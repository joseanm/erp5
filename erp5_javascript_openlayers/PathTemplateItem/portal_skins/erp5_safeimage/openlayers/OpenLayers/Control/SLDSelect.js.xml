<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.8</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>SLDSelect.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Control.js\n
 * @requires OpenLayers/Layer/WMS.js\n
 * @requires OpenLayers/Handler/RegularPolygon.js\n
 * @requires OpenLayers/Handler/Polygon.js\n
 * @requires OpenLayers/Handler/Path.js\n
 * @requires OpenLayers/Handler/Click.js\n
 * @requires OpenLayers/Filter/Spatial.js\n
 * @requires OpenLayers/Format/SLD/v1_0_0.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Control.SLDSelect\n
 * Perform selections on WMS layers using Styled Layer Descriptor (SLD)\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Control>\n
 */\n
OpenLayers.Control.SLDSelect = OpenLayers.Class(OpenLayers.Control, {\n
\n
    /** \n
     * APIProperty: events\n
     * {<OpenLayers.Events>} Events instance for listeners and triggering\n
     *     control specific events.\n
     *\n
     * Register a listener for a particular event with the following syntax:\n
     * (code)\n
     * control.events.register(type, obj, listener);\n
     * (end)\n
     *\n
     * Supported event types (in addition to those from <OpenLayers.Control.events>):\n
     * selected - Triggered when a selection occurs.  Listeners receive an \n
     *     event with *filters* and *layer* properties.  Filters will be an \n
     *     array of OpenLayers.Filter objects created in order to perform \n
     *     the particular selection.\n
     */\n
\n
    /**\n
     * APIProperty: clearOnDeactivate\n
     * {Boolean} Should the selection be cleared when the control is \n
     *     deactivated. Default value is false.\n
     */\n
    clearOnDeactivate: false,\n
\n
    /**\n
     * APIProperty: layers\n
     * {Array(<OpenLayers.Layer.WMS>)} The WMS layers this control will work \n
     *     on.\n
     */\n
    layers: null,\n
\n
    /**\n
     * Property: callbacks\n
     * {Object} The functions that are sent to the handler for callback\n
     */\n
    callbacks: null,\n
\n
    /**\n
     * APIProperty: selectionSymbolizer\n
     * {Object} Determines the styling of the selected objects. Default is\n
     *     a selection in red.\n
     */\n
    selectionSymbolizer: {\n
        \'Polygon\': {fillColor: \'#FF0000\', stroke: false},\n
        \'Line\': {strokeColor: \'#FF0000\', strokeWidth: 2},\n
        \'Point\': {graphicName: \'square\', fillColor: \'#FF0000\', pointRadius: 5}\n
    },\n
\n
    /**\n
     * APIProperty: layerOptions\n
     * {Object} The options to apply to the selection layer, by default the\n
     *     selection layer will be kept out of the layer switcher.\n
     */\n
    layerOptions: null,\n
\n
    /**\n
     * APIProperty: handlerOptions\n
     * {Object} Used to set non-default properties on the control\'s handler\n
     */\n
    handlerOptions: null,\n
\n
    /**\n
     * APIProperty: sketchStyle\n
     * {<OpenLayers.Style>|Object} Style or symbolizer to use for the sketch\n
     * handler. The recommended way of styling the sketch layer, however, is\n
     * to configure an <OpenLayers.StyleMap> in the layerOptions of the\n
     * <handlerOptions>:\n
     * \n
     * (code)\n
     * new OpenLayers.Control.SLDSelect(OpenLayers.Handler.Path, {\n
     *     handlerOptions: {\n
     *         layerOptions: {\n
     *             styleMap: new OpenLayers.StyleMap({\n
     *                 "default": {strokeColor: "yellow"}\n
     *             });\n
     *         }\n
     *     }\n
     * });\n
     * (end)\n
     */\n
    sketchStyle: null,\n
\n
    /**\n
     * APIProperty: wfsCache\n
     * {Object} Cache to use for storing parsed results from\n
     *     <OpenLayers.Format.WFSDescribeFeatureType.read>. If not provided,\n
     *     these will be cached on the prototype.\n
     */\n
    wfsCache: {},\n
\n
    /**\n
     * APIProperty: layerCache\n
     * {Object} Cache to use for storing references to the selection layers.\n
     *     Normally each source layer will have exactly 1 selection layer of\n
     *     type OpenLayers.Layer.WMS. If not provided, layers will\n
     *     be cached on the prototype. Note that if <clearOnDeactivate> is\n
     *     true, the layer will no longer be cached after deactivating the\n
     *     control.\n
     */\n
    layerCache: {},\n
\n
    /**\n
     * Constructor: OpenLayers.Control.SLDSelect\n
     * Create a new control for selecting features in WMS layers using\n
     *     Styled Layer Descriptor (SLD).\n
     *\n
     * Parameters:\n
     * handler - {<OpenLayers.Class>} A sketch handler class. This determines\n
     *     the type of selection, e.g. box (<OpenLayers.Handler.Box>), point\n
     *     (<OpenLayers.Handler.Point>), path (<OpenLayers.Handler.Path>) or\n
     *     polygon (<OpenLayers.Handler.Polygon>) selection. To use circle\n
     *     type selection, use <OpenLayers.Handler.RegularPolygon> and pass\n
     *     the number of desired sides (e.g. 40) as "sides" property to the\n
     *     <handlerOptions>.\n
     * options - {Object} An object containing all configuration properties for\n
     *     the control.\n
     *\n
     * Valid options:\n
     * layers - Array({<OpenLayers.Layer.WMS>}) The layers to perform the\n
     *     selection on.\n
     */\n
    initialize: function(handler, options) {\n
        OpenLayers.Control.prototype.initialize.apply(this, [options]);\n
\n
        this.callbacks = OpenLayers.Util.extend({done: this.select, \n
            click: this.select}, this.callbacks);\n
        this.handlerOptions = this.handlerOptions || {};\n
        this.layerOptions = OpenLayers.Util.applyDefaults(this.layerOptions, {\n
            displayInLayerSwitcher: false,\n
            tileOptions: {maxGetUrlLength: 2048}\n
        });\n
        if (this.sketchStyle) {\n
            this.handlerOptions.layerOptions = OpenLayers.Util.applyDefaults(\n
                this.handlerOptions.layerOptions,\n
                {styleMap: new OpenLayers.StyleMap({"default": this.sketchStyle})}\n
            );\n
        }\n
        this.handler = new handler(this, this.callbacks, this.handlerOptions);\n
    },\n
\n
    /**\n
     * APIMethod: destroy\n
     * Take care of things that are not handled in superclass.\n
     */\n
    destroy: function() {\n
        for (var key in this.layerCache) {\n
            delete this.layerCache[key];\n
        }\n
        for (var key in this.wfsCache) {\n
            delete this.wfsCache[key];\n
        }\n
        OpenLayers.Control.prototype.destroy.apply(this, arguments);\n
    },\n
\n
    /**\n
     * Method: coupleLayerVisiblity\n
     * Couple the selection layer and the source layer with respect to\n
     *     layer visibility. So if the source layer is turned off, the\n
     *     selection layer is also turned off.\n
     *\n
     * Context: \n
     * - {<OpenLayers.Layer>}\n
     *\n
     * Parameters:\n
     * evt - {Object}\n
     */\n
    coupleLayerVisiblity: function(evt) {\n
        this.setVisibility(evt.object.getVisibility());\n
    },\n
\n
    /**\n
     * Method: createSelectionLayer\n
     * Creates a "clone" from the source layer in which the selection can\n
     * be drawn. This ensures both the source layer and the selection are \n
     * visible and not only the selection.\n
     *\n
     * Parameters:\n
     * source - {<OpenLayers.Layer.WMS>} The source layer on which the selection\n
     *     is performed.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Layer.WMS>} A WMS layer with maxGetUrlLength configured to 2048\n
     *     since SLD selections can easily get quite long.\n
     */\n
    createSelectionLayer: function(source) {\n
        // check if we already have a selection layer for the source layer\n
        var selectionLayer;\n
        if (!this.layerCache[source.id]) {\n
            selectionLayer = new OpenLayers.Layer.WMS(source.name, \n
                source.url, source.params, \n
                OpenLayers.Util.applyDefaults(\n
                    this.layerOptions,\n
                    source.getOptions())\n
            );\n
            this.layerCache[source.id] = selectionLayer;\n
            // make sure the layers are coupled wrt visibility, but only\n
            // if they are not displayed in the layer switcher, because in\n
            // that case the user cannot control visibility.\n
            if (this.layerOptions.displayInLayerSwitcher === false) {\n
                source.events.on({\n
                    "visibilitychanged": this.coupleLayerVisiblity,\n
                    scope: selectionLayer});\n
            }\n
            this.map.addLayer(selectionLayer);\n
        } else {\n
            selectionLayer = this.layerCache[source.id];\n
        }\n
        return selectionLayer;\n
    },\n
\n
    /**\n
     * Method: createSLD\n
     * Create the SLD document for the layer using the supplied filters.\n
     *\n
     * Parameters:\n
     * layer - {<OpenLayers.Layer.WMS>}\n
     * filters - Array({<OpenLayers.Filter>}) The filters to be applied.\n
     * geometryAttributes - Array({Object}) The geometry attributes of the \n
     *     layer.\n
     *\n
     * Returns:\n
     * {String} The SLD document generated as a string.\n
     */\n
    createSLD: function(layer, filters, geometryAttributes) {\n
        var sld = {version: "1.0.0", namedLayers: {}};\n
        var layerNames = [layer.params.LAYERS].join(",").split(",");\n
        for (var i=0, len=layerNames.length; i<len; i++) { \n
            var name = layerNames[i];\n
            sld.namedLayers[name] = {name: name, userStyles: []};\n
            var symbolizer = this.selectionSymbolizer;\n
            var geometryAttribute = geometryAttributes[i];\n
            if (geometryAttribute.type.indexOf(\'Polygon\') >= 0) {\n
                symbolizer = {Polygon: this.selectionSymbolizer[\'Polygon\']};\n
            } else if (geometryAttribute.type.indexOf(\'LineString\') >= 0) {\n
                symbolizer = {Line: this.selectionSymbolizer[\'Line\']};\n
            } else if (geometryAttribute.type.indexOf(\'Point\') >= 0) {\n
                symbolizer = {Point: this.selectionSymbolizer[\'Point\']};\n
            }\n
            var filter = filters[i];\n
            sld.namedLayers[name].userStyles.push({name: \'default\', rules: [\n
                new OpenLayers.Rule({symbolizer: symbolizer, \n
                    filter: filter, \n
                    maxScaleDenominator: layer.options.minScale})\n
            ]});\n
        }\n
        return new OpenLayers.Format.SLD({srsName: this.map.getProjection()}).write(sld);\n
    },\n
\n
    /**\n
     * Method: parseDescribeLayer\n
     * Parse the SLD WMS DescribeLayer response and issue the corresponding\n
     *     WFS DescribeFeatureType request\n
     *\n
     * request - {XMLHttpRequest} The request object.\n
     */\n
    parseDescribeLayer: function(request) {\n
        var format = new OpenLayers.Format.WMSDescribeLayer();\n
        var doc = request.responseXML;\n
        if(!doc || !doc.documentElement) {\n
            doc = request.responseText;\n
        }\n
        var describeLayer = format.read(doc);\n
        var typeNames = [];\n
        var url = null;\n
        for (var i=0, len=describeLayer.length; i<len; i++) {\n
            // perform a WFS DescribeFeatureType request\n
            if (describeLayer[i].owsType == "WFS") {\n
                typeNames.push(describeLayer[i].typeName);\n
                url = describeLayer[i].owsURL;\n
            }\n
        }\n
        var options = {\n
            url: url,\n
            params: {\n
                SERVICE: "WFS",\n
                TYPENAME: typeNames.toString(),\n
                REQUEST: "DescribeFeatureType",\n
                VERSION: "1.0.0"\n
            },\n
            callback: function(request) {\n
                var format = new OpenLayers.Format.WFSDescribeFeatureType();\n
                var doc = request.responseXML;\n
                if(!doc || !doc.documentElement) {\n
                    doc = request.responseText;\n
                }\n
                var describeFeatureType = format.read(doc);\n
                this.control.wfsCache[this.layer.id] = describeFeatureType;\n
                this.control._queue && this.control.applySelection();\n
            },\n
            scope: this\n
        };\n
        OpenLayers.Request.GET(options);\n
    },\n
\n
   /**\n
    * Method: getGeometryAttributes\n
    * Look up the geometry attributes from the WFS DescribeFeatureType response\n
    *\n
    * Parameters:\n
    * layer - {<OpenLayers.Layer.WMS>} The layer for which to look up the \n
    *     geometry attributes.\n
    *\n
    * Returns:\n
    * Array({Object}) Array of geometry attributes\n
    */ \n
   getGeometryAttributes: function(layer) {\n
        var result = [];\n
        var cache = this.wfsCache[layer.id];\n
        for (var i=0, len=cache.featureTypes.length; i<len; i++) {\n
            var typeName = cache.featureTypes[i];\n
            var properties = typeName.properties;\n
            for (var j=0, lenj=properties.length; j < lenj; j++) {\n
                var property = properties[j];\n
                var type = property.type;\n
                if ((type.indexOf(\'LineString\') >= 0) ||\n
                    (type.indexOf(\'GeometryAssociationType\') >=0) ||\n
                    (type.indexOf(\'GeometryPropertyType\') >= 0) ||\n
                    (type.indexOf(\'Point\') >= 0) ||\n
                    (type.indexOf(\'Polygon\') >= 0) ) {\n
                        result.push(property);\n
                }\n
            }\n
        }\n
        return result;\n
    },\n
\n
    /**\n
     * APIMethod: activate\n
     * Activate the control. Activating the control will perform a SLD WMS\n
     *     DescribeLayer request followed by a WFS DescribeFeatureType request\n
     *     so that the proper symbolizers can be chosen based on the geometry\n
     *     type.\n
     */\n
    activate: function() {\n
        var activated = OpenLayers.Control.prototype.activate.call(this);\n
        if(activated) {\n
            for (var i=0, len=this.layers.length; i<len; i++) {\n
                var layer = this.layers[i];\n
                if (layer && !this.wfsCache[layer.id]) {\n
                    var options = {\n
                        url: layer.url,\n
                        params: {\n
                            SERVICE: "WMS",\n
                            VERSION: layer.params.VERSION,\n
                            LAYERS: layer.params.LAYERS,\n
                            REQUEST: "DescribeLayer"\n
                        },\n
                        callback: this.parseDescribeLayer,\n
                        scope: {layer: layer, control: this}\n
                    };\n
                    OpenLayers.Request.GET(options);\n
                }\n
            }\n
        }\n
        return activated;\n
    },\n
\n
    /**\n
     * APIMethod: deactivate\n
     * Deactivate the control. If clearOnDeactivate is true, remove the\n
     *     selection layer(s).\n
     */\n
    deactivate: function() {\n
        var deactivated = OpenLayers.Control.prototype.deactivate.call(this);\n
        if(deactivated) {\n
            for (var i=0, len=this.layers.length; i<len; i++) {\n
                var layer = this.layers[i];\n
                if (layer && this.clearOnDeactivate === true) {\n
                    var layerCache = this.layerCache;\n
                    var selectionLayer = layerCache[layer.id];\n
                    if (selectionLayer) {\n
                        layer.events.un({\n
                            "visibilitychanged": this.coupleLayerVisiblity,\n
                            scope: selectionLayer});\n
                        selectionLayer.destroy();\n
                        delete layerCache[layer.id];\n
                    }\n
                }\n
            }\n
        }\n
        return deactivated;\n
    },\n
\n
    /**\n
     * APIMethod: setLayers\n
     * Set the layers on which the selection should be performed.  Call the \n
     *     setLayers method if the layer(s) to be used change and the same \n
     *     control should be used on a new set of layers.\n
     *     If the control is already active, it will be active after the new\n
     *     set of layers is set.\n
     *\n
     * Parameters:\n
     * layers - {Array(<OpenLayers.Layer.WMS>)}  The new set of layers on which \n
     *     the selection should be performed.\n
     */\n
    setLayers: function(layers) {\n
        if(this.active) {\n
            this.deactivate();\n
            this.layers = layers;\n
            this.activate();\n
        } else {\n
            this.layers = layers;\n
        }\n
    },\n
\n
    /**\n
     * Function: createFilter\n
     * Create the filter to be used in the SLD.\n
     *\n
     * Parameters:\n
     * geometryAttribute - {Object} Used to get the name of the geometry \n
     *     attribute which is needed for constructing the spatial filter.\n
     * geometry - {<OpenLayers.Geometry>} The geometry to use.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Filter.Spatial>} The spatial filter created.\n
     */\n
    createFilter: function(geometryAttribute, geometry) {\n
        var filter = null;\n
        if (this.handler instanceof OpenLayers.Handler.RegularPolygon) {\n
            // box\n
            if (this.handler.irregular === true) {\n
                filter = new OpenLayers.Filter.Spatial({\n
                    type: OpenLayers.Filter.Spatial.BBOX,\n
                    property: geometryAttribute.name,\n
                    value: geometry.getBounds()}\n
                );\n
            } else {\n
                filter = new OpenLayers.Filter.Spatial({\n
                    type: OpenLayers.Filter.Spatial.INTERSECTS,\n
                    property: geometryAttribute.name,\n
                    value: geometry}\n
                );\n
            }\n
        } else if (this.handler instanceof OpenLayers.Handler.Polygon) {\n
            filter = new OpenLayers.Filter.Spatial({\n
                type: OpenLayers.Filter.Spatial.INTERSECTS,\n
                property: geometryAttribute.name,\n
                value: geometry}\n
            );\n
        } else if (this.handler instanceof OpenLayers.Handler.Path) {\n
            // if source layer is point based, use DWITHIN instead\n
            if (geometryAttribute.type.indexOf(\'Point\') >= 0) {\n
                filter = new OpenLayers.Filter.Spatial({\n
                    type: OpenLayers.Filter.Spatial.DWITHIN,\n
                    property: geometryAttribute.name,\n
                    distance: this.map.getExtent().getWidth()*0.01 ,\n
                    distanceUnits: this.map.getUnits(),\n
                    value: geometry}\n
                );\n
            } else {\n
                filter = new OpenLayers.Filter.Spatial({\n
                    type: OpenLayers.Filter.Spatial.INTERSECTS,\n
                    property: geometryAttribute.name,\n
                    value: geometry}\n
                );\n
            }\n
        } else if (this.handler instanceof OpenLayers.Handler.Click) {\n
            if (geometryAttribute.type.indexOf(\'Polygon\') >= 0) {\n
                filter = new OpenLayers.Filter.Spatial({\n
                    type: OpenLayers.Filter.Spatial.INTERSECTS,\n
                    property: geometryAttribute.name,\n
                    value: geometry}\n
                );\n
            } else {\n
                filter = new OpenLayers.Filter.Spatial({\n
                    type: OpenLayers.Filter.Spatial.DWITHIN,\n
                    property: geometryAttribute.name,\n
                    distance: this.map.getExtent().getWidth()*0.01 ,\n
                    distanceUnits: this.map.getUnits(),\n
                    value: geometry}\n
                );\n
            }\n
        }\n
        return filter;\n
    },\n
\n
    /**\n
     * Method: select\n
     * When the handler is done, use SLD_BODY on the selection layer to\n
     *     display the selection in the map.\n
     *\n
     * Parameters:\n
     * geometry - {Object} or {<OpenLayers.Geometry>}\n
     */\n
    select: function(geometry) {\n
        this._queue = function() {\n
            for (var i=0, len=this.layers.length; i<len; i++) {\n
                var layer = this.layers[i];\n
                var geometryAttributes = this.getGeometryAttributes(layer);\n
                var filters = [];\n
                for (var j=0, lenj=geometryAttributes.length; j<lenj; j++) {\n
                    var geometryAttribute = geometryAttributes[j];\n
                    if (geometryAttribute !== null) {\n
                        // from the click handler we will not get an actual \n
                        // geometry so transform\n
                        if (!(geometry instanceof OpenLayers.Geometry)) {\n
                            var point = this.map.getLonLatFromPixel(\n
                                geometry.xy);\n
                            geometry = new OpenLayers.Geometry.Point(\n
                                point.lon, point.lat);\n
                        }\n
                        var filter = this.createFilter(geometryAttribute,\n
                        geometry);\n
                        if (filter !== null) {\n
                            filters.push(filter);\n
                        }\n
                    }\n
                }\n
    \n
                var selectionLayer = this.createSelectionLayer(layer);\n
                var sld = this.createSLD(layer, filters, geometryAttributes);\n
    \n
                this.events.triggerEvent("selected", {\n
                    layer: layer,\n
                    filters: filters\n
                });\n
    \n
                selectionLayer.mergeNewParams({SLD_BODY: sld});\n
                delete this._queue;\n
            }\n
        };\n
        this.applySelection();\n
    },\n
    \n
    /**\n
     * Method: applySelection\n
     * Checks if all required wfs data is cached, and applies the selection\n
     */\n
    applySelection: function() {\n
        var canApply = true;\n
        for (var i=0, len=this.layers.length; i<len; i++) {\n
            if(!this.wfsCache[this.layers[i].id]) {\n
                canApply = false;\n
                break;\n
            }\n
        }\n
        canApply && this._queue.call(this);\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Control.SLDSelect"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>21423</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
