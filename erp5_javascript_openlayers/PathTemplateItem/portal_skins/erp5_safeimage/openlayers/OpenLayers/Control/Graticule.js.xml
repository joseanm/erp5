<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.8</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Graticule.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Control.js\n
 * @requires OpenLayers/Lang.js\n
 * @requires OpenLayers/Rule.js\n
 * @requires OpenLayers/StyleMap.js\n
 * @requires OpenLayers/Layer/Vector.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Control.Graticule\n
 * The Graticule displays a grid of latitude/longitude lines reprojected on\n
 * the map.  \n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Control>\n
 *  \n
 */\n
OpenLayers.Control.Graticule = OpenLayers.Class(OpenLayers.Control, {\n
\n
    /**\n
     * APIProperty: autoActivate\n
     * {Boolean} Activate the control when it is added to a map. Default is\n
     *     true. \n
     */\n
    autoActivate: true,\n
    \n
    /**\n
    * APIProperty: intervals\n
    * {Array(Float)} A list of possible graticule widths in degrees.\n
    */\n
    intervals: [ 45, 30, 20, 10, 5, 2, 1,\n
                 0.5, 0.2, 0.1, 0.05, 0.01, \n
                 0.005, 0.002, 0.001 ],\n
\n
    /**\n
     * APIProperty: displayInLayerSwitcher\n
     * {Boolean} Allows the Graticule control to be switched on and off by \n
     *     LayerSwitcher control. Defaults is true.\n
     */\n
    displayInLayerSwitcher: true,\n
\n
    /**\n
     * APIProperty: visible\n
     * {Boolean} should the graticule be initially visible (default=true)\n
     */\n
    visible: true,\n
\n
    /**\n
     * APIProperty: numPoints\n
     * {Integer} The number of points to use in each graticule line.  Higher\n
     * numbers result in a smoother curve for projected maps \n
     */\n
    numPoints: 50,\n
\n
    /**\n
     * APIProperty: targetSize\n
     * {Integer} The maximum size of the grid in pixels on the map\n
     */\n
    targetSize: 200,\n
\n
    /**\n
     * APIProperty: layerName\n
     * {String} The name to be displayed in the layer switcher, default is set \n
     *     by {<OpenLayers.Lang>}.\n
     */\n
    layerName: null,\n
\n
    /**\n
     * APIProperty: labelled\n
     * {Boolean} Should the graticule lines be labelled?. default=true\n
     */\n
    labelled: true,\n
\n
    /**\n
     * APIProperty: labelFormat\n
     * {String} the format of the labels, default = \'dm\'. See\n
     * <OpenLayers.Util.getFormattedLonLat> for other options.\n
     */\n
    labelFormat: \'dm\',\n
\n
    /**\n
     * APIProperty: lineSymbolizer\n
     * {symbolizer} the symbolizer used to render lines\n
     */\n
    lineSymbolizer: {\n
                strokeColor: "#333",\n
                strokeWidth: 1,\n
                strokeOpacity: 0.5\n
            },\n
\n
    /**\n
     * APIProperty: labelSymbolizer\n
     * {symbolizer} the symbolizer used to render labels\n
     */\n
     labelSymbolizer: {},\n
\n
    /**\n
     * Property: gratLayer\n
     * {<OpenLayers.Layer.Vector>} vector layer used to draw the graticule on\n
     */\n
    gratLayer: null,\n
\n
    /**\n
     * Constructor: OpenLayers.Control.Graticule\n
     * Create a new graticule control to display a grid of latitude longitude\n
     * lines.\n
     * \n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be used\n
     *     to extend the control.\n
     */\n
    initialize: function(options) {\n
        options = options || {};\n
        options.layerName = options.layerName || OpenLayers.i18n("Graticule");\n
        OpenLayers.Control.prototype.initialize.apply(this, [options]);\n
        \n
        this.labelSymbolizer.stroke = false;\n
        this.labelSymbolizer.fill = false;\n
        this.labelSymbolizer.label = "${label}";\n
        this.labelSymbolizer.labelAlign = "${labelAlign}";\n
        this.labelSymbolizer.labelXOffset = "${xOffset}";\n
        this.labelSymbolizer.labelYOffset = "${yOffset}";\n
    },\n
\n
    /**\n
     * APIMethod: destroy\n
     */\n
    destroy: function() {\n
        this.deactivate();        \n
        OpenLayers.Control.prototype.destroy.apply(this, arguments);        \n
        if (this.gratLayer) {\n
            this.gratLayer.destroy();\n
            this.gratLayer = null;\n
        }\n
    },\n
    \n
    /**\n
     * Method: draw\n
     *\n
     * initializes the graticule layer and does the initial update\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    draw: function() {\n
        OpenLayers.Control.prototype.draw.apply(this, arguments);\n
        if (!this.gratLayer) {\n
            var gratStyle = new OpenLayers.Style({},{\n
                rules: [new OpenLayers.Rule({\'symbolizer\':\n
                    {"Point":this.labelSymbolizer,\n
                     "Line":this.lineSymbolizer}\n
                })]\n
            });\n
            this.gratLayer = new OpenLayers.Layer.Vector(this.layerName, {\n
                styleMap: new OpenLayers.StyleMap({\'default\':gratStyle}),\n
                visibility: this.visible,\n
                displayInLayerSwitcher: this.displayInLayerSwitcher\n
            });\n
        }\n
        return this.div;\n
    },\n
\n
     /**\n
     * APIMethod: activate\n
     */\n
    activate: function() {\n
        if (OpenLayers.Control.prototype.activate.apply(this, arguments)) {\n
            this.map.addLayer(this.gratLayer);\n
            this.map.events.register(\'moveend\', this, this.update);     \n
            this.update();\n
            return true;            \n
        } else {\n
            return false;\n
        }\n
    },\n
    \n
    /**\n
     * APIMethod: deactivate\n
     */\n
    deactivate: function() {\n
        if (OpenLayers.Control.prototype.deactivate.apply(this, arguments)) {\n
            this.map.events.unregister(\'moveend\', this, this.update);\n
            this.map.removeLayer(this.gratLayer);\n
            return true;\n
        } else {\n
            return false;\n
        }\n
    },\n
    /**\n
     * Method: update\n
     *\n
     * calculates the grid to be displayed and actually draws it\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    update: function() {\n
        //wait for the map to be initialized before proceeding\n
        var mapBounds = this.map.getExtent();\n
        if (!mapBounds) {\n
            return;\n
        }\n
        \n
        //clear out the old grid\n
        this.gratLayer.destroyFeatures();\n
        \n
        //get the projection objects required\n
        var llProj = new OpenLayers.Projection("EPSG:4326");\n
        var mapProj = this.map.getProjectionObject();\n
        var mapRes = this.map.getResolution();\n
        \n
        //if the map is in lon/lat, then the lines are straight and only one\n
        //point is required\n
        if (mapProj.proj && mapProj.proj.projName == "longlat") {\n
            this.numPoints = 1;\n
        }\n
        \n
        //get the map center in EPSG:4326\n
        var mapCenter = this.map.getCenter(); //lon and lat here are really map x and y\n
        var mapCenterLL = new OpenLayers.Pixel(mapCenter.lon, mapCenter.lat);\n
        OpenLayers.Projection.transform(mapCenterLL, mapProj, llProj);\n
        \n
        /* This block of code determines the lon/lat interval to use for the\n
         * grid by calculating the diagonal size of one grid cell at the map\n
         * center.  Iterates through the intervals array until the diagonal\n
         * length is less than the targetSize option.\n
         */\n
        //find lat/lon interval that results in a grid of less than the target size\n
        var testSq = this.targetSize*mapRes;\n
        testSq *= testSq;   //compare squares rather than doing a square root to save time\n
        var llInterval;\n
        for (var i=0; i<this.intervals.length; ++i) {\n
            llInterval = this.intervals[i];   //could do this for both x and y??\n
            var delta = llInterval/2;  \n
            var p1 = mapCenterLL.offset({x: -delta, y: -delta});  //test coords in EPSG:4326 space\n
            var p2 = mapCenterLL.offset({x: delta, y: delta});\n
            OpenLayers.Projection.transform(p1, llProj, mapProj); // convert them back to map projection\n
            OpenLayers.Projection.transform(p2, llProj, mapProj);\n
            var distSq = (p1.x-p2.x)*(p1.x-p2.x) + (p1.y-p2.y)*(p1.y-p2.y);\n
            if (distSq <= testSq) {\n
                break;\n
            }\n
        }\n
        //alert(llInterval);\n
        \n
        //round the LL center to an even number based on the interval\n
        mapCenterLL.x = Math.floor(mapCenterLL.x/llInterval)*llInterval;\n
        mapCenterLL.y = Math.floor(mapCenterLL.y/llInterval)*llInterval;\n
        //TODO adjust for minutses/seconds?\n
        \n
        /* The following 2 blocks calculate the nodes of the grid along a \n
         * line of constant longitude (then latitiude) running through the\n
         * center of the map until it reaches the map edge.  The calculation\n
         * goes from the center in both directions to the edge.\n
         */\n
        //get the central longitude line, increment the latitude\n
        var iter = 0;\n
        var centerLonPoints = [mapCenterLL.clone()];\n
        var newPoint = mapCenterLL.clone();\n
        var mapXY;\n
        do {\n
            newPoint = newPoint.offset({x: 0, y: llInterval});\n
            mapXY = OpenLayers.Projection.transform(newPoint.clone(), llProj, mapProj);\n
            centerLonPoints.unshift(newPoint);\n
        } while (mapBounds.containsPixel(mapXY) && ++iter<1000);\n
        newPoint = mapCenterLL.clone();\n
        do {          \n
            newPoint = newPoint.offset({x: 0, y: -llInterval});\n
            mapXY = OpenLayers.Projection.transform(newPoint.clone(), llProj, mapProj);\n
            centerLonPoints.push(newPoint);\n
        } while (mapBounds.containsPixel(mapXY) && ++iter<1000);\n
        \n
        //get the central latitude line, increment the longitude\n
        iter = 0;\n
        var centerLatPoints = [mapCenterLL.clone()];\n
        newPoint = mapCenterLL.clone();\n
        do {\n
            newPoint = newPoint.offset({x: -llInterval, y: 0});\n
            mapXY = OpenLayers.Projection.transform(newPoint.clone(), llProj, mapProj);\n
            centerLatPoints.unshift(newPoint);\n
        } while (mapBounds.containsPixel(mapXY) && ++iter<1000);\n
        newPoint = mapCenterLL.clone();\n
        do {          \n
            newPoint = newPoint.offset({x: llInterval, y: 0});\n
            mapXY = OpenLayers.Projection.transform(newPoint.clone(), llProj, mapProj);\n
            centerLatPoints.push(newPoint);\n
        } while (mapBounds.containsPixel(mapXY) && ++iter<1000);\n
        \n
        //now generate a line for each node in the central lat and lon lines\n
        //first loop over constant longitude\n
        var lines = [];\n
        for(var i=0; i < centerLatPoints.length; ++i) {\n
            var lon = centerLatPoints[i].x;\n
            var pointList = [];\n
            var labelPoint = null;\n
            var latEnd = Math.min(centerLonPoints[0].y, 90);\n
            var latStart = Math.max(centerLonPoints[centerLonPoints.length - 1].y, -90);\n
            var latDelta = (latEnd - latStart)/this.numPoints;\n
            var lat = latStart;\n
            for(var j=0; j<= this.numPoints; ++j) {\n
                var gridPoint = new OpenLayers.Geometry.Point(lon,lat);\n
                gridPoint.transform(llProj, mapProj);\n
                pointList.push(gridPoint);\n
                lat += latDelta;\n
                if (gridPoint.y >= mapBounds.bottom && !labelPoint) {\n
                    labelPoint = gridPoint;\n
                }\n
            }\n
            if (this.labelled) {\n
                //keep track of when this grid line crosses the map bounds to set\n
                //the label position\n
                //labels along the bottom, add 10 pixel offset up into the map\n
                //TODO add option for labels on top\n
                var labelPos = new OpenLayers.Geometry.Point(labelPoint.x,mapBounds.bottom);\n
                var labelAttrs = {\n
                    value: lon,\n
                    label: this.labelled?OpenLayers.Util.getFormattedLonLat(lon, "lon", this.labelFormat):"",\n
                    labelAlign: "cb",\n
                    xOffset: 0,\n
                    yOffset: 2\n
                }; \n
                this.gratLayer.addFeatures(new OpenLayers.Feature.Vector(labelPos,labelAttrs));\n
            }\n
            var geom = new OpenLayers.Geometry.LineString(pointList);\n
            lines.push(new OpenLayers.Feature.Vector(geom));\n
        }\n
        \n
        //now draw the lines of constant latitude\n
        for (var j=0; j < centerLonPoints.length; ++j) {\n
            lat = centerLonPoints[j].y;\n
            if (lat<-90 || lat>90) {  //latitudes only valid between -90 and 90\n
                continue;\n
            }\n
            var pointList = [];\n
            var lonStart = centerLatPoints[0].x;\n
            var lonEnd = centerLatPoints[centerLatPoints.length - 1].x;\n
            var lonDelta = (lonEnd - lonStart)/this.numPoints;\n
            var lon = lonStart;\n
            var labelPoint = null;\n
            for(var i=0; i <= this.numPoints ; ++i) {\n
                var gridPoint = new OpenLayers.Geometry.Point(lon,lat);\n
                gridPoint.transform(llProj, mapProj);\n
                pointList.push(gridPoint);\n
                lon += lonDelta;\n
                if (gridPoint.x < mapBounds.right) {\n
                    labelPoint = gridPoint;\n
                }\n
            }\n
            if (this.labelled) {\n
                //keep track of when this grid line crosses the map bounds to set\n
                //the label position\n
                //labels along the right, 30 pixel offset left into the map\n
                //TODO add option for labels on left\n
                var labelPos = new OpenLayers.Geometry.Point(mapBounds.right, labelPoint.y); \n
                var labelAttrs = {\n
                    value: lat,\n
                    label: this.labelled?OpenLayers.Util.getFormattedLonLat(lat, "lat", this.labelFormat):"",\n
                    labelAlign: "rb",\n
                    xOffset: -2,\n
                    yOffset: 2\n
                }; \n
                this.gratLayer.addFeatures(new OpenLayers.Feature.Vector(labelPos,labelAttrs));\n
            }\n
            var geom = new OpenLayers.Geometry.LineString(pointList);\n
            lines.push(new OpenLayers.Feature.Vector(geom));\n
          }\n
          this.gratLayer.addFeatures(lines);\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Control.Graticule"\n
});\n
\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>14041</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
