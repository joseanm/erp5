<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.81</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Measure.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Control.js\n
 * @requires OpenLayers/Feature/Vector.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Control.Measure\n
 * Allows for drawing of features for measurements.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Control>\n
 */\n
OpenLayers.Control.Measure = OpenLayers.Class(OpenLayers.Control, {\n
\n
    /** \n
     * APIProperty: events\n
     * {<OpenLayers.Events>} Events instance for listeners and triggering\n
     *     control specific events.\n
     *\n
     * Register a listener for a particular event with the following syntax:\n
     * (code)\n
     * control.events.register(type, obj, listener);\n
     * (end)\n
     *\n
     * Supported event types (in addition to those from <OpenLayers.Control.events>):\n
     * measure - Triggered when a measurement sketch is complete.  Listeners\n
     *      will receive an event with measure, units, order, and geometry\n
     *      properties.\n
     * measurepartial - Triggered when a new point is added to the\n
     *      measurement sketch or if the <immediate> property is true and the\n
     *      measurement sketch is modified.  Listeners receive an event with measure,\n
     *      units, order, and geometry.\n
     */\n
\n
    /**\n
     * APIProperty: handlerOptions\n
     * {Object} Used to set non-default properties on the control\'s handler\n
     */\n
    handlerOptions: null,\n
    \n
    /**\n
     * Property: callbacks\n
     * {Object} The functions that are sent to the handler for callback\n
     */\n
    callbacks: null,\n
    \n
    /**\n
     * Property: displaySystem\n
     * {String} Display system for output measurements.  Supported values\n
     *     are \'english\', \'metric\', and \'geographic\'.  Default is \'metric\'.\n
     */\n
    displaySystem: \'metric\',\n
    \n
    /**\n
     * Property: geodesic\n
     * {Boolean} Calculate geodesic metrics instead of planar metrics.  This\n
     *     requires that geometries can be transformed into Geographic/WGS84\n
     *     (if that is not already the map projection).  Default is false.\n
     */\n
    geodesic: false,\n
    \n
    /**\n
     * Property: displaySystemUnits\n
     * {Object} Units for various measurement systems.  Values are arrays\n
     *     of unit abbreviations (from OpenLayers.INCHES_PER_UNIT) in decreasing\n
     *     order of length.\n
     */\n
    displaySystemUnits: {\n
        geographic: [\'dd\'],\n
        english: [\'mi\', \'ft\', \'in\'],\n
        metric: [\'km\', \'m\']\n
    },\n
\n
    /**\n
     * Property: delay\n
     * {Number} Number of milliseconds between clicks before the event is\n
     *     considered a double-click.  The "measurepartial" event will not\n
     *     be triggered if the sketch is completed within this time.  This\n
     *     is required for IE where creating a browser reflow (if a listener\n
     *     is modifying the DOM by displaying the measurement values) messes\n
     *     with the dblclick listener in the sketch handler.\n
     */\n
    partialDelay: 300,\n
\n
    /**\n
     * Property: delayedTrigger\n
     * {Number} Timeout id of trigger for measurepartial.\n
     */\n
    delayedTrigger: null,\n
\n
    /**\n
     * APIProperty: persist\n
     * {Boolean} Keep the temporary measurement sketch drawn after the\n
     *     measurement is complete.  The geometry will persist until a new\n
     *     measurement is started, the control is deactivated, or <cancel> is\n
     *     called.\n
     */\n
    persist: false,\n
\n
    /**\n
     * APIProperty: immediate\n
     * {Boolean} Activates the immediate measurement so that the "measurepartial"\n
     *     event is also fired once the measurement sketch is modified.\n
     *     Default is false.\n
     */\n
    immediate : false,\n
\n
    /**\n
     * Constructor: OpenLayers.Control.Measure\n
     * \n
     * Parameters:\n
     * handler - {<OpenLayers.Handler>} \n
     * options - {Object} \n
     */\n
    initialize: function(handler, options) {\n
        OpenLayers.Control.prototype.initialize.apply(this, [options]);\n
        var callbacks = {done: this.measureComplete,\n
            point: this.measurePartial};\n
        if (this.immediate){\n
            callbacks.modify = this.measureImmediate;\n
        }\n
        this.callbacks = OpenLayers.Util.extend(callbacks, this.callbacks);\n
\n
        // let the handler options override, so old code that passes \'persist\' \n
        // directly to the handler does not need an update\n
        this.handlerOptions = OpenLayers.Util.extend(\n
            {persist: this.persist}, this.handlerOptions\n
        );\n
        this.handler = new handler(this, this.callbacks, this.handlerOptions);\n
    },\n
    \n
    /**\n
     * APIMethod: deactivate\n
     */\n
    deactivate: function() {\n
        this.cancelDelay();\n
        return OpenLayers.Control.prototype.deactivate.apply(this, arguments);\n
    },\n
\n
    /**\n
     * APIMethod: cancel\n
     * Stop the control from measuring.  If <persist> is true, the temporary\n
     *     sketch will be erased.\n
     */\n
    cancel: function() {\n
        this.cancelDelay();\n
        this.handler.cancel();\n
    },\n
\n
    /**\n
     * APIMethod: setImmediate\n
     * Sets the <immediate> property. Changes the activity of immediate\n
     * measurement.\n
     */\n
    setImmediate: function(immediate) {\n
        this.immediate = immediate;\n
        if (this.immediate){\n
            this.callbacks.modify = this.measureImmediate;\n
        } else {\n
            delete this.callbacks.modify;\n
        }\n
    },\n
    \n
    /**\n
     * Method: updateHandler\n
     *\n
     * Parameters:\n
     * handler - {Function} One of the sketch handler constructors.\n
     * options - {Object} Options for the handler.\n
     */\n
    updateHandler: function(handler, options) {\n
        var active = this.active;\n
        if(active) {\n
            this.deactivate();\n
        }\n
        this.handler = new handler(this, this.callbacks, options);\n
        if(active) {\n
            this.activate();\n
        }\n
    },\n
\n
    /**\n
     * Method: measureComplete\n
     * Called when the measurement sketch is done.\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     */\n
    measureComplete: function(geometry) {\n
        this.cancelDelay();\n
        this.measure(geometry, "measure");\n
    },\n
    \n
    /**\n
     * Method: measurePartial\n
     * Called each time a new point is added to the measurement sketch.\n
     *\n
     * Parameters:\n
     * point - {<OpenLayers.Geometry.Point>} The last point added.\n
     * geometry - {<OpenLayers.Geometry>} The sketch geometry.\n
     */\n
    measurePartial: function(point, geometry) {\n
        this.cancelDelay();\n
        geometry = geometry.clone();\n
        // when we\'re wating for a dblclick, we have to trigger measurepartial\n
        // after some delay to deal with reflow issues in IE\n
        if (this.handler.freehandMode(this.handler.evt)) {\n
            // no dblclick in freehand mode\n
            this.measure(geometry, "measurepartial");\n
        } else {\n
            this.delayedTrigger = window.setTimeout(\n
                OpenLayers.Function.bind(function() {\n
                    this.delayedTrigger = null;\n
                    this.measure(geometry, "measurepartial");\n
                }, this),\n
                this.partialDelay\n
            );\n
        }\n
    },\n
\n
    /**\n
     * Method: measureImmediate\n
     * Called each time the measurement sketch is modified.\n
     * \n
     * Parameters: point - {<OpenLayers.Geometry.Point>} The point at the\n
     * mouseposition. feature - {<OpenLayers.Feature.Vector>} The sketch feature.\n
     */\n
    measureImmediate : function(point, feature, drawing) {\n
        if (drawing && !this.handler.freehandMode(this.handler.evt)) {\n
            this.cancelDelay();\n
            this.measure(feature.geometry, "measurepartial");\n
        }\n
    },\n
\n
    /**\n
     * Method: cancelDelay\n
     * Cancels the delay measurement that measurePartial began.\n
     */\n
    cancelDelay: function() {\n
        if (this.delayedTrigger !== null) {\n
            window.clearTimeout(this.delayedTrigger);\n
            this.delayedTrigger = null;\n
        }\n
    },\n
\n
    /**\n
     * Method: measure\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * eventType - {String}\n
     */\n
    measure: function(geometry, eventType) {\n
        var stat, order;\n
        if(geometry.CLASS_NAME.indexOf(\'LineString\') > -1) {\n
            stat = this.getBestLength(geometry);\n
            order = 1;\n
        } else {\n
            stat = this.getBestArea(geometry);\n
            order = 2;\n
        }\n
        this.events.triggerEvent(eventType, {\n
            measure: stat[0],\n
            units: stat[1],\n
            order: order,\n
            geometry: geometry\n
        });\n
    },\n
    \n
    /**\n
     * Method: getBestArea\n
     * Based on the <displaySystem> returns the area of a geometry.\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     *\n
     * Returns:\n
     * {Array([Float, String])}  Returns a two item array containing the\n
     *     area and the units abbreviation.\n
     */\n
    getBestArea: function(geometry) {\n
        var units = this.displaySystemUnits[this.displaySystem];\n
        var unit, area;\n
        for(var i=0, len=units.length; i<len; ++i) {\n
            unit = units[i];\n
            area = this.getArea(geometry, unit);\n
            if(area > 1) {\n
                break;\n
            }\n
        }\n
        return [area, unit];\n
    },\n
    \n
    /**\n
     * Method: getArea\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * units - {String} Unit abbreviation\n
     *\n
     * Returns:\n
     * {Float} The geometry area in the given units.\n
     */\n
    getArea: function(geometry, units) {\n
        var area, geomUnits;\n
        if(this.geodesic) {\n
            area = geometry.getGeodesicArea(this.map.getProjectionObject());\n
            geomUnits = "m";\n
        } else {\n
            area = geometry.getArea();\n
            geomUnits = this.map.getUnits();\n
        }\n
        var inPerDisplayUnit = OpenLayers.INCHES_PER_UNIT[units];\n
        if(inPerDisplayUnit) {\n
            var inPerMapUnit = OpenLayers.INCHES_PER_UNIT[geomUnits];\n
            area *= Math.pow((inPerMapUnit / inPerDisplayUnit), 2);\n
        }\n
        return area;\n
    },\n
    \n
    /**\n
     * Method: getBestLength\n
     * Based on the <displaySystem> returns the length of a geometry.\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     *\n
     * Returns:\n
     * {Array([Float, String])}  Returns a two item array containing the\n
     *     length and the units abbreviation.\n
     */\n
    getBestLength: function(geometry) {\n
        var units = this.displaySystemUnits[this.displaySystem];\n
        var unit, length;\n
        for(var i=0, len=units.length; i<len; ++i) {\n
            unit = units[i];\n
            length = this.getLength(geometry, unit);\n
            if(length > 1) {\n
                break;\n
            }\n
        }\n
        return [length, unit];\n
    },\n
\n
    /**\n
     * Method: getLength\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * units - {String} Unit abbreviation\n
     *\n
     * Returns:\n
     * {Float} The geometry length in the given units.\n
     */\n
    getLength: function(geometry, units) {\n
        var length, geomUnits;\n
        if(this.geodesic) {\n
            length = geometry.getGeodesicLength(this.map.getProjectionObject());\n
            geomUnits = "m";\n
        } else {\n
            length = geometry.getLength();\n
            geomUnits = this.map.getUnits();\n
        }\n
        var inPerDisplayUnit = OpenLayers.INCHES_PER_UNIT[units];\n
        if(inPerDisplayUnit) {\n
            var inPerMapUnit = OpenLayers.INCHES_PER_UNIT[geomUnits];\n
            length *= (inPerMapUnit / inPerDisplayUnit);\n
        }\n
        return length;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Control.Measure"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>11790</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
