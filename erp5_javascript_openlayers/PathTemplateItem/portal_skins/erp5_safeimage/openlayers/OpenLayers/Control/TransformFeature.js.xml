<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.81</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>TransformFeature.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/Control.js\n
 * @requires OpenLayers/Control/DragFeature.js\n
 * @requires OpenLayers/Feature/Vector.js\n
 * @requires OpenLayers/Geometry/LineString.js\n
 * @requires OpenLayers/Geometry/Point.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Control.TransformFeature\n
 * Control to transform features with a standard transformation box.\n
 *\n
 * Inherits From:\n
 *  - <OpenLayers.Control>\n
 */\n
OpenLayers.Control.TransformFeature = OpenLayers.Class(OpenLayers.Control, {\n
\n
    /** \n
     * APIProperty: events\n
     * {<OpenLayers.Events>} Events instance for listeners and triggering\n
     *     control specific events.\n
     *\n
     * Register a listener for a particular event with the following syntax:\n
     * (code)\n
     * control.events.register(type, obj, listener);\n
     * (end)\n
     *\n
     * Supported event types (in addition to those from <OpenLayers.Control.events>):\n
     * beforesetfeature - Triggered before a feature is set for\n
     *     tranformation. The feature will not be set if a listener returns\n
     *     false. Listeners receive a *feature* property, with the feature\n
     *     that will be set for transformation. Listeners are allowed to\n
     *     set the control\'s *scale*, *ratio* and *rotation* properties,\n
     *     which will set the initial scale, ratio and rotation of the\n
     *     feature, like the <setFeature> method\'s initialParams argument.\n
     * setfeature - Triggered when a feature is set for tranformation.\n
     *     Listeners receive a *feature* property, with the feature that\n
     *     is now set for transformation.\n
     * beforetransform - Triggered while dragging, before a feature is\n
     *     transformed. The feature will not be transformed if a listener\n
     *     returns false (but the box still will). Listeners receive one or\n
     *     more of *center*, *scale*, *ratio* and *rotation*. The *center*\n
     *     property is an <OpenLayers.Geometry.Point> object with the new\n
     *     center of the transformed feature, the others are Floats with the\n
     *     scale, ratio or rotation change since the last transformation.\n
     * transform - Triggered while dragging, when a feature is transformed.\n
     *     Listeners receive an event object with one or more of *center*,\n
     *     scale*, *ratio* and *rotation*. The *center* property is an\n
     *     <OpenLayers.Geometry.Point> object with the new center of the\n
     *     transformed feature, the others are Floats with the scale, ratio\n
     *     or rotation change of the feature since the last transformation.\n
     * transformcomplete - Triggered after dragging. Listeners receive\n
     *     an event object with the transformed *feature*.\n
     */\n
\n
    /**\n
     * APIProperty: geometryTypes\n
     * {Array(String)} To restrict transformation to a limited set of geometry\n
     *     types, send a list of strings corresponding to the geometry class\n
     *     names.\n
     */\n
    geometryTypes: null,\n
\n
    /**\n
     * Property: layer\n
     * {<OpenLayers.Layer.Vector>}\n
     */\n
    layer: null,\n
    \n
    /**\n
     * APIProperty: preserveAspectRatio\n
     * {Boolean} set to true to not change the feature\'s aspect ratio.\n
     */\n
    preserveAspectRatio: false,\n
    \n
    /**\n
     * APIProperty: rotate\n
     * {Boolean} set to false if rotation should be disabled. Default is true.\n
     *     To be passed with the constructor or set when the control is not\n
     *     active.\n
     */\n
    rotate: true,\n
    \n
    /**\n
     * APIProperty: feature\n
     * {<OpenLayers.Feature.Vector>} Feature currently available for\n
     *     transformation. Read-only, use <setFeature> to set it manually.\n
     */\n
    feature: null,\n
    \n
    /**\n
     * APIProperty: renderIntent\n
     * {String|Object} Render intent for the transformation box and\n
     *     handles. A symbolizer object can also be provided here.\n
     */\n
    renderIntent: "temporary",\n
    \n
    /**\n
     * APIProperty: rotationHandleSymbolizer\n
     * {Object|String} Optional. A custom symbolizer for the rotation handles.\n
     *     A render intent can also be provided here. Defaults to\n
     *     (code)\n
     *     {\n
     *         stroke: false,\n
     *         pointRadius: 10,\n
     *         fillOpacity: 0,\n
     *         cursor: "pointer"\n
     *     }\n
     *     (end)\n
     */\n
    rotationHandleSymbolizer: null,\n
    \n
    /**\n
     * APIProperty: box\n
     * {<OpenLayers.Feature.Vector>} The transformation box rectangle.\n
     *     Read-only.\n
     */\n
    box: null,\n
    \n
    /**\n
     * APIProperty: center\n
     * {<OpenLayers.Geometry.Point>} The center of the feature bounds.\n
     * Read-only.\n
     */\n
    center: null,\n
    \n
    /**\n
     * APIProperty: scale\n
     * {Float} The scale of the feature, relative to the scale the time the\n
     *     feature was set. Read-only, except for *beforesetfeature*\n
     *     listeners.\n
     */\n
    scale: 1,\n
    \n
    /**\n
     * APIProperty: ratio\n
     * {Float} The ratio of the feature relative to the ratio the time the\n
     *     feature was set. Read-only, except for *beforesetfeature*\n
     *     listeners.\n
     */\n
    ratio: 1,\n
    \n
    /**\n
     * Property: rotation\n
     * {Integer} the current rotation angle of the box. Read-only, except for\n
     *     *beforesetfeature* listeners.\n
     */\n
    rotation: 0,\n
    \n
    /**\n
     * APIProperty: handles\n
     * {Array(<OpenLayers.Feature.Vector>)} The 8 handles currently available\n
     *     for scaling/resizing. Numbered counterclockwise, starting from the\n
     *     southwest corner. Read-only.\n
     */\n
    handles: null,\n
    \n
    /**\n
     * APIProperty: rotationHandles\n
     * {Array(<OpenLayers.Feature.Vector>)} The 4 rotation handles currently\n
     *     available for rotating. Numbered counterclockwise, starting from\n
     *     the southwest corner. Read-only.\n
     */\n
    rotationHandles: null,\n
    \n
    /**\n
     * Property: dragControl\n
     * {<OpenLayers.Control.DragFeature>}\n
     */\n
    dragControl: null,\n
    \n
    /**\n
     * APIProperty: irregular\n
     * {Boolean} Make scaling/resizing work irregularly. If true then\n
     *     dragging a handle causes the feature to resize in the direction\n
     *     of movement. If false then the feature resizes symetrically\n
     *     about it\'s center.\n
     */\n
    irregular: false,\n
    \n
    /**\n
     * Constructor: OpenLayers.Control.TransformFeature\n
     * Create a new transform feature control.\n
     *\n
     * Parameters:\n
     * layer - {<OpenLayers.Layer.Vector>} Layer that contains features that\n
     *     will be transformed.\n
     * options - {Object} Optional object whose properties will be set on the\n
     *     control.\n
     */\n
    initialize: function(layer, options) {\n
        OpenLayers.Control.prototype.initialize.apply(this, [options]);\n
\n
        this.layer = layer;\n
\n
        if(!this.rotationHandleSymbolizer) {\n
            this.rotationHandleSymbolizer = {\n
                stroke: false,\n
                pointRadius: 10,\n
                fillOpacity: 0,\n
                cursor: "pointer"\n
            };\n
        }\n
\n
        this.createBox();\n
        this.createControl();        \n
    },\n
    \n
    /**\n
     * APIMethod: activate\n
     * Activates the control.\n
     */\n
    activate: function() {\n
        var activated = false;\n
        if(OpenLayers.Control.prototype.activate.apply(this, arguments)) {\n
            this.dragControl.activate();\n
            this.layer.addFeatures([this.box]);\n
            this.rotate && this.layer.addFeatures(this.rotationHandles);\n
            this.layer.addFeatures(this.handles);        \n
            activated = true;\n
        }\n
        return activated;\n
    },\n
    \n
    /**\n
     * APIMethod: deactivate\n
     * Deactivates the control.\n
     */\n
    deactivate: function() {\n
        var deactivated = false;\n
        if(OpenLayers.Control.prototype.deactivate.apply(this, arguments)) {\n
            this.layer.removeFeatures(this.handles);\n
            this.rotate && this.layer.removeFeatures(this.rotationHandles);\n
            this.layer.removeFeatures([this.box]);\n
            this.dragControl.deactivate();\n
            deactivated = true;\n
        }\n
        return deactivated;\n
    },\n
    \n
    /**\n
     * Method: setMap\n
     * \n
     * Parameters:\n
     * map - {<OpenLayers.Map>}\n
     */\n
    setMap: function(map) {\n
        this.dragControl.setMap(map);\n
        OpenLayers.Control.prototype.setMap.apply(this, arguments);\n
    },\n
\n
    /**\n
     * APIMethod: setFeature\n
     * Place the transformation box on a feature and start transforming it.\n
     * If the control is not active, it will be activated.\n
     * \n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>}\n
     * initialParams - {Object} Initial values for rotation, scale or ratio.\n
     *     Setting a rotation value here will cause the transformation box to\n
     *     start rotated. Setting a scale or ratio will not affect the\n
     *     transormation box, but applications may use this to keep track of\n
     *     scale and ratio of a feature across multiple transforms.\n
     */\n
    setFeature: function(feature, initialParams) {\n
        initialParams = OpenLayers.Util.applyDefaults(initialParams, {\n
            rotation: 0,\n
            scale: 1,\n
            ratio: 1\n
        });\n
\n
        var oldRotation = this.rotation;\n
        var oldCenter = this.center;\n
        OpenLayers.Util.extend(this, initialParams);\n
\n
        var cont = this.events.triggerEvent("beforesetfeature",\n
            {feature: feature}\n
        );\n
        if (cont === false) {\n
            return;\n
        }\n
\n
        this.feature = feature;\n
        this.activate();\n
\n
        this._setfeature = true;\n
\n
        var featureBounds = this.feature.geometry.getBounds();\n
        this.box.move(featureBounds.getCenterLonLat());\n
        this.box.geometry.rotate(-oldRotation, oldCenter);\n
        this._angle = 0;\n
\n
        var ll;\n
        if(this.rotation) {\n
            var geom = feature.geometry.clone();\n
            geom.rotate(-this.rotation, this.center);\n
            var box = new OpenLayers.Feature.Vector(\n
                geom.getBounds().toGeometry());\n
            box.geometry.rotate(this.rotation, this.center);\n
            this.box.geometry.rotate(this.rotation, this.center);\n
            this.box.move(box.geometry.getBounds().getCenterLonLat());\n
            var llGeom = box.geometry.components[0].components[0];\n
            ll = llGeom.getBounds().getCenterLonLat();\n
        } else {\n
            ll = new OpenLayers.LonLat(featureBounds.left, featureBounds.bottom);\n
        }\n
        this.handles[0].move(ll);\n
        \n
        delete this._setfeature;\n
\n
        this.events.triggerEvent("setfeature", {feature: feature});\n
    },\n
    \n
    /**\n
     * APIMethod: unsetFeature\n
     * Remove the transformation box off any feature.\n
     * If the control is active, it will be deactivated first.\n
     */\n
    unsetFeature: function() {\n
        if (this.active) {\n
            this.deactivate();\n
        } else {\n
            this.feature = null;\n
            this.rotation = 0;\n
            this.scale = 1;\n
            this.ratio = 1;\n
        }\n
    },\n
    \n
    /**\n
     * Method: createBox\n
     * Creates the box with all handles and transformation handles.\n
     */\n
    createBox: function() {\n
        var control = this;\n
        \n
        this.center = new OpenLayers.Geometry.Point(0, 0);\n
        this.box = new OpenLayers.Feature.Vector(\n
            new OpenLayers.Geometry.LineString([\n
                new OpenLayers.Geometry.Point(-1, -1),\n
                new OpenLayers.Geometry.Point(0, -1),\n
                new OpenLayers.Geometry.Point(1, -1),\n
                new OpenLayers.Geometry.Point(1, 0),\n
                new OpenLayers.Geometry.Point(1, 1),\n
                new OpenLayers.Geometry.Point(0, 1),\n
                new OpenLayers.Geometry.Point(-1, 1),\n
                new OpenLayers.Geometry.Point(-1, 0),\n
                new OpenLayers.Geometry.Point(-1, -1)\n
            ]), null,\n
            typeof this.renderIntent == "string" ? null : this.renderIntent\n
        );\n
        \n
        // Override for box move - make sure that the center gets updated\n
        this.box.geometry.move = function(x, y) {\n
            control._moving = true;\n
            OpenLayers.Geometry.LineString.prototype.move.apply(this, arguments);\n
            control.center.move(x, y);\n
            delete control._moving;\n
        };\n
\n
        // Overrides for vertex move, resize and rotate - make sure that\n
        // handle and rotationHandle geometries are also moved, resized and\n
        // rotated.\n
        var vertexMoveFn = function(x, y) {\n
            OpenLayers.Geometry.Point.prototype.move.apply(this, arguments);\n
            this._rotationHandle && this._rotationHandle.geometry.move(x, y);\n
            this._handle.geometry.move(x, y);\n
        };\n
        var vertexResizeFn = function(scale, center, ratio) {\n
            OpenLayers.Geometry.Point.prototype.resize.apply(this, arguments);\n
            this._rotationHandle && this._rotationHandle.geometry.resize(\n
                scale, center, ratio);\n
            this._handle.geometry.resize(scale, center, ratio);\n
        };\n
        var vertexRotateFn = function(angle, center) {\n
            OpenLayers.Geometry.Point.prototype.rotate.apply(this, arguments);\n
            this._rotationHandle && this._rotationHandle.geometry.rotate(\n
                angle, center);\n
            this._handle.geometry.rotate(angle, center);\n
        };\n
        \n
        // Override for handle move - make sure that the box and other handles\n
        // are updated, and finally transform the feature.\n
        var handleMoveFn = function(x, y) {\n
            var oldX = this.x, oldY = this.y;\n
            OpenLayers.Geometry.Point.prototype.move.call(this, x, y);\n
            if(control._moving) {\n
                return;\n
            }\n
            var evt = control.dragControl.handlers.drag.evt;\n
            var preserveAspectRatio = !control._setfeature &&\n
                control.preserveAspectRatio;\n
            var reshape = !preserveAspectRatio && !(evt && evt.shiftKey);\n
            var oldGeom = new OpenLayers.Geometry.Point(oldX, oldY);\n
            var centerGeometry = control.center;\n
            this.rotate(-control.rotation, centerGeometry);\n
            oldGeom.rotate(-control.rotation, centerGeometry);\n
            var dx1 = this.x - centerGeometry.x;\n
            var dy1 = this.y - centerGeometry.y;\n
            var dx0 = dx1 - (this.x - oldGeom.x);\n
            var dy0 = dy1 - (this.y - oldGeom.y);\n
            if (control.irregular && !control._setfeature) {\n
               dx1 -= (this.x - oldGeom.x) / 2;\n
               dy1 -= (this.y - oldGeom.y) / 2;\n
            }\n
            this.x = oldX;\n
            this.y = oldY;\n
            var scale, ratio = 1;\n
            if (reshape) {\n
                scale = Math.abs(dy0) < 0.00001 ? 1 : dy1 / dy0;\n
                ratio = (Math.abs(dx0) < 0.00001 ? 1 : (dx1 / dx0)) / scale;\n
            } else {\n
                var l0 = Math.sqrt((dx0 * dx0) + (dy0 * dy0));\n
                var l1 = Math.sqrt((dx1 * dx1) + (dy1 * dy1));\n
                scale = l1 / l0;\n
            }\n
\n
            // rotate the box to 0 before resizing - saves us some\n
            // calculations and is inexpensive because we don\'t drawFeature.\n
            control._moving = true;\n
            control.box.geometry.rotate(-control.rotation, centerGeometry);\n
            delete control._moving;\n
\n
            control.box.geometry.resize(scale, centerGeometry, ratio);\n
            control.box.geometry.rotate(control.rotation, centerGeometry);\n
            control.transformFeature({scale: scale, ratio: ratio});\n
            if (control.irregular && !control._setfeature) {\n
               var newCenter = centerGeometry.clone();\n
               newCenter.x += Math.abs(oldX - centerGeometry.x) < 0.00001 ? 0 : (this.x - oldX);\n
               newCenter.y += Math.abs(oldY - centerGeometry.y) < 0.00001 ? 0 : (this.y - oldY);\n
               control.box.geometry.move(this.x - oldX, this.y - oldY);\n
               control.transformFeature({center: newCenter});\n
            }\n
        };\n
        \n
        // Override for rotation handle move - make sure that the box and\n
        // other handles are updated, and finally transform the feature.\n
        var rotationHandleMoveFn = function(x, y){\n
            var oldX = this.x, oldY = this.y;\n
            OpenLayers.Geometry.Point.prototype.move.call(this, x, y);\n
            if(control._moving) {\n
                return;\n
            }\n
            var evt = control.dragControl.handlers.drag.evt;\n
            var constrain = (evt && evt.shiftKey) ? 45 : 1;\n
            var centerGeometry = control.center;\n
            var dx1 = this.x - centerGeometry.x;\n
            var dy1 = this.y - centerGeometry.y;\n
            var dx0 = dx1 - x;\n
            var dy0 = dy1 - y;\n
            this.x = oldX;\n
            this.y = oldY;\n
            var a0 = Math.atan2(dy0, dx0);\n
            var a1 = Math.atan2(dy1, dx1);\n
            var angle = a1 - a0;\n
            angle *= 180 / Math.PI;\n
            control._angle = (control._angle + angle) % 360;\n
            var diff = control.rotation % constrain;\n
            if(Math.abs(control._angle) >= constrain || diff !== 0) {\n
                angle = Math.round(control._angle / constrain) * constrain -\n
                    diff;\n
                control._angle = 0;\n
                control.box.geometry.rotate(angle, centerGeometry);\n
                control.transformFeature({rotation: angle});\n
            } \n
        };\n
\n
        var handles = new Array(8);\n
        var rotationHandles = new Array(4);\n
        var geom, handle, rotationHandle;\n
        var positions = ["sw", "s", "se", "e", "ne", "n", "nw", "w"];\n
        for(var i=0; i<8; ++i) {\n
            geom = this.box.geometry.components[i];\n
            handle = new OpenLayers.Feature.Vector(geom.clone(), {\n
                role: positions[i] + "-resize"\n
            }, typeof this.renderIntent == "string" ? null :\n
                this.renderIntent);\n
            if(i % 2 == 0) {\n
                rotationHandle = new OpenLayers.Feature.Vector(geom.clone(), {\n
                    role: positions[i] + "-rotate"\n
                }, typeof this.rotationHandleSymbolizer == "string" ?\n
                    null : this.rotationHandleSymbolizer);\n
                rotationHandle.geometry.move = rotationHandleMoveFn;\n
                geom._rotationHandle = rotationHandle;\n
                rotationHandles[i/2] = rotationHandle;\n
            }\n
            geom.move = vertexMoveFn;\n
            geom.resize = vertexResizeFn;\n
            geom.rotate = vertexRotateFn;\n
            handle.geometry.move = handleMoveFn;\n
            geom._handle = handle;\n
            handles[i] = handle;\n
        }\n
        \n
        this.rotationHandles = rotationHandles;\n
        this.handles = handles;\n
    },\n
    \n
    /**\n
     * Method: createControl\n
     * Creates a DragFeature control for this control.\n
     */\n
    createControl: function() {\n
        var control = this;\n
        this.dragControl = new OpenLayers.Control.DragFeature(this.layer, {\n
            documentDrag: true,\n
            // avoid moving the feature itself - move the box instead\n
            moveFeature: function(pixel) {\n
                if(this.feature === control.feature) {\n
                    this.feature = control.box;\n
                }\n
                OpenLayers.Control.DragFeature.prototype.moveFeature.apply(this,\n
                    arguments);\n
            },\n
            // transform while dragging\n
            onDrag: function(feature, pixel) {\n
                if(feature === control.box) {\n
                    control.transformFeature({center: control.center});\n
                }\n
            },\n
            // set a new feature\n
            onStart: function(feature, pixel) {\n
                var eligible = !control.geometryTypes ||\n
                    OpenLayers.Util.indexOf(control.geometryTypes,\n
                        feature.geometry.CLASS_NAME) !== -1;\n
                var i = OpenLayers.Util.indexOf(control.handles, feature);\n
                i += OpenLayers.Util.indexOf(control.rotationHandles,\n
                    feature);\n
                if(feature !== control.feature && feature !== control.box &&\n
                                                        i == -2 && eligible) {\n
                    control.setFeature(feature);\n
                }\n
            },\n
            onComplete: function(feature, pixel) {\n
                control.events.triggerEvent("transformcomplete",\n
                    {feature: control.feature});\n
            }\n
        });\n
    },\n
    \n
    /**\n
     * Method: drawHandles\n
     * Draws the handles to match the box.\n
     */\n
    drawHandles: function() {\n
        var layer = this.layer;\n
        for(var i=0; i<8; ++i) {\n
            if(this.rotate && i % 2 === 0) {\n
                layer.drawFeature(this.rotationHandles[i/2],\n
                    this.rotationHandleSymbolizer);\n
            }\n
            layer.drawFeature(this.handles[i], this.renderIntent);\n
        }\n
    },\n
    \n
    /**\n
     * Method: transformFeature\n
     * Transforms the feature.\n
     * \n
     * Parameters:\n
     * mods - {Object} An object with optional scale, ratio, rotation and\n
     *     center properties.\n
     */\n
    transformFeature: function(mods) {\n
        if(!this._setfeature) {\n
            this.scale *= (mods.scale || 1);\n
            this.ratio *= (mods.ratio || 1);\n
            var oldRotation = this.rotation;\n
            this.rotation = (this.rotation + (mods.rotation || 0)) % 360;\n
            \n
            if(this.events.triggerEvent("beforetransform", mods) !== false) {\n
                var feature = this.feature;\n
                var geom = feature.geometry;\n
                var center = this.center;\n
                geom.rotate(-oldRotation, center);\n
                if(mods.scale || mods.ratio) {\n
                    geom.resize(mods.scale, center, mods.ratio);\n
                } else if(mods.center) {\n
                    feature.move(mods.center.getBounds().getCenterLonLat());\n
                }\n
                geom.rotate(this.rotation, center);\n
                this.layer.drawFeature(feature);\n
                feature.toState(OpenLayers.State.UPDATE);\n
                this.events.triggerEvent("transform", mods);\n
            }\n
        }\n
        this.layer.drawFeature(this.box, this.renderIntent);\n
        this.drawHandles();\n
    },\n
        \n
    /**\n
     * APIMethod: destroy\n
     * Take care of things that are not handled in superclass.\n
     */\n
    destroy: function() {\n
        var geom;\n
        for(var i=0; i<8; ++i) {\n
            geom = this.box.geometry.components[i];\n
            geom._handle.destroy();\n
            geom._handle = null;\n
            geom._rotationHandle && geom._rotationHandle.destroy();\n
            geom._rotationHandle = null;\n
        }\n
        this.center = null;\n
        this.feature = null;\n
        this.handles = null;\n
        this.rotationHandleSymbolizer = null;\n
        this.rotationHandles = null;\n
        this.box.destroy();\n
        this.box = null;\n
        this.layer = null;\n
        this.dragControl.destroy();\n
        this.dragControl = null;\n
        OpenLayers.Control.prototype.destroy.apply(this, arguments);\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Control.TransformFeature"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>23368</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
