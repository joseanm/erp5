<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.81</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>WMTSGetFeatureInfo.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/Control.js\n
 * @requires OpenLayers/Handler/Click.js\n
 * @requires OpenLayers/Handler/Hover.js\n
 * @requires OpenLayers/Request.js\n
 * @requires OpenLayers/Format/WMSGetFeatureInfo.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Control.WMTSGetFeatureInfo\n
 * The WMTSGetFeatureInfo control uses a WMTS query to get information about a \n
 *     point on the map.  The information may be in a display-friendly format \n
 *     such as HTML, or a machine-friendly format such as GML, depending on the \n
 *     server\'s capabilities and the client\'s configuration.  This control \n
 *     handles click or hover events, attempts to parse the results using an \n
 *     OpenLayers.Format, and fires a \'getfeatureinfo\' event for each layer\n
 *     queried.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Control>\n
 */\n
OpenLayers.Control.WMTSGetFeatureInfo = OpenLayers.Class(OpenLayers.Control, {\n
\n
   /**\n
     * APIProperty: hover\n
     * {Boolean} Send GetFeatureInfo requests when mouse stops moving.\n
     *     Default is false.\n
     */\n
    hover: false,\n
    \n
    /**\n
     * Property: requestEncoding\n
     * {String} One of "KVP" or "REST".  Only KVP encoding is supported at this \n
     *     time.\n
     */\n
    requestEncoding: "KVP",\n
\n
    /**\n
     * APIProperty: drillDown\n
     * {Boolean} Drill down over all WMTS layers in the map. When\n
     *     using drillDown mode, hover is not possible.  A getfeatureinfo event\n
     *     will be fired for each layer queried.\n
     */\n
    drillDown: false,\n
\n
    /**\n
     * APIProperty: maxFeatures\n
     * {Integer} Maximum number of features to return from a WMTS query. This\n
     *     sets the feature_count parameter on WMTS GetFeatureInfo\n
     *     requests.\n
     */\n
    maxFeatures: 10,\n
\n
    /** APIProperty: clickCallback\n
     *  {String} The click callback to register in the\n
     *      {<OpenLayers.Handler.Click>} object created when the hover\n
     *      option is set to false. Default is "click".\n
     */\n
    clickCallback: "click",\n
    \n
    /**\n
     * Property: layers\n
     * {Array(<OpenLayers.Layer.WMTS>)} The layers to query for feature info.\n
     *     If omitted, all map WMTS layers will be considered.\n
     */\n
    layers: null,\n
\n
    /**\n
     * APIProperty: queryVisible\n
     * {Boolean} Filter out hidden layers when searching the map for layers to \n
     *     query.  Default is true.\n
     */\n
    queryVisible: true,\n
\n
    /**\n
     * Property: infoFormat\n
     * {String} The mimetype to request from the server\n
     */\n
    infoFormat: \'text/html\',\n
    \n
    /**\n
     * Property: vendorParams\n
     * {Object} Additional parameters that will be added to the request, for\n
     * WMTS implementations that support them. This could e.g. look like\n
     * (start code)\n
     * {\n
     *     radius: 5\n
     * }\n
     * (end)\n
     */\n
    vendorParams: {},\n
    \n
    /**\n
     * Property: format\n
     * {<OpenLayers.Format>} A format for parsing GetFeatureInfo responses.\n
     *     Default is <OpenLayers.Format.WMSGetFeatureInfo>.\n
     */\n
    format: null,\n
    \n
    /**\n
     * Property: formatOptions\n
     * {Object} Optional properties to set on the format (if one is not provided\n
     *     in the <format> property.\n
     */\n
    formatOptions: null,\n
\n
    /**\n
     * APIProperty: handlerOptions\n
     * {Object} Additional options for the handlers used by this control, e.g.\n
     * (start code)\n
     * {\n
     *     "click": {delay: 100},\n
     *     "hover": {delay: 300}\n
     * }\n
     * (end)\n
     */\n
    handlerOptions: null,\n
    \n
    /**\n
     * Property: handler\n
     * {Object} Reference to the <OpenLayers.Handler> for this control\n
     */\n
    handler: null,\n
    \n
    /**\n
     * Property: hoverRequest\n
     * {<OpenLayers.Request>} contains the currently running hover request\n
     *     (if any).\n
     */\n
    hoverRequest: null,\n
    \n
    /** \n
     * APIProperty: events\n
     * {<OpenLayers.Events>} Events instance for listeners and triggering\n
     *     control specific events.\n
     *\n
     * Register a listener for a particular event with the following syntax:\n
     * (code)\n
     * control.events.register(type, obj, listener);\n
     * (end)\n
     *\n
     * Supported event types (in addition to those from <OpenLayers.Control.events>):\n
     * beforegetfeatureinfo - Triggered before each request is sent.\n
     *      The event object has an *xy* property with the position of the \n
     *      mouse click or hover event that triggers the request and a *layer*\n
     *      property referencing the layer about to be queried.  If a listener\n
     *      returns false, the request will not be issued.\n
     * getfeatureinfo - Triggered when a GetFeatureInfo response is received.\n
     *      The event object has a *text* property with the body of the\n
     *      response (String), a *features* property with an array of the\n
     *      parsed features, an *xy* property with the position of the mouse\n
     *      click or hover event that triggered the request, a *layer* property\n
     *      referencing the layer queried and a *request* property with the \n
     *      request itself. If drillDown is set to true, one event will be fired\n
     *      for each layer queried.\n
     * exception - Triggered when a GetFeatureInfo request fails (with a \n
     *      status other than 200) or whenparsing fails.  Listeners will receive \n
     *      an event with *request*, *xy*, and *layer*  properties.  In the case \n
     *      of a parsing error, the event will also contain an *error* property.\n
     */\n
    \n
    /** \n
     * Property: pending\n
     * {Number}  The number of pending requests.\n
     */\n
    pending: 0,\n
\n
    /**\n
     * Constructor: <OpenLayers.Control.WMTSGetFeatureInfo>\n
     *\n
     * Parameters:\n
     * options - {Object} \n
     */\n
    initialize: function(options) {\n
        options = options || {};\n
        options.handlerOptions = options.handlerOptions || {};\n
\n
        OpenLayers.Control.prototype.initialize.apply(this, [options]);\n
        \n
        if (!this.format) {\n
            this.format = new OpenLayers.Format.WMSGetFeatureInfo(\n
                options.formatOptions\n
            );\n
        }\n
        \n
        if (this.drillDown === true) {\n
            this.hover = false;\n
        }\n
\n
        if (this.hover) {\n
            this.handler = new OpenLayers.Handler.Hover(\n
                this, {\n
                    move: this.cancelHover,\n
                    pause: this.getInfoForHover\n
                },\n
                OpenLayers.Util.extend(\n
                    this.handlerOptions.hover || {}, {delay: 250}\n
                )\n
            );\n
        } else {\n
            var callbacks = {};\n
            callbacks[this.clickCallback] = this.getInfoForClick;\n
            this.handler = new OpenLayers.Handler.Click(\n
                this, callbacks, this.handlerOptions.click || {}\n
            );\n
        }\n
    },\n
\n
    /**\n
     * Method: getInfoForClick \n
     * Called on click\n
     *\n
     * Parameters:\n
     * evt - {<OpenLayers.Event>} \n
     */\n
    getInfoForClick: function(evt) {\n
        this.request(evt.xy, {});\n
    },\n
   \n
    /**\n
     * Method: getInfoForHover\n
     * Pause callback for the hover handler\n
     *\n
     * Parameters:\n
     * evt - {Object}\n
     */\n
    getInfoForHover: function(evt) {\n
        this.request(evt.xy, {hover: true});\n
    },\n
\n
    /**\n
     * Method: cancelHover\n
     * Cancel callback for the hover handler\n
     */\n
    cancelHover: function() {\n
        if (this.hoverRequest) {\n
            --this.pending;\n
            if (this.pending <= 0) {\n
                OpenLayers.Element.removeClass(this.map.viewPortDiv, "olCursorWait");\n
                this.pending = 0;\n
            }            \n
            this.hoverRequest.abort();\n
            this.hoverRequest = null;\n
        }\n
    },\n
\n
    /**\n
     * Method: findLayers\n
     * Internal method to get the layers, independent of whether we are\n
     *     inspecting the map or using a client-provided array\n
     */\n
    findLayers: function() {\n
        var candidates = this.layers || this.map.layers;\n
        var layers = [];\n
        var layer;\n
        for (var i=candidates.length-1; i>=0; --i) {\n
            layer = candidates[i];\n
            if (layer instanceof OpenLayers.Layer.WMTS &&\n
                layer.requestEncoding === this.requestEncoding &&\n
                (!this.queryVisible || layer.getVisibility())) {\n
                layers.push(layer);\n
                if (!this.drillDown || this.hover) {\n
                    break;\n
                }\n
            }\n
        }\n
        return layers;\n
    },\n
    \n
    /**\n
     * Method: buildRequestOptions\n
     * Build an object with the relevant options for the GetFeatureInfo request.\n
     *\n
     * Parameters:\n
     * layer - {<OpenLayers.Layer.WMTS>} A WMTS layer.\n
     * xy - {<OpenLayers.Pixel>} The position on the map where the \n
     *     mouse event occurred.\n
     */\n
    buildRequestOptions: function(layer, xy) {\n
        var loc = this.map.getLonLatFromPixel(xy);\n
        var getTileUrl = layer.getURL(\n
            new OpenLayers.Bounds(loc.lon, loc.lat, loc.lon, loc.lat)\n
        );\n
        var params = OpenLayers.Util.getParameters(getTileUrl);\n
        var tileInfo = layer.getTileInfo(loc);\n
        OpenLayers.Util.extend(params, {\n
            service: "WMTS",\n
            version: layer.version,\n
            request: "GetFeatureInfo",\n
            infoFormat: this.infoFormat,\n
            i: tileInfo.i,\n
            j: tileInfo.j\n
        });\n
        OpenLayers.Util.applyDefaults(params, this.vendorParams);\n
        return {\n
            url: OpenLayers.Util.isArray(layer.url) ? layer.url[0] : layer.url,\n
            params: OpenLayers.Util.upperCaseObject(params),\n
            callback: function(request) {\n
                this.handleResponse(xy, request, layer);\n
            },\n
            scope: this\n
        };\n
    },\n
\n
    /**\n
     * Method: request\n
     * Sends a GetFeatureInfo request to the WMTS\n
     * \n
     * Parameters:\n
     * xy - {<OpenLayers.Pixel>} The position on the map where the mouse event \n
     *     occurred.\n
     * options - {Object} additional options for this method.\n
     * \n
     * Valid options:\n
     * - *hover* {Boolean} true if we do the request for the hover handler\n
     */\n
    request: function(xy, options) {\n
        options = options || {};\n
        var layers = this.findLayers();\n
        if (layers.length > 0) {\n
            var issue, layer;\n
            for (var i=0, len=layers.length; i<len; i++) {\n
                layer = layers[i];\n
                issue = this.events.triggerEvent("beforegetfeatureinfo", {\n
                    xy: xy,\n
                    layer: layer\n
                });\n
                if (issue !== false) {\n
                    ++this.pending;\n
                    var requestOptions = this.buildRequestOptions(layer, xy);\n
                    var request = OpenLayers.Request.GET(requestOptions);\n
                    if (options.hover === true) {\n
                        this.hoverRequest = request;\n
                    }\n
                }\n
            }\n
            if (this.pending > 0) {\n
                OpenLayers.Element.addClass(this.map.viewPortDiv, "olCursorWait");\n
            }\n
        }\n
    },\n
\n
    /**\n
     * Method: handleResponse\n
     * Handler for the GetFeatureInfo response.\n
     * \n
     * Parameters:\n
     * xy - {<OpenLayers.Pixel>} The position on the map where the mouse event \n
     *     occurred.\n
     * request - {XMLHttpRequest} The request object.\n
     * layer - {<OpenLayers.Layer.WMTS>} The queried layer.\n
     */\n
    handleResponse: function(xy, request, layer) {\n
        --this.pending;\n
        if (this.pending <= 0) {\n
            OpenLayers.Element.removeClass(this.map.viewPortDiv, "olCursorWait");\n
            this.pending = 0;\n
        }\n
        if (request.status && (request.status < 200 || request.status >= 300)) {\n
            this.events.triggerEvent("exception", {\n
                xy: xy, \n
                request: request,\n
                layer: layer\n
            });\n
        } else {\n
            var doc = request.responseXML;\n
            if (!doc || !doc.documentElement) {\n
                doc = request.responseText;\n
            }\n
            var features, except;\n
            try {\n
                features = this.format.read(doc);\n
            } catch (error) {\n
                except = true;\n
                this.events.triggerEvent("exception", {\n
                    xy: xy,\n
                    request: request,\n
                    error: error,\n
                    layer: layer\n
                });\n
            }\n
            if (!except) {\n
                this.events.triggerEvent("getfeatureinfo", {\n
                    text: request.responseText,\n
                    features: features,\n
                    request: request,\n
                    xy: xy,\n
                    layer: layer\n
                });\n
            }\n
        }\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Control.WMTSGetFeatureInfo"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>13067</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
