<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.81</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>CacheWrite.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Control.js\n
 * @requires OpenLayers/Request.js\n
 * @requires OpenLayers/Console.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Control.CacheWrite\n
 * A control for caching image tiles in the browser\'s local storage. The\n
 * <OpenLayers.Control.CacheRead> control is used to fetch and use the cached\n
 * tile images.\n
 *\n
 * Note: Before using this control on any layer that is not your own, make sure\n
 * that the terms of service of the tile provider allow local storage of tiles.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Control>\n
 */\n
OpenLayers.Control.CacheWrite = OpenLayers.Class(OpenLayers.Control, {\n
    \n
    /** \n
     * APIProperty: events\n
     * {<OpenLayers.Events>} Events instance for listeners and triggering\n
     *     control specific events.\n
     *\n
     * To register events in the constructor, configure <eventListeners>.\n
     *\n
     * Register a listener for a particular event with the following syntax:\n
     * (code)\n
     * control.events.register(type, obj, listener);\n
     * (end)\n
     *\n
     * Supported event types (in addition to those from <OpenLayers.Control.events>):\n
     * cachefull - Triggered when the cache is full. Listeners receive an\n
     *     object with a tile property as first argument. The tile references\n
     *     the tile that couldn\'t be cached.\n
     */\n
    \n
    /**\n
     * APIProperty: eventListeners\n
     * {Object} Object with event listeners, keyed by event name. An optional\n
     *     scope property defines the scope that listeners will be executed in.\n
     */\n
\n
    /**\n
     * APIProperty: layers\n
     * {Array(<OpenLayers.Layer.Grid>)}. Optional. If provided, caching\n
     *     will be enabled for these layers only, otherwise for all cacheable\n
     *     layers.\n
     */\n
    layers: null,\n
    \n
    /**\n
     * APIProperty: imageFormat\n
     * {String} The image format used for caching. The default is "image/png".\n
     *     Supported formats depend on the user agent. If an unsupported\n
     *     <imageFormat> is provided, "image/png" will be used. For aerial\n
     *     imagery, "image/jpeg" is recommended.\n
     */\n
    imageFormat: "image/png",\n
    \n
    /**\n
     * Property: quotaRegEx\n
     * {RegExp}\n
     */\n
    quotaRegEx: (/quota/i),\n
    \n
    /**\n
     * Constructor: OpenLayers.Control.CacheWrite\n
     *\n
     * Parameters:\n
     * options - {Object} Object with API properties for this control.\n
     */\n
\n
    /** \n
     * Method: setMap\n
     * Set the map property for the control. \n
     * \n
     * Parameters:\n
     * map - {<OpenLayers.Map>} \n
     */\n
    setMap: function(map) {\n
        OpenLayers.Control.prototype.setMap.apply(this, arguments);\n
        var i, layers = this.layers || map.layers;\n
        for (i=layers.length-1; i>=0; --i) {\n
            this.addLayer({layer: layers[i]});\n
        }\n
        if (!this.layers) {\n
            map.events.on({\n
                addlayer: this.addLayer,\n
                removeLayer: this.removeLayer,\n
                scope: this\n
            });\n
        }\n
    },\n
    \n
    /**\n
     * Method: addLayer\n
     * Adds a layer to the control. Once added, tiles requested for this layer\n
     *     will be cached.\n
     *\n
     * Parameters:\n
     * evt - {Object} Object with a layer property referencing an\n
     *     <OpenLayers.Layer> instance\n
     */\n
    addLayer: function(evt) {\n
        evt.layer.events.on({\n
            tileloadstart: this.makeSameOrigin,\n
            tileloaded: this.cache,\n
            scope: this\n
        });        \n
    },\n
    \n
    /**\n
     * Method: removeLayer\n
     * Removes a layer from the control. Once removed, tiles requested for this\n
     *     layer will no longer be cached.\n
     *\n
     * Parameters:\n
     * evt - {Object} Object with a layer property referencing an\n
     *     <OpenLayers.Layer> instance\n
     */\n
    removeLayer: function(evt) {\n
        evt.layer.events.un({\n
            tileloadstart: this.makeSameOrigin,\n
            tileloaded: this.cache,\n
            scope: this\n
        });\n
    },\n
\n
    /**\n
     * Method: makeSameOrigin\n
     * If the tile does not have CORS image loading enabled and is from a\n
     * different origin, use OpenLayers.ProxyHost to make it a same origin url.\n
     *\n
     * Parameters:\n
     * evt - {<OpenLayers.Event>}\n
     */\n
    makeSameOrigin: function(evt) {\n
        if (this.active) {\n
            var tile = evt.tile;\n
            if (tile instanceof OpenLayers.Tile.Image &&\n
                    !tile.crossOriginKeyword &&\n
                    tile.url.substr(0, 5) !== "data:") {\n
                var sameOriginUrl = OpenLayers.Request.makeSameOrigin(\n
                    tile.url, OpenLayers.ProxyHost\n
                );\n
                OpenLayers.Control.CacheWrite.urlMap[sameOriginUrl] = tile.url;\n
                tile.url = sameOriginUrl;\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: cache\n
     * Adds a tile to the cache. When the cache is full, the "cachefull" event\n
     * is triggered.\n
     *\n
     * Parameters:\n
     * obj - {Object} Object with a tile property, tile being the\n
     *     <OpenLayers.Tile.Image> with the data to add to the cache\n
     */\n
    cache: function(obj) {\n
        if (this.active && window.localStorage) {\n
            var tile = obj.tile;\n
            if (tile instanceof OpenLayers.Tile.Image &&\n
                    tile.url.substr(0, 5) !== \'data:\') {\n
                try {\n
                    var canvasContext = tile.getCanvasContext();\n
                    if (canvasContext) {\n
                        var urlMap = OpenLayers.Control.CacheWrite.urlMap;\n
                        var url = urlMap[tile.url] || tile.url;\n
                        window.localStorage.setItem(\n
                            "olCache_" + url,\n
                            canvasContext.canvas.toDataURL(this.imageFormat)\n
                        );\n
                        delete urlMap[tile.url];\n
                    }\n
                } catch(e) {\n
                    // local storage full or CORS violation\n
                    var reason = e.name || e.message;\n
                    if (reason && this.quotaRegEx.test(reason)) {\n
                        this.events.triggerEvent("cachefull", {tile: tile});\n
                    } else {\n
                        OpenLayers.Console.error(e.toString());\n
                    }\n
                }\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: destroy\n
     * The destroy method is used to perform any clean up before the control\n
     * is dereferenced.  Typically this is where event listeners are removed\n
     * to prevent memory leaks.\n
     */\n
    destroy: function() {\n
        if (this.layers || this.map) {\n
            var i, layers = this.layers || this.map.layers;\n
            for (i=layers.length-1; i>=0; --i) {\n
                this.removeLayer({layer: layers[i]});\n
            }\n
        }\n
        if (this.map) {\n
            this.map.events.un({\n
                addlayer: this.addLayer,\n
                removeLayer: this.removeLayer,\n
                scope: this\n
            });\n
        }\n
        OpenLayers.Control.prototype.destroy.apply(this, arguments);\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Control.CacheWrite"\n
});\n
\n
/**\n
 * APIFunction: OpenLayers.Control.CacheWrite.clearCache\n
 * Clears all tiles cached with <OpenLayers.Control.CacheWrite> from the cache.\n
 */\n
OpenLayers.Control.CacheWrite.clearCache = function() {\n
    if (!window.localStorage) { return; }\n
    var i, key;\n
    for (i=window.localStorage.length-1; i>=0; --i) {\n
        key = window.localStorage.key(i);\n
        if (key.substr(0, 8) === "olCache_") {\n
            window.localStorage.removeItem(key);\n
        }\n
    }\n
};\n
\n
/**\n
 * Property: OpenLayers.Control.CacheWrite.urlMap\n
 * {Object} Mapping of same origin urls to cache url keys. Entries will be\n
 *     deleted as soon as a tile was cached.\n
 */\n
OpenLayers.Control.CacheWrite.urlMap = {};\n
\n
\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>8033</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
