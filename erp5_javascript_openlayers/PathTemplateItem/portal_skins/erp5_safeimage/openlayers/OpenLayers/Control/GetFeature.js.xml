<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.81</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>GetFeature.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Control.js\n
 * @requires OpenLayers/Handler/Click.js\n
 * @requires OpenLayers/Handler/Box.js\n
 * @requires OpenLayers/Handler/Hover.js\n
 * @requires OpenLayers/Filter/Spatial.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Control.GetFeature\n
 * Gets vector features for locations underneath the mouse cursor. Can be\n
 *     configured to act on click, hover or dragged boxes. Uses an\n
 *     <OpenLayers.Protocol> that supports spatial filters to retrieve\n
 *     features from a server and fires events that notify applications of the\n
 *     selected features. \n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Control>\n
 */\n
OpenLayers.Control.GetFeature = OpenLayers.Class(OpenLayers.Control, {\n
    \n
    /**\n
     * APIProperty: protocol\n
     * {<OpenLayers.Protocol>} Required. The protocol used for fetching\n
     *     features.\n
     */\n
    protocol: null,\n
    \n
    /**\n
     * APIProperty: multipleKey\n
     * {String} An event modifier (\'altKey\' or \'shiftKey\') that temporarily sets\n
     *     the <multiple> property to true.  Default is null.\n
     */\n
    multipleKey: null,\n
    \n
    /**\n
     * APIProperty: toggleKey\n
     * {String} An event modifier (\'altKey\' or \'shiftKey\') that temporarily sets\n
     *     the <toggle> property to true.  Default is null.\n
     */\n
    toggleKey: null,\n
    \n
    /**\n
     * Property: modifiers\n
     * {Object} The event modifiers to use, according to the current event\n
     *     being handled by this control\'s handlers\n
     */\n
    modifiers: null,\n
    \n
    /**\n
     * APIProperty: multiple\n
     * {Boolean} Allow selection of multiple geometries.  Default is false.\n
     */\n
    multiple: false, \n
\n
    /**\n
     * APIProperty: click\n
     * {Boolean} Use a click handler for selecting/unselecting features. If\n
     *     both <click> and <box> are set to true, the click handler takes\n
     *     precedence over the box handler if a box with zero extent was\n
     *     selected.  Default is true.\n
     */\n
    click: true,\n
\n
    /**\n
     * APIProperty: single\n
     * {Boolean} Tells whether select by click should select a single\n
     *     feature. If set to false, all matching features are selected.\n
     *     If set to true, only the best matching feature is selected.\n
     *     This option has an effect only of the <click> option is set\n
     *     to true. Default is true.\n
     */\n
    single: true,\n
    \n
    /**\n
     * APIProperty: clickout\n
     * {Boolean} Unselect features when clicking outside any feature.\n
     *     Applies only if <click> is true.  Default is true.\n
     */\n
    clickout: true,\n
    \n
    /**\n
     * APIProperty: toggle\n
     * {Boolean} Unselect a selected feature on click.  Applies only if\n
     *     <click> is true.  Default is false.\n
     */\n
    toggle: false,\n
\n
    /**\n
     * APIProperty: clickTolerance\n
     * {Integer} Tolerance for the filter query in pixels. This has the\n
     *     same effect as the tolerance parameter on WMS GetFeatureInfo\n
     *     requests.  Will be ignored for box selections.  Applies only if\n
     *     <click> or <hover> is true.  Default is 5.  Note that this not\n
     *     only affects requests on click, but also on hover.\n
     */\n
    clickTolerance: 5,\n
    \n
    /**\n
     * APIProperty: hover\n
     * {Boolean} Send feature requests on mouse moves.  Default is false.\n
     */\n
    hover: false,\n
\n
    /**\n
     * APIProperty: box\n
     * {Boolean} Allow feature selection by drawing a box. If set to\n
     *     true set <click> to false to disable the click handler and\n
     *     rely on the box handler only, even for "zero extent" boxes.\n
     *     See the description of the <click> option for additional\n
     *     information.  Default is false.\n
     */\n
    box: false,\n
    \n
    /**\n
     * APIProperty: maxFeatures\n
     * {Integer} Maximum number of features to return from a query in single mode\n
     *     if supported by the <protocol>. This set of features is then used to\n
     *     determine the best match client-side. Default is 10.\n
     */\n
    maxFeatures: 10,\n
    \n
    /**\n
     * Property: features\n
     * {Object} Hash of {<OpenLayers.Feature.Vector>}, keyed by fid, holding\n
     *     the currently selected features\n
     */\n
    features: null,\n
    \n
    /**\n
     * Proeprty: hoverFeature\n
     * {<OpenLayers.Feature.Vector>} The feature currently selected by the\n
     *     hover handler\n
     */\n
    hoverFeature: null,\n
    \n
    /**\n
     * APIProperty: handlerOptions\n
     * {Object} Additional options for the handlers used by this control. This\n
     *     is a hash with the keys "click", "box" and "hover".\n
     */\n
    handlerOptions: null,\n
    \n
    /**\n
     * Property: handlers\n
     * {Object} Object with references to multiple <OpenLayers.Handler>\n
     *     instances.\n
     */\n
    handlers: null,\n
\n
    /**\n
     * Property: hoverResponse\n
     * {<OpenLayers.Protocol.Response>} The response object associated with\n
     *     the currently running hover request (if any).\n
     */\n
    hoverResponse: null,\n
    \n
    /**\n
     * Property: filterType\n
     * {<String>} The type of filter to use when sending off a request. \n
     *     Possible values: \n
     *     OpenLayers.Filter.Spatial.<BBOX|INTERSECTS|WITHIN|CONTAINS>\n
     *     Defaults to: OpenLayers.Filter.Spatial.BBOX\n
     */\n
    filterType: OpenLayers.Filter.Spatial.BBOX,\n
\n
    /** \n
     * APIProperty: events\n
     * {<OpenLayers.Events>} Events instance for listeners and triggering\n
     *     control specific events.\n
     *\n
     * Register a listener for a particular event with the following syntax:\n
     * (code)\n
     * control.events.register(type, obj, listener);\n
     * (end)\n
     *\n
     * Supported event types (in addition to those from <OpenLayers.Control.events>):\n
     * beforefeatureselected - Triggered when <click> is true before a\n
     *      feature is selected. The event object has a feature property with\n
     *      the feature about to select\n
     * featureselected - Triggered when <click> is true and a feature is\n
     *      selected. The event object has a feature property with the\n
     *      selected feature\n
     * beforefeaturesselected - Triggered when <click> is true before a\n
     *      set of features is selected. The event object is an array of\n
     *      feature properties with the features about to be selected.  \n
     *      Return false after receiving this event to discontinue processing\n
     *      of all featureselected events and the featuresselected event.\n
     * featuresselected - Triggered when <click> is true and a set of\n
     *      features is selected.  The event object is an array of feature\n
     *      properties of the selected features\n
     * featureunselected - Triggered when <click> is true and a feature is\n
     *      unselected. The event object has a feature property with the\n
     *      unselected feature\n
     * clickout - Triggered when when <click> is true and no feature was\n
     *      selected.\n
     * hoverfeature - Triggered when <hover> is true and the mouse has\n
     *      stopped over a feature\n
     * outfeature - Triggered when <hover> is true and the mouse moves\n
     *      moved away from a hover-selected feature\n
     */\n
\n
    /**\n
     * Constructor: OpenLayers.Control.GetFeature\n
     * Create a new control for fetching remote features.\n
     *\n
     * Parameters:\n
     * options - {Object} A configuration object which at least has to contain\n
     *     a <protocol> property (if not, it has to be set before a request is\n
     *     made)\n
     */\n
    initialize: function(options) {\n
        options.handlerOptions = options.handlerOptions || {};\n
\n
        OpenLayers.Control.prototype.initialize.apply(this, [options]);\n
        \n
        this.features = {};\n
\n
        this.handlers = {};\n
        \n
        if(this.click) {\n
            this.handlers.click = new OpenLayers.Handler.Click(this,\n
                {click: this.selectClick}, this.handlerOptions.click || {});\n
        }\n
\n
        if(this.box) {\n
            this.handlers.box = new OpenLayers.Handler.Box(\n
                this, {done: this.selectBox},\n
                OpenLayers.Util.extend(this.handlerOptions.box, {\n
                    boxDivClassName: "olHandlerBoxSelectFeature"\n
                })\n
            ); \n
        }\n
        \n
        if(this.hover) {\n
            this.handlers.hover = new OpenLayers.Handler.Hover(\n
                this, {\'move\': this.cancelHover, \'pause\': this.selectHover},\n
                OpenLayers.Util.extend(this.handlerOptions.hover, {\n
                    \'delay\': 250,\n
                    \'pixelTolerance\': 2\n
                })\n
            );\n
        }\n
    },\n
    \n
    /**\n
     * Method: activate\n
     * Activates the control.\n
     * \n
     * Returns:\n
     * {Boolean} The control was effectively activated.\n
     */\n
    activate: function () {\n
        if (!this.active) {\n
            for(var i in this.handlers) {\n
                this.handlers[i].activate();\n
            }\n
        }\n
        return OpenLayers.Control.prototype.activate.apply(\n
            this, arguments\n
        );\n
    },\n
\n
    /**\n
     * Method: deactivate\n
     * Deactivates the control.\n
     * \n
     * Returns:\n
     * {Boolean} The control was effectively deactivated.\n
     */\n
    deactivate: function () {\n
        if (this.active) {\n
            for(var i in this.handlers) {\n
                this.handlers[i].deactivate();\n
            }\n
        }\n
        return OpenLayers.Control.prototype.deactivate.apply(\n
            this, arguments\n
        );\n
    },\n
    \n
    /**\n
     * Method: selectClick\n
     * Called on click\n
     *\n
     * Parameters:\n
     * evt - {<OpenLayers.Event>} \n
     */\n
    selectClick: function(evt) {\n
        var bounds = this.pixelToBounds(evt.xy);\n
        \n
        this.setModifiers(evt);\n
        this.request(bounds, {single: this.single});\n
    },\n
\n
    /**\n
     * Method: selectBox\n
     * Callback from the handlers.box set up when <box> selection is on\n
     *\n
     * Parameters:\n
     * position - {<OpenLayers.Bounds>|Object} An OpenLayers.Bounds or\n
     * an object with a \'left\', \'bottom\', \'right\' and \'top\' properties.\n
     */\n
    selectBox: function(position) {\n
        var bounds;\n
        if (position instanceof OpenLayers.Bounds) {\n
            var minXY = this.map.getLonLatFromPixel({\n
                x: position.left,\n
                y: position.bottom\n
            });\n
            var maxXY = this.map.getLonLatFromPixel({\n
                x: position.right,\n
                y: position.top\n
            });\n
            bounds = new OpenLayers.Bounds(\n
                minXY.lon, minXY.lat, maxXY.lon, maxXY.lat\n
            );\n
            \n
        } else {\n
            if(this.click) {\n
                // box without extent - let the click handler take care of it\n
                return;\n
            }\n
            bounds = this.pixelToBounds(position);\n
        }\n
        this.setModifiers(this.handlers.box.dragHandler.evt);\n
        this.request(bounds);\n
    },\n
    \n
    /**\n
     * Method: selectHover\n
     * Callback from the handlers.hover set up when <hover> selection is on\n
     *\n
     * Parameters:\n
     * evt - {Object} event object with an xy property\n
     */\n
    selectHover: function(evt) {\n
        var bounds = this.pixelToBounds(evt.xy);\n
        this.request(bounds, {single: true, hover: true});\n
    },\n
\n
    /**\n
     * Method: cancelHover\n
     * Callback from the handlers.hover set up when <hover> selection is on\n
     */\n
    cancelHover: function() {\n
        if (this.hoverResponse) {\n
            this.protocol.abort(this.hoverResponse);\n
            this.hoverResponse = null;\n
\n
            OpenLayers.Element.removeClass(this.map.viewPortDiv, "olCursorWait");\n
        }\n
    },\n
\n
    /**\n
     * Method: request\n
     * Sends a GetFeature request to the WFS\n
     * \n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>} bounds for the request\'s BBOX filter\n
     * options - {Object} additional options for this method.\n
     * \n
     * Supported options include:\n
     * single - {Boolean} A single feature should be returned.\n
     *     Note that this will be ignored if the protocol does not\n
     *     return the geometries of the features.\n
     * hover - {Boolean} Do the request for the hover handler.\n
     */\n
    request: function(bounds, options) {\n
        options = options || {};\n
        var filter = new OpenLayers.Filter.Spatial({\n
            type: this.filterType, \n
            value: bounds\n
        });\n
        \n
        // Set the cursor to "wait" to tell the user we\'re working.\n
        OpenLayers.Element.addClass(this.map.viewPortDiv, "olCursorWait");\n
\n
        var response = this.protocol.read({\n
            maxFeatures: options.single == true ? this.maxFeatures : undefined,\n
            filter: filter,\n
            callback: function(result) {\n
                if(result.success()) {\n
                    if(result.features.length) {\n
                        if(options.single == true) {\n
                            this.selectBestFeature(result.features,\n
                                bounds.getCenterLonLat(), options);\n
                        } else {\n
                            this.select(result.features);\n
                        }\n
                    } else if(options.hover) {\n
                        this.hoverSelect();\n
                    } else {\n
                        this.events.triggerEvent("clickout");\n
                        if(this.clickout) {\n
                            this.unselectAll();\n
                        }\n
                    }\n
                }\n
                // Reset the cursor.\n
                OpenLayers.Element.removeClass(this.map.viewPortDiv, "olCursorWait");\n
            },\n
            scope: this\n
        });\n
        if(options.hover == true) {\n
            this.hoverResponse = response;\n
        }\n
    },\n
\n
    /**\n
     * Method: selectBestFeature\n
     * Selects the feature from an array of features that is the best match\n
     *     for the click position.\n
     * \n
     * Parameters:\n
     * features - {Array(<OpenLayers.Feature.Vector>)}\n
     * clickPosition - {<OpenLayers.LonLat>}\n
     * options - {Object} additional options for this method\n
     * \n
     * Supported options include:\n
     * hover - {Boolean} Do the selection for the hover handler.\n
     */\n
    selectBestFeature: function(features, clickPosition, options) {\n
        options = options || {};\n
        if(features.length) {\n
            var point = new OpenLayers.Geometry.Point(clickPosition.lon,\n
                clickPosition.lat);\n
            var feature, resultFeature, dist;\n
            var minDist = Number.MAX_VALUE;\n
            for(var i=0; i<features.length; ++i) {\n
                feature = features[i];\n
                if(feature.geometry) {\n
                    dist = point.distanceTo(feature.geometry, {edge: false});\n
                    if(dist < minDist) {\n
                        minDist = dist;\n
                        resultFeature = feature;\n
                        if(minDist == 0) {\n
                            break;\n
                        }\n
                    }\n
                }\n
            }\n
            \n
            if(options.hover == true) {\n
                this.hoverSelect(resultFeature);\n
            } else {\n
                this.select(resultFeature || features);\n
            } \n
        }\n
    },\n
    \n
    /**\n
     * Method: setModifiers\n
     * Sets the multiple and toggle modifiers according to the current event\n
     * \n
     * Parameters:\n
     * evt - {<OpenLayers.Event>}\n
     */\n
    setModifiers: function(evt) {\n
        this.modifiers = {\n
            multiple: this.multiple || (this.multipleKey && evt[this.multipleKey]),\n
            toggle: this.toggle || (this.toggleKey && evt[this.toggleKey])\n
        };        \n
    },\n
\n
    /**\n
     * Method: select\n
     * Add feature to the hash of selected features and trigger the\n
     * featureselected and featuresselected events.\n
     * \n
     * Parameters:\n
     * features - {<OpenLayers.Feature.Vector>} or an array of features\n
     */\n
    select: function(features) {\n
        if(!this.modifiers.multiple && !this.modifiers.toggle) {\n
            this.unselectAll();\n
        }\n
        if(!(OpenLayers.Util.isArray(features))) {\n
            features = [features];\n
        }\n
        \n
        var cont = this.events.triggerEvent("beforefeaturesselected", {\n
            features: features\n
        });\n
        if(cont !== false) {\n
            var selectedFeatures = [];\n
            var feature;\n
            for(var i=0, len=features.length; i<len; ++i) {\n
                feature = features[i];\n
                if(this.features[feature.fid || feature.id]) {\n
                    if(this.modifiers.toggle) {\n
                        this.unselect(this.features[feature.fid || feature.id]);\n
                    }\n
                } else {\n
                    cont = this.events.triggerEvent("beforefeatureselected", {\n
                        feature: feature\n
                    });\n
                    if(cont !== false) {\n
                        this.features[feature.fid || feature.id] = feature;\n
                        selectedFeatures.push(feature);\n
                \n
                        this.events.triggerEvent("featureselected",\n
                            {feature: feature});\n
                    }\n
                }\n
            }\n
            this.events.triggerEvent("featuresselected", {\n
                features: selectedFeatures\n
            });\n
        }\n
    },\n
    \n
    /**\n
     * Method: hoverSelect\n
     * Sets/unsets the <hoverFeature>\n
     * \n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>} the feature to hover-select.\n
     *     If none is provided, the current <hoverFeature> will be nulled and\n
     *     the outfeature event will be triggered.\n
     */\n
    hoverSelect: function(feature) {\n
        var fid = feature ? feature.fid || feature.id : null;\n
        var hfid = this.hoverFeature ?\n
            this.hoverFeature.fid || this.hoverFeature.id : null;\n
            \n
        if(hfid && hfid != fid) {\n
            this.events.triggerEvent("outfeature",\n
                {feature: this.hoverFeature});\n
            this.hoverFeature = null;\n
        }\n
        if(fid && fid != hfid) {\n
            this.events.triggerEvent("hoverfeature", {feature: feature});\n
            this.hoverFeature = feature;\n
        }\n
    },\n
\n
    /**\n
     * Method: unselect\n
     * Remove feature from the hash of selected features and trigger the\n
     * featureunselected event.\n
     *\n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>}\n
     */\n
    unselect: function(feature) {\n
        delete this.features[feature.fid || feature.id];\n
        this.events.triggerEvent("featureunselected", {feature: feature});\n
    },\n
    \n
    /**\n
     * Method: unselectAll\n
     * Unselect all selected features.\n
     */\n
    unselectAll: function() {\n
        // we\'ll want an option to supress notification here\n
        for(var fid in this.features) {\n
            this.unselect(this.features[fid]);\n
        }\n
    },\n
    \n
    /** \n
     * Method: setMap\n
     * Set the map property for the control. \n
     * \n
     * Parameters:\n
     * map - {<OpenLayers.Map>} \n
     */\n
    setMap: function(map) {\n
        for(var i in this.handlers) {\n
            this.handlers[i].setMap(map);\n
        }\n
        OpenLayers.Control.prototype.setMap.apply(this, arguments);\n
    },\n
    \n
    /**\n
     * Method: pixelToBounds\n
     * Takes a pixel as argument and creates bounds after adding the\n
     * <clickTolerance>.\n
     * \n
     * Parameters:\n
     * pixel - {<OpenLayers.Pixel>}\n
     */\n
    pixelToBounds: function(pixel) {\n
        var llPx = pixel.add(-this.clickTolerance/2, this.clickTolerance/2);\n
        var urPx = pixel.add(this.clickTolerance/2, -this.clickTolerance/2);\n
        var ll = this.map.getLonLatFromPixel(llPx);\n
        var ur = this.map.getLonLatFromPixel(urPx);\n
        return new OpenLayers.Bounds(ll.lon, ll.lat, ur.lon, ur.lat);\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Control.GetFeature"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>20030</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
