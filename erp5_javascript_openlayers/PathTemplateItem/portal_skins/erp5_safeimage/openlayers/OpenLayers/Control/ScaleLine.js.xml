<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.8</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>ScaleLine.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Control.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Control.ScaleLine\n
 * The ScaleLine displays a small line indicator representing the current \n
 * map scale on the map. By default it is drawn in the lower left corner of\n
 * the map.\n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Control>\n
 *  \n
 * Is a very close copy of:\n
 *  - <OpenLayers.Control.Scale>\n
 */\n
OpenLayers.Control.ScaleLine = OpenLayers.Class(OpenLayers.Control, {\n
\n
    /**\n
     * Property: maxWidth\n
     * {Integer} Maximum width of the scale line in pixels.  Default is 100.\n
     */\n
    maxWidth: 100,\n
\n
    /**\n
     * Property: topOutUnits\n
     * {String} Units for zoomed out on top bar.  Default is km.\n
     */\n
    topOutUnits: "km",\n
    \n
    /**\n
     * Property: topInUnits\n
     * {String} Units for zoomed in on top bar.  Default is m.\n
     */\n
    topInUnits: "m",\n
\n
    /**\n
     * Property: bottomOutUnits\n
     * {String} Units for zoomed out on bottom bar.  Default is mi.\n
     */\n
    bottomOutUnits: "mi",\n
\n
    /**\n
     * Property: bottomInUnits\n
     * {String} Units for zoomed in on bottom bar.  Default is ft.\n
     */\n
    bottomInUnits: "ft",\n
    \n
    /**\n
     * Property: eTop\n
     * {DOMElement}\n
     */\n
    eTop: null,\n
\n
    /**\n
     * Property: eBottom\n
     * {DOMElement}\n
     */\n
    eBottom:null,\n
    \n
    /**\n
     * APIProperty: geodesic\n
     * {Boolean} Use geodesic measurement. Default is false. The recommended\n
     * setting for maps in EPSG:4326 is false, and true EPSG:900913. If set to\n
     * true, the scale will be calculated based on the horizontal size of the\n
     * pixel in the center of the map viewport.\n
     */\n
    geodesic: false,\n
\n
    /**\n
     * Constructor: OpenLayers.Control.ScaleLine\n
     * Create a new scale line control.\n
     * \n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be used\n
     *     to extend the control.\n
     */\n
\n
    /**\n
     * Method: draw\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    draw: function() {\n
        OpenLayers.Control.prototype.draw.apply(this, arguments);\n
        if (!this.eTop) {\n
            // stick in the top bar\n
            this.eTop = document.createElement("div");\n
            this.eTop.className = this.displayClass + "Top";\n
            var theLen = this.topInUnits.length;\n
            this.div.appendChild(this.eTop);\n
            if((this.topOutUnits == "") || (this.topInUnits == "")) {\n
                this.eTop.style.visibility = "hidden";\n
            } else {\n
                this.eTop.style.visibility = "visible";\n
            }\n
\n
            // and the bottom bar\n
            this.eBottom = document.createElement("div");\n
            this.eBottom.className = this.displayClass + "Bottom";\n
            this.div.appendChild(this.eBottom);\n
            if((this.bottomOutUnits == "") || (this.bottomInUnits == "")) {\n
                this.eBottom.style.visibility = "hidden";\n
            } else {\n
                this.eBottom.style.visibility = "visible";\n
            }\n
        }\n
        this.map.events.register(\'moveend\', this, this.update);\n
        this.update();\n
        return this.div;\n
    },\n
\n
    /** \n
     * Method: getBarLen\n
     * Given a number, round it down to the nearest 1,2,5 times a power of 10.\n
     * That seems a fairly useful set of number groups to use.\n
     * \n
     * Parameters:\n
     * maxLen - {float}  the number we\'re rounding down from\n
     * \n
     * Returns:\n
     * {Float} the rounded number (less than or equal to maxLen)\n
     */\n
    getBarLen: function(maxLen) {\n
        // nearest power of 10 lower than maxLen\n
        var digits = parseInt(Math.log(maxLen) / Math.log(10));\n
        var pow10 = Math.pow(10, digits);\n
        \n
        // ok, find first character\n
        var firstChar = parseInt(maxLen / pow10);\n
\n
        // right, put it into the correct bracket\n
        var barLen;\n
        if(firstChar > 5) {\n
            barLen = 5;\n
        } else if(firstChar > 2) {\n
            barLen = 2;\n
        } else {\n
            barLen = 1;\n
        }\n
\n
        // scale it up the correct power of 10\n
        return barLen * pow10;\n
    },\n
\n
    /**\n
     * Method: update\n
     * Update the size of the bars, and the labels they contain.\n
     */\n
    update: function() {\n
        var res = this.map.getResolution();\n
        if (!res) {\n
            return;\n
        }\n
\n
        var curMapUnits = this.map.getUnits();\n
        var inches = OpenLayers.INCHES_PER_UNIT;\n
\n
        // convert maxWidth to map units\n
        var maxSizeData = this.maxWidth * res * inches[curMapUnits];\n
        var geodesicRatio = 1;\n
        if(this.geodesic === true) {\n
            var maxSizeGeodesic = (this.map.getGeodesicPixelSize().w ||\n
                0.000001) * this.maxWidth;\n
            var maxSizeKilometers = maxSizeData / inches["km"];\n
            geodesicRatio = maxSizeGeodesic / maxSizeKilometers;\n
            maxSizeData *= geodesicRatio;\n
        }\n
\n
        // decide whether to use large or small scale units     \n
        var topUnits;\n
        var bottomUnits;\n
        if(maxSizeData > 100000) {\n
            topUnits = this.topOutUnits;\n
            bottomUnits = this.bottomOutUnits;\n
        } else {\n
            topUnits = this.topInUnits;\n
            bottomUnits = this.bottomInUnits;\n
        }\n
\n
        // and to map units units\n
        var topMax = maxSizeData / inches[topUnits];\n
        var bottomMax = maxSizeData / inches[bottomUnits];\n
\n
        // now trim this down to useful block length\n
        var topRounded = this.getBarLen(topMax);\n
        var bottomRounded = this.getBarLen(bottomMax);\n
\n
        // and back to display units\n
        topMax = topRounded / inches[curMapUnits] * inches[topUnits];\n
        bottomMax = bottomRounded / inches[curMapUnits] * inches[bottomUnits];\n
\n
        // and to pixel units\n
        var topPx = topMax / res / geodesicRatio;\n
        var bottomPx = bottomMax / res / geodesicRatio;\n
        \n
        // now set the pixel widths\n
        // and the values inside them\n
        \n
        if (this.eBottom.style.visibility == "visible"){\n
            this.eBottom.style.width = Math.round(bottomPx) + "px"; \n
            this.eBottom.innerHTML = bottomRounded + " " + bottomUnits ;\n
        }\n
            \n
        if (this.eTop.style.visibility == "visible"){\n
            this.eTop.style.width = Math.round(topPx) + "px";\n
            this.eTop.innerHTML = topRounded + " " + topUnits;\n
        }\n
        \n
    }, \n
\n
    CLASS_NAME: "OpenLayers.Control.ScaleLine"\n
});\n
\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>6670</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
