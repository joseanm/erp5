<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.8</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>OverviewMap.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/** \n
 * @requires OpenLayers/Control.js\n
 * @requires OpenLayers/BaseTypes.js\n
 * @requires OpenLayers/Events/buttonclick.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Control.OverviewMap\n
 * The OverMap control creates a small overview map, useful to display the \n
 * extent of a zoomed map and your main map and provide additional \n
 * navigation options to the User.  By default the overview map is drawn in\n
 * the lower right corner of the main map. Create a new overview map with the\n
 * <OpenLayers.Control.OverviewMap> constructor.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Control>\n
 */\n
OpenLayers.Control.OverviewMap = OpenLayers.Class(OpenLayers.Control, {\n
\n
    /**\n
     * Property: element\n
     * {DOMElement} The DOM element that contains the overview map\n
     */\n
    element: null,\n
    \n
    /**\n
     * APIProperty: ovmap\n
     * {<OpenLayers.Map>} A reference to the overview map itself.\n
     */\n
    ovmap: null,\n
\n
    /**\n
     * APIProperty: size\n
     * {<OpenLayers.Size>} The overvew map size in pixels.  Note that this is\n
     * the size of the map itself - the element that contains the map (default\n
     * class name olControlOverviewMapElement) may have padding or other style\n
     * attributes added via CSS.\n
     */\n
    size: {w: 180, h: 90},\n
\n
    /**\n
     * APIProperty: layers\n
     * {Array(<OpenLayers.Layer>)} Ordered list of layers in the overview map.\n
     * If none are sent at construction, the base layer for the main map is used.\n
     */\n
    layers: null,\n
    \n
    /**\n
     * APIProperty: minRectSize\n
     * {Integer} The minimum width or height (in pixels) of the extent\n
     *     rectangle on the overview map.  When the extent rectangle reaches\n
     *     this size, it will be replaced depending on the value of the\n
     *     <minRectDisplayClass> property.  Default is 15 pixels.\n
     */\n
    minRectSize: 15,\n
    \n
    /**\n
     * APIProperty: minRectDisplayClass\n
     * {String} Replacement style class name for the extent rectangle when\n
     *     <minRectSize> is reached.  This string will be suffixed on to the\n
     *     displayClass.  Default is "RectReplacement".\n
     *\n
     * Example CSS declaration:\n
     * (code)\n
     * .olControlOverviewMapRectReplacement {\n
     *     overflow: hidden;\n
     *     cursor: move;\n
     *     background-image: url("img/overview_replacement.gif");\n
     *     background-repeat: no-repeat;\n
     *     background-position: center;\n
     * }\n
     * (end)\n
     */\n
    minRectDisplayClass: "RectReplacement",\n
\n
    /**\n
     * APIProperty: minRatio\n
     * {Float} The ratio of the overview map resolution to the main map\n
     *     resolution at which to zoom farther out on the overview map.\n
     */\n
    minRatio: 8,\n
\n
    /**\n
     * APIProperty: maxRatio\n
     * {Float} The ratio of the overview map resolution to the main map\n
     *     resolution at which to zoom farther in on the overview map.\n
     */\n
    maxRatio: 32,\n
    \n
    /**\n
     * APIProperty: mapOptions\n
     * {Object} An object containing any non-default properties to be sent to\n
     *     the overview map\'s map constructor.  These should include any\n
     *     non-default options that the main map was constructed with.\n
     */\n
    mapOptions: null,\n
\n
    /**\n
     * APIProperty: autoPan\n
     * {Boolean} Always pan the overview map, so the extent marker remains in\n
     *     the center.  Default is false.  If true, when you drag the extent\n
     *     marker, the overview map will update itself so the marker returns\n
     *     to the center.\n
     */\n
    autoPan: false,\n
    \n
    /**\n
     * Property: handlers\n
     * {Object}\n
     */\n
    handlers: null,\n
\n
    /**\n
     * Property: resolutionFactor\n
     * {Object}\n
     */\n
    resolutionFactor: 1,\n
\n
    /**\n
     * APIProperty: maximized\n
     * {Boolean} Start as maximized (visible). Defaults to false.\n
     */\n
    maximized: false,\n
\n
    /**\n
     * Constructor: OpenLayers.Control.OverviewMap\n
     * Create a new overview map\n
     *\n
     * Parameters:\n
     * options - {Object} Properties of this object will be set on the overview\n
     * map object.  Note, to set options on the map object contained in this\n
     * control, set <mapOptions> as one of the options properties.\n
     */\n
    initialize: function(options) {\n
        this.layers = [];\n
        this.handlers = {};\n
        OpenLayers.Control.prototype.initialize.apply(this, [options]);\n
    },\n
    \n
    /**\n
     * APIMethod: destroy\n
     * Deconstruct the control\n
     */\n
    destroy: function() {\n
        if (!this.mapDiv) { // we\'ve already been destroyed\n
            return;\n
        }\n
        if (this.handlers.click) {\n
            this.handlers.click.destroy();\n
        }\n
        if (this.handlers.drag) {\n
            this.handlers.drag.destroy();\n
        }\n
\n
        this.ovmap && this.ovmap.viewPortDiv.removeChild(this.extentRectangle);\n
        this.extentRectangle = null;\n
\n
        if (this.rectEvents) {\n
            this.rectEvents.destroy();\n
            this.rectEvents = null;\n
        }\n
\n
        if (this.ovmap) {\n
            this.ovmap.destroy();\n
            this.ovmap = null;\n
        }\n
        \n
        this.element.removeChild(this.mapDiv);\n
        this.mapDiv = null;\n
\n
        this.div.removeChild(this.element);\n
        this.element = null;\n
\n
        if (this.maximizeDiv) {\n
            this.div.removeChild(this.maximizeDiv);\n
            this.maximizeDiv = null;\n
        }\n
        \n
        if (this.minimizeDiv) {\n
            this.div.removeChild(this.minimizeDiv);\n
            this.minimizeDiv = null;\n
        }\n
\n
        this.map.events.un({\n
            buttonclick: this.onButtonClick,\n
            moveend: this.update,\n
            changebaselayer: this.baseLayerDraw,\n
            scope: this\n
        });\n
\n
        OpenLayers.Control.prototype.destroy.apply(this, arguments);    \n
    },\n
\n
    /**\n
     * Method: draw\n
     * Render the control in the browser.\n
     */    \n
    draw: function() {\n
        OpenLayers.Control.prototype.draw.apply(this, arguments);\n
        if (this.layers.length === 0) {\n
            if (this.map.baseLayer) {\n
                var layer = this.map.baseLayer.clone();\n
                this.layers = [layer];\n
            } else {\n
                this.map.events.register("changebaselayer", this, this.baseLayerDraw);\n
                return this.div;\n
            }\n
        }\n
\n
        // create overview map DOM elements\n
        this.element = document.createElement(\'div\');\n
        this.element.className = this.displayClass + \'Element\';\n
        this.element.style.display = \'none\';\n
\n
        this.mapDiv = document.createElement(\'div\');\n
        this.mapDiv.style.width = this.size.w + \'px\';\n
        this.mapDiv.style.height = this.size.h + \'px\';\n
        this.mapDiv.style.position = \'relative\';\n
        this.mapDiv.style.overflow = \'hidden\';\n
        this.mapDiv.id = OpenLayers.Util.createUniqueID(\'overviewMap\');\n
        \n
        this.extentRectangle = document.createElement(\'div\');\n
        this.extentRectangle.style.position = \'absolute\';\n
        this.extentRectangle.style.zIndex = 1000;  //HACK\n
        this.extentRectangle.className = this.displayClass+\'ExtentRectangle\';\n
\n
        this.element.appendChild(this.mapDiv);  \n
\n
        this.div.appendChild(this.element);\n
\n
        // Optionally add min/max buttons if the control will go in the\n
        // map viewport.\n
        if(!this.outsideViewport) {\n
            this.div.className += " " + this.displayClass + \'Container\';\n
            // maximize button div\n
            var img = OpenLayers.Util.getImageLocation(\'layer-switcher-maximize.png\');\n
            this.maximizeDiv = OpenLayers.Util.createAlphaImageDiv(\n
                                        this.displayClass + \'MaximizeButton\', \n
                                        null, \n
                                        null, \n
                                        img, \n
                                        \'absolute\');\n
            this.maximizeDiv.style.display = \'none\';\n
            this.maximizeDiv.className = this.displayClass + \'MaximizeButton olButton\';\n
            this.div.appendChild(this.maximizeDiv);\n
    \n
            // minimize button div\n
            var img = OpenLayers.Util.getImageLocation(\'layer-switcher-minimize.png\');\n
            this.minimizeDiv = OpenLayers.Util.createAlphaImageDiv(\n
                                        \'OpenLayers_Control_minimizeDiv\', \n
                                        null, \n
                                        null, \n
                                        img, \n
                                        \'absolute\');\n
            this.minimizeDiv.style.display = \'none\';\n
            this.minimizeDiv.className = this.displayClass + \'MinimizeButton olButton\';\n
            this.div.appendChild(this.minimizeDiv);            \n
            this.minimizeControl();\n
        } else {\n
            // show the overview map\n
            this.element.style.display = \'\';\n
        }\n
        if(this.map.getExtent()) {\n
            this.update();\n
        }\n
        \n
        this.map.events.on({\n
            buttonclick: this.onButtonClick,\n
            moveend: this.update,\n
            scope: this\n
        });\n
        \n
        if (this.maximized) {\n
            this.maximizeControl();\n
        }\n
        return this.div;\n
    },\n
    \n
    /**\n
     * Method: baseLayerDraw\n
     * Draw the base layer - called if unable to complete in the initial draw\n
     */\n
    baseLayerDraw: function() {\n
        this.draw();\n
        this.map.events.unregister("changebaselayer", this, this.baseLayerDraw);\n
    },\n
\n
    /**\n
     * Method: rectDrag\n
     * Handle extent rectangle drag\n
     *\n
     * Parameters:\n
     * px - {<OpenLayers.Pixel>} The pixel location of the drag.\n
     */\n
    rectDrag: function(px) {\n
        var deltaX = this.handlers.drag.last.x - px.x;\n
        var deltaY = this.handlers.drag.last.y - px.y;\n
        if(deltaX != 0 || deltaY != 0) {\n
            var rectTop = this.rectPxBounds.top;\n
            var rectLeft = this.rectPxBounds.left;\n
            var rectHeight = Math.abs(this.rectPxBounds.getHeight());\n
            var rectWidth = this.rectPxBounds.getWidth();\n
            // don\'t allow dragging off of parent element\n
            var newTop = Math.max(0, (rectTop - deltaY));\n
            newTop = Math.min(newTop,\n
                              this.ovmap.size.h - this.hComp - rectHeight);\n
            var newLeft = Math.max(0, (rectLeft - deltaX));\n
            newLeft = Math.min(newLeft,\n
                               this.ovmap.size.w - this.wComp - rectWidth);\n
            this.setRectPxBounds(new OpenLayers.Bounds(newLeft,\n
                                                       newTop + rectHeight,\n
                                                       newLeft + rectWidth,\n
                                                       newTop));\n
        }\n
    },\n
    \n
    /**\n
     * Method: mapDivClick\n
     * Handle browser events\n
     *\n
     * Parameters:\n
     * evt - {<OpenLayers.Event>} evt\n
     */\n
    mapDivClick: function(evt) {\n
        var pxCenter = this.rectPxBounds.getCenterPixel();\n
        var deltaX = evt.xy.x - pxCenter.x;\n
        var deltaY = evt.xy.y - pxCenter.y;\n
        var top = this.rectPxBounds.top;\n
        var left = this.rectPxBounds.left;\n
        var height = Math.abs(this.rectPxBounds.getHeight());\n
        var width = this.rectPxBounds.getWidth();\n
        var newTop = Math.max(0, (top + deltaY));\n
        newTop = Math.min(newTop, this.ovmap.size.h - height);\n
        var newLeft = Math.max(0, (left + deltaX));\n
        newLeft = Math.min(newLeft, this.ovmap.size.w - width);\n
        this.setRectPxBounds(new OpenLayers.Bounds(newLeft,\n
                                                   newTop + height,\n
                                                   newLeft + width,\n
                                                   newTop));\n
        this.updateMapToRect();\n
    },\n
    \n
    /**\n
     * Method: onButtonClick\n
     *\n
     * Parameters:\n
     * evt - {Event}\n
     */\n
    onButtonClick: function(evt) {\n
        if (evt.buttonElement === this.minimizeDiv) {\n
            this.minimizeControl();\n
        } else if (evt.buttonElement === this.maximizeDiv) {\n
            this.maximizeControl();\n
        }\n
    },\n
\n
    /**\n
     * Method: maximizeControl\n
     * Unhide the control.  Called when the control is in the map viewport.\n
     *\n
     * Parameters:\n
     * e - {<OpenLayers.Event>}\n
     */\n
    maximizeControl: function(e) {\n
        this.element.style.display = \'\';\n
        this.showToggle(false);\n
        if (e != null) {\n
            OpenLayers.Event.stop(e);                                            \n
        }\n
    },\n
\n
    /**\n
     * Method: minimizeControl\n
     * Hide all the contents of the control, shrink the size, \n
     * add the maximize icon\n
     * \n
     * Parameters:\n
     * e - {<OpenLayers.Event>}\n
     */\n
    minimizeControl: function(e) {\n
        this.element.style.display = \'none\';\n
        this.showToggle(true);\n
        if (e != null) {\n
            OpenLayers.Event.stop(e);                                            \n
        }\n
    },\n
\n
    /**\n
     * Method: showToggle\n
     * Hide/Show the toggle depending on whether the control is minimized\n
     *\n
     * Parameters:\n
     * minimize - {Boolean} \n
     */\n
    showToggle: function(minimize) {\n
        this.maximizeDiv.style.display = minimize ? \'\' : \'none\';\n
        this.minimizeDiv.style.display = minimize ? \'none\' : \'\';\n
    },\n
\n
    /**\n
     * Method: update\n
     * Update the overview map after layers move.\n
     */\n
    update: function() {\n
        if(this.ovmap == null) {\n
            this.createMap();\n
        }\n
        \n
        if(this.autoPan || !this.isSuitableOverview()) {\n
            this.updateOverview();\n
        }\n
        \n
        // update extent rectangle\n
        this.updateRectToMap();\n
    },\n
    \n
    /**\n
     * Method: isSuitableOverview\n
     * Determines if the overview map is suitable given the extent and\n
     * resolution of the main map.\n
     */\n
    isSuitableOverview: function() {\n
        var mapExtent = this.map.getExtent();\n
        var maxExtent = this.map.maxExtent;\n
        var testExtent = new OpenLayers.Bounds(\n
                                Math.max(mapExtent.left, maxExtent.left),\n
                                Math.max(mapExtent.bottom, maxExtent.bottom),\n
                                Math.min(mapExtent.right, maxExtent.right),\n
                                Math.min(mapExtent.top, maxExtent.top));        \n
\n
        if (this.ovmap.getProjection() != this.map.getProjection()) {\n
            testExtent = testExtent.transform(\n
                this.map.getProjectionObject(),\n
                this.ovmap.getProjectionObject() );\n
        }\n
\n
        var resRatio = this.ovmap.getResolution() / this.map.getResolution();\n
        return ((resRatio > this.minRatio) &&\n
                (resRatio <= this.maxRatio) &&\n
                (this.ovmap.getExtent().containsBounds(testExtent)));\n
    },\n
    \n
    /**\n
     * Method updateOverview\n
     * Called by <update> if <isSuitableOverview> returns true\n
     */\n
    updateOverview: function() {\n
        var mapRes = this.map.getResolution();\n
        var targetRes = this.ovmap.getResolution();\n
        var resRatio = targetRes / mapRes;\n
        if(resRatio > this.maxRatio) {\n
            // zoom in overview map\n
            targetRes = this.minRatio * mapRes;            \n
        } else if(resRatio <= this.minRatio) {\n
            // zoom out overview map\n
            targetRes = this.maxRatio * mapRes;\n
        }\n
        var center;\n
        if (this.ovmap.getProjection() != this.map.getProjection()) {\n
            center = this.map.center.clone();\n
            center.transform(this.map.getProjectionObject(),\n
                this.ovmap.getProjectionObject() );\n
        } else {\n
            center = this.map.center;\n
        }\n
        this.ovmap.setCenter(center, this.ovmap.getZoomForResolution(\n
            targetRes * this.resolutionFactor));\n
        this.updateRectToMap();\n
    },\n
    \n
    /**\n
     * Method: createMap\n
     * Construct the map that this control contains\n
     */\n
    createMap: function() {\n
        // create the overview map\n
        var options = OpenLayers.Util.extend(\n
                        {controls: [], maxResolution: \'auto\', \n
                         fallThrough: false}, this.mapOptions);\n
        this.ovmap = new OpenLayers.Map(this.mapDiv, options);\n
        this.ovmap.viewPortDiv.appendChild(this.extentRectangle);\n
        \n
        // prevent ovmap from being destroyed when the page unloads, because\n
        // the OverviewMap control has to do this (and does it).\n
        OpenLayers.Event.stopObserving(window, \'unload\', this.ovmap.unloadDestroy);\n
        \n
        this.ovmap.addLayers(this.layers);\n
        this.ovmap.zoomToMaxExtent();\n
        // check extent rectangle border width\n
        this.wComp = parseInt(OpenLayers.Element.getStyle(this.extentRectangle,\n
                                               \'border-left-width\')) +\n
                     parseInt(OpenLayers.Element.getStyle(this.extentRectangle,\n
                                               \'border-right-width\'));\n
        this.wComp = (this.wComp) ? this.wComp : 2;\n
        this.hComp = parseInt(OpenLayers.Element.getStyle(this.extentRectangle,\n
                                               \'border-top-width\')) +\n
                     parseInt(OpenLayers.Element.getStyle(this.extentRectangle,\n
                                               \'border-bottom-width\'));\n
        this.hComp = (this.hComp) ? this.hComp : 2;\n
\n
        this.handlers.drag = new OpenLayers.Handler.Drag(\n
            this, {move: this.rectDrag, done: this.updateMapToRect},\n
            {map: this.ovmap}\n
        );\n
        this.handlers.click = new OpenLayers.Handler.Click(\n
            this, {\n
                "click": this.mapDivClick\n
            },{\n
                "single": true, "double": false,\n
                "stopSingle": true, "stopDouble": true,\n
                "pixelTolerance": 1,\n
                map: this.ovmap\n
            }\n
        );\n
        this.handlers.click.activate();\n
        \n
        this.rectEvents = new OpenLayers.Events(this, this.extentRectangle,\n
                                                null, true);\n
        this.rectEvents.register("mouseover", this, function(e) {\n
            if(!this.handlers.drag.active && !this.map.dragging) {\n
                this.handlers.drag.activate();\n
            }\n
        });\n
        this.rectEvents.register("mouseout", this, function(e) {\n
            if(!this.handlers.drag.dragging) {\n
                this.handlers.drag.deactivate();\n
            }\n
        });\n
\n
        if (this.ovmap.getProjection() != this.map.getProjection()) {\n
            var sourceUnits = this.map.getProjectionObject().getUnits() ||\n
                this.map.units || this.map.baseLayer.units;\n
            var targetUnits = this.ovmap.getProjectionObject().getUnits() ||\n
                this.ovmap.units || this.ovmap.baseLayer.units;\n
            this.resolutionFactor = sourceUnits && targetUnits ?\n
                OpenLayers.INCHES_PER_UNIT[sourceUnits] /\n
                OpenLayers.INCHES_PER_UNIT[targetUnits] : 1;\n
        }\n
    },\n
        \n
    /**\n
     * Method: updateRectToMap\n
     * Updates the extent rectangle position and size to match the map extent\n
     */\n
    updateRectToMap: function() {\n
        // If the projections differ we need to reproject\n
        var bounds;\n
        if (this.ovmap.getProjection() != this.map.getProjection()) {\n
            bounds = this.map.getExtent().transform(\n
                this.map.getProjectionObject(), \n
                this.ovmap.getProjectionObject() );\n
        } else {\n
            bounds = this.map.getExtent();\n
        }\n
        var pxBounds = this.getRectBoundsFromMapBounds(bounds);\n
        if (pxBounds) {\n
            this.setRectPxBounds(pxBounds);\n
        }\n
    },\n
    \n
    /**\n
     * Method: updateMapToRect\n
     * Updates the map extent to match the extent rectangle position and size\n
     */\n
    updateMapToRect: function() {\n
        var lonLatBounds = this.getMapBoundsFromRectBounds(this.rectPxBounds);\n
        if (this.ovmap.getProjection() != this.map.getProjection()) {\n
            lonLatBounds = lonLatBounds.transform(\n
                this.ovmap.getProjectionObject(),\n
                this.map.getProjectionObject() );\n
        }\n
        this.map.panTo(lonLatBounds.getCenterLonLat());\n
    },\n
\n
    /**\n
     * Method: setRectPxBounds\n
     * Set extent rectangle pixel bounds.\n
     *\n
     * Parameters:\n
     * pxBounds - {<OpenLayers.Bounds>}\n
     */\n
    setRectPxBounds: function(pxBounds) {\n
        var top = Math.max(pxBounds.top, 0);\n
        var left = Math.max(pxBounds.left, 0);\n
        var bottom = Math.min(pxBounds.top + Math.abs(pxBounds.getHeight()),\n
                              this.ovmap.size.h - this.hComp);\n
        var right = Math.min(pxBounds.left + pxBounds.getWidth(),\n
                             this.ovmap.size.w - this.wComp);\n
        var width = Math.max(right - left, 0);\n
        var height = Math.max(bottom - top, 0);\n
        if(width < this.minRectSize || height < this.minRectSize) {\n
            this.extentRectangle.className = this.displayClass +\n
                                             this.minRectDisplayClass;\n
            var rLeft = left + (width / 2) - (this.minRectSize / 2);\n
            var rTop = top + (height / 2) - (this.minRectSize / 2);\n
            this.extentRectangle.style.top = Math.round(rTop) + \'px\';\n
            this.extentRectangle.style.left = Math.round(rLeft) + \'px\';\n
            this.extentRectangle.style.height = this.minRectSize + \'px\';\n
            this.extentRectangle.style.width = this.minRectSize + \'px\';\n
        } else {\n
            this.extentRectangle.className = this.displayClass +\n
                                             \'ExtentRectangle\';\n
            this.extentRectangle.style.top = Math.round(top) + \'px\';\n
            this.extentRectangle.style.left = Math.round(left) + \'px\';\n
            this.extentRectangle.style.height = Math.round(height) + \'px\';\n
            this.extentRectangle.style.width = Math.round(width) + \'px\';\n
        }\n
        this.rectPxBounds = new OpenLayers.Bounds(\n
            Math.round(left), Math.round(bottom),\n
            Math.round(right), Math.round(top)\n
        );\n
    },\n
\n
    /**\n
     * Method: getRectBoundsFromMapBounds\n
     * Get the rect bounds from the map bounds.\n
     *\n
     * Parameters:\n
     * lonLatBounds - {<OpenLayers.Bounds>}\n
     *\n
     * Returns:\n
     * {<OpenLayers.Bounds>}A bounds which is the passed-in map lon/lat extent\n
     * translated into pixel bounds for the overview map\n
     */\n
    getRectBoundsFromMapBounds: function(lonLatBounds) {\n
        var leftBottomPx = this.getOverviewPxFromLonLat({\n
            lon: lonLatBounds.left,\n
            lat: lonLatBounds.bottom\n
        });\n
        var rightTopPx = this.getOverviewPxFromLonLat({\n
            lon: lonLatBounds.right,\n
            lat: lonLatBounds.top\n
        });\n
        var bounds = null;\n
        if (leftBottomPx && rightTopPx) {\n
            bounds = new OpenLayers.Bounds(leftBottomPx.x, leftBottomPx.y,\n
                                           rightTopPx.x, rightTopPx.y);\n
        }\n
        return bounds;\n
    },\n
\n
    /**\n
     * Method: getMapBoundsFromRectBounds\n
     * Get the map bounds from the rect bounds.\n
     *\n
     * Parameters:\n
     * pxBounds - {<OpenLayers.Bounds>}\n
     *\n
     * Returns:\n
     * {<OpenLayers.Bounds>} Bounds which is the passed-in overview rect bounds\n
     * translated into lon/lat bounds for the overview map\n
     */\n
    getMapBoundsFromRectBounds: function(pxBounds) {\n
        var leftBottomLonLat = this.getLonLatFromOverviewPx({\n
            x: pxBounds.left,\n
            y: pxBounds.bottom\n
        });\n
        var rightTopLonLat = this.getLonLatFromOverviewPx({\n
            x: pxBounds.right,\n
            y: pxBounds.top\n
        });\n
        return new OpenLayers.Bounds(leftBottomLonLat.lon, leftBottomLonLat.lat,\n
                                     rightTopLonLat.lon, rightTopLonLat.lat);\n
    },\n
\n
    /**\n
     * Method: getLonLatFromOverviewPx\n
     * Get a map location from a pixel location\n
     *\n
     * Parameters:\n
     * overviewMapPx - {<OpenLayers.Pixel>|Object} OpenLayers.Pixel or\n
     *                                             an object with a\n
     *                                             \'x\' and \'y\' properties.\n
     *\n
     * Returns:\n
     * {Object} Location which is the passed-in overview map\n
     * OpenLayers.Pixel, translated into lon/lat by the overview\n
     * map. An object with a \'lon\' and \'lat\' properties.\n
     */\n
    getLonLatFromOverviewPx: function(overviewMapPx) {\n
        var size = this.ovmap.size;\n
        var res  = this.ovmap.getResolution();\n
        var center = this.ovmap.getExtent().getCenterLonLat();\n
    \n
        var deltaX = overviewMapPx.x - (size.w / 2);\n
        var deltaY = overviewMapPx.y - (size.h / 2);\n
\n
        return {\n
            lon: center.lon + deltaX * res,\n
            lat: center.lat - deltaY * res\n
        };\n
    },\n
\n
    /**\n
     * Method: getOverviewPxFromLonLat\n
     * Get a pixel location from a map location\n
     *\n
     * Parameters:\n
     * lonlat - {<OpenLayers.LonLat>|Object} OpenLayers.LonLat or an\n
     *     object with a \'lon\' and \'lat\' properties.\n
     *\n
     * Returns:\n
     * {Object} Location which is the passed-in OpenLayers.LonLat, \n
     * translated into overview map pixels\n
     */\n
    getOverviewPxFromLonLat: function(lonlat) {\n
        var res = this.ovmap.getResolution();\n
        var extent = this.ovmap.getExtent();\n
        if (extent) {\n
            return {\n
                x: Math.round(1/res * (lonlat.lon - extent.left)),\n
                y: Math.round(1/res * (extent.top - lonlat.lat))\n
            };\n
        } \n
    },\n
\n
    CLASS_NAME: \'OpenLayers.Control.OverviewMap\'\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>25888</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
