<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.8</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>ModifyFeature.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Control/DragFeature.js\n
 * @requires OpenLayers/Control/SelectFeature.js\n
 * @requires OpenLayers/Handler/Keyboard.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Control.ModifyFeature\n
 * Control to modify features.  When activated, a click renders the vertices\n
 *     of a feature - these vertices can then be dragged.  By default, the\n
 *     delete key will delete the vertex under the mouse.  New features are\n
 *     added by dragging "virtual vertices" between vertices.  Create a new\n
 *     control with the <OpenLayers.Control.ModifyFeature> constructor.\n
 *\n
 * Inherits From:\n
 *  - <OpenLayers.Control>\n
 */\n
OpenLayers.Control.ModifyFeature = OpenLayers.Class(OpenLayers.Control, {\n
\n
    /**\n
     * APIProperty: geometryTypes\n
     * {Array(String)} To restrict modification to a limited set of geometry\n
     *     types, send a list of strings corresponding to the geometry class\n
     *     names.\n
     */\n
    geometryTypes: null,\n
\n
    /**\n
     * APIProperty: clickout\n
     * {Boolean} Unselect features when clicking outside any feature.\n
     *     Default is true.\n
     */\n
    clickout: true,\n
\n
    /**\n
     * APIProperty: toggle\n
     * {Boolean} Unselect a selected feature on click.\n
     *      Default is true.\n
     */\n
    toggle: true,\n
    \n
    /**\n
     * APIProperty: standalone\n
     * {Boolean} Set to true to create a control without SelectFeature\n
     *     capabilities. Default is false.  If standalone is true, to modify\n
     *     a feature, call the <selectFeature> method with the target feature.\n
     *     Note that you must call the <unselectFeature> method to finish\n
     *     feature modification in standalone mode (before starting to modify\n
     *     another feature).\n
     */\n
    standalone: false,\n
\n
    /**\n
     * Property: layer\n
     * {<OpenLayers.Layer.Vector>}\n
     */\n
    layer: null,\n
    \n
    /**\n
     * Property: feature\n
     * {<OpenLayers.Feature.Vector>} Feature currently available for modification.\n
     */\n
    feature: null,\n
    \n
    /**\n
     * Property: vertices\n
     * {Array(<OpenLayers.Feature.Vector>)} Verticies currently available\n
     *     for dragging.\n
     */\n
    vertices: null,\n
    \n
    /**\n
     * Property: virtualVertices\n
     * {Array(<OpenLayers.Feature.Vector>)} Virtual vertices in the middle\n
     *     of each edge.\n
     */\n
    virtualVertices: null,\n
\n
    /**\n
     * Property: selectControl\n
     * {<OpenLayers.Control.SelectFeature>}\n
     */\n
    selectControl: null,\n
    \n
    /**\n
     * Property: dragControl\n
     * {<OpenLayers.Control.DragFeature>}\n
     */\n
    dragControl: null,\n
    \n
    /**\n
     * Property: handlers\n
     * {Object}\n
     */\n
    handlers: null,\n
    \n
    /**\n
     * APIProperty: deleteCodes\n
     * {Array(Integer)} Keycodes for deleting verticies.  Set to null to disable\n
     *     vertex deltion by keypress.  If non-null, keypresses with codes\n
     *     in this array will delete vertices under the mouse. Default\n
     *     is 46 and 68, the \'delete\' and lowercase \'d\' keys.\n
     */\n
    deleteCodes: null,\n
\n
    /**\n
     * APIProperty: virtualStyle\n
     * {Object} A symbolizer to be used for virtual vertices.\n
     */\n
    virtualStyle: null,\n
    \n
    /**\n
     * APIProperty: vertexRenderIntent\n
     * {String} The renderIntent to use for vertices. If no <virtualStyle> is\n
     * provided, this renderIntent will also be used for virtual vertices, with\n
     * a fillOpacity and strokeOpacity of 0.3. Default is null, which means\n
     * that the layer\'s default style will be used for vertices.\n
     */\n
    vertexRenderIntent: null,\n
\n
    /**\n
     * APIProperty: mode\n
     * {Integer} Bitfields specifying the modification mode. Defaults to\n
     *      OpenLayers.Control.ModifyFeature.RESHAPE. To set the mode to a\n
     *      combination of options, use the | operator. For example, to allow\n
     *      the control to both resize and rotate features, use the following\n
     *      syntax\n
     * (code)\n
     * control.mode = OpenLayers.Control.ModifyFeature.RESIZE |\n
     *                OpenLayers.Control.ModifyFeature.ROTATE;\n
     *  (end)\n
     */\n
    mode: null,\n
\n
    /**\n
     * APIProperty: createVertices\n
     * {Boolean} Create new vertices by dragging the virtual vertices\n
     *     in the middle of each edge. Default is true.\n
     */\n
    createVertices: true,\n
\n
    /**\n
     * Property: modified\n
     * {Boolean} The currently selected feature has been modified.\n
     */\n
    modified: false,\n
\n
    /**\n
     * Property: radiusHandle\n
     * {<OpenLayers.Feature.Vector>} A handle for rotating/resizing a feature.\n
     */\n
    radiusHandle: null,\n
\n
    /**\n
     * Property: dragHandle\n
     * {<OpenLayers.Feature.Vector>} A handle for dragging a feature.\n
     */\n
    dragHandle: null,\n
\n
    /**\n
     * APIProperty: onModificationStart \n
     * {Function} *Deprecated*.  Register for "beforefeaturemodified" instead.\n
     *     The "beforefeaturemodified" event is triggered on the layer before\n
     *     any modification begins.\n
     *\n
     * Optional function to be called when a feature is selected\n
     *     to be modified. The function should expect to be called with a\n
     *     feature.  This could be used for example to allow to lock the\n
     *     feature on server-side.\n
     */\n
    onModificationStart: function() {},\n
\n
    /**\n
     * APIProperty: onModification\n
     * {Function} *Deprecated*.  Register for "featuremodified" instead.\n
     *     The "featuremodified" event is triggered on the layer with each\n
     *     feature modification.\n
     *\n
     * Optional function to be called when a feature has been\n
     *     modified.  The function should expect to be called with a feature.\n
     */\n
    onModification: function() {},\n
\n
    /**\n
     * APIProperty: onModificationEnd\n
     * {Function} *Deprecated*.  Register for "afterfeaturemodified" instead.\n
     *     The "afterfeaturemodified" event is triggered on the layer after\n
     *     a feature has been modified.\n
     *\n
     * Optional function to be called when a feature is finished \n
     *     being modified.  The function should expect to be called with a\n
     *     feature.\n
     */\n
    onModificationEnd: function() {},\n
\n
    /**\n
     * Constructor: OpenLayers.Control.ModifyFeature\n
     * Create a new modify feature control.\n
     *\n
     * Parameters:\n
     * layer - {<OpenLayers.Layer.Vector>} Layer that contains features that\n
     *     will be modified.\n
     * options - {Object} Optional object whose properties will be set on the\n
     *     control.\n
     */\n
    initialize: function(layer, options) {\n
        options = options || {};\n
        this.layer = layer;\n
        this.vertices = [];\n
        this.virtualVertices = [];\n
        this.virtualStyle = OpenLayers.Util.extend({},\n
            this.layer.style ||\n
            this.layer.styleMap.createSymbolizer(null, options.vertexRenderIntent)\n
        );\n
        this.virtualStyle.fillOpacity = 0.3;\n
        this.virtualStyle.strokeOpacity = 0.3;\n
        this.deleteCodes = [46, 68];\n
        this.mode = OpenLayers.Control.ModifyFeature.RESHAPE;\n
        OpenLayers.Control.prototype.initialize.apply(this, [options]);\n
        if(!(OpenLayers.Util.isArray(this.deleteCodes))) {\n
            this.deleteCodes = [this.deleteCodes];\n
        }\n
        var control = this;\n
\n
        // configure the select control\n
        var selectOptions = {\n
            geometryTypes: this.geometryTypes,\n
            clickout: this.clickout,\n
            toggle: this.toggle,\n
            onBeforeSelect: this.beforeSelectFeature,\n
            onSelect: this.selectFeature,\n
            onUnselect: this.unselectFeature,\n
            scope: this\n
        };\n
        if(this.standalone === false) {\n
            this.selectControl = new OpenLayers.Control.SelectFeature(\n
                layer, selectOptions\n
            );\n
        }\n
\n
        // configure the drag control\n
        var dragOptions = {\n
            geometryTypes: ["OpenLayers.Geometry.Point"],\n
            onStart: function(feature, pixel) {\n
                control.dragStart.apply(control, [feature, pixel]);\n
            },\n
            onDrag: function(feature, pixel) {\n
                control.dragVertex.apply(control, [feature, pixel]);\n
            },\n
            onComplete: function(feature) {\n
                control.dragComplete.apply(control, [feature]);\n
            },\n
            featureCallbacks: {\n
                over: function(feature) {\n
                    /**\n
                     * In normal mode, the feature handler is set up to allow\n
                     * dragging of all points.  In standalone mode, we only\n
                     * want to allow dragging of sketch vertices and virtual\n
                     * vertices - or, in the case of a modifiable point, the\n
                     * point itself.\n
                     */\n
                    if(control.standalone !== true || feature._sketch ||\n
                       control.feature === feature) {\n
                        control.dragControl.overFeature.apply(\n
                            control.dragControl, [feature]);\n
                    }\n
                }\n
            }\n
        };\n
        this.dragControl = new OpenLayers.Control.DragFeature(\n
            layer, dragOptions\n
        );\n
\n
        // configure the keyboard handler\n
        var keyboardOptions = {\n
            keydown: this.handleKeypress\n
        };\n
        this.handlers = {\n
            keyboard: new OpenLayers.Handler.Keyboard(this, keyboardOptions)\n
        };\n
    },\n
\n
    /**\n
     * APIMethod: destroy\n
     * Take care of things that are not handled in superclass.\n
     */\n
    destroy: function() {\n
        this.layer = null;\n
        this.standalone || this.selectControl.destroy();\n
        this.dragControl.destroy();\n
        OpenLayers.Control.prototype.destroy.apply(this, []);\n
    },\n
\n
    /**\n
     * APIMethod: activate\n
     * Activate the control.\n
     * \n
     * Returns:\n
     * {Boolean} Successfully activated the control.\n
     */\n
    activate: function() {\n
        return ((this.standalone || this.selectControl.activate()) &&\n
                this.handlers.keyboard.activate() &&\n
                OpenLayers.Control.prototype.activate.apply(this, arguments));\n
    },\n
\n
    /**\n
     * APIMethod: deactivate\n
     * Deactivate the control.\n
     *\n
     * Returns: \n
     * {Boolean} Successfully deactivated the control.\n
     */\n
    deactivate: function() {\n
        var deactivated = false;\n
        // the return from the controls is unimportant in this case\n
        if(OpenLayers.Control.prototype.deactivate.apply(this, arguments)) {\n
            this.layer.removeFeatures(this.vertices, {silent: true});\n
            this.layer.removeFeatures(this.virtualVertices, {silent: true});\n
            this.vertices = [];\n
            this.dragControl.deactivate();\n
            var feature = this.feature;\n
            var valid = feature && feature.geometry && feature.layer;\n
            if(this.standalone === false) {\n
                if(valid) {\n
                    this.selectControl.unselect.apply(this.selectControl,\n
                                                      [feature]);\n
                }\n
                this.selectControl.deactivate();\n
            } else {\n
                if(valid) {\n
                    this.unselectFeature(feature);\n
                }\n
            }\n
            this.handlers.keyboard.deactivate();\n
            deactivated = true;\n
        }\n
        return deactivated;\n
    },\n
    \n
    /**\n
     * Method: beforeSelectFeature\n
     * Called before a feature is selected.\n
     *\n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>} The feature about to be selected.\n
     */\n
    beforeSelectFeature: function(feature) {\n
        return this.layer.events.triggerEvent(\n
            "beforefeaturemodified", {feature: feature}\n
        );\n
    },\n
\n
    /**\n
     * APIMethod: selectFeature\n
     * Select a feature for modification in standalone mode. In non-standalone\n
     * mode, this method is called when the select feature control selects a\n
     * feature. Register a listener to the beforefeaturemodified event and\n
     * return false to prevent feature modification.\n
     *\n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>} the selected feature.\n
     */\n
    selectFeature: function(feature) {\n
        if (!this.standalone || this.beforeSelectFeature(feature) !== false) {\n
            this.feature = feature;\n
            this.modified = false;\n
            this.resetVertices();\n
            this.dragControl.activate();\n
            this.onModificationStart(this.feature);\n
        }\n
        // keep track of geometry modifications\n
        var modified = feature.modified;\n
        if (feature.geometry && !(modified && modified.geometry)) {\n
            this._originalGeometry = feature.geometry.clone();\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: unselectFeature\n
     * Called when the select feature control unselects a feature.\n
     *\n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>} The unselected feature.\n
     */\n
    unselectFeature: function(feature) {\n
        this.layer.removeFeatures(this.vertices, {silent: true});\n
        this.vertices = [];\n
        this.layer.destroyFeatures(this.virtualVertices, {silent: true});\n
        this.virtualVertices = [];\n
        if(this.dragHandle) {\n
            this.layer.destroyFeatures([this.dragHandle], {silent: true});\n
            delete this.dragHandle;\n
        }\n
        if(this.radiusHandle) {\n
            this.layer.destroyFeatures([this.radiusHandle], {silent: true});\n
            delete this.radiusHandle;\n
        }\n
        this.feature = null;\n
        this.dragControl.deactivate();\n
        this.onModificationEnd(feature);\n
        this.layer.events.triggerEvent("afterfeaturemodified", {\n
            feature: feature,\n
            modified: this.modified\n
        });\n
        this.modified = false;\n
    },\n
\n
    /**\n
     * Method: dragStart\n
     * Called by the drag feature control with before a feature is dragged.\n
     *     This method is used to differentiate between points and vertices\n
     *     of higher order geometries.  This respects the <geometryTypes>\n
     *     property and forces a select of points when the drag control is\n
     *     already active (and stops events from propagating to the select\n
     *     control).\n
     *\n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>} The point or vertex about to be\n
     *     dragged.\n
     * pixel - {<OpenLayers.Pixel>} Pixel location of the mouse event.\n
     */\n
    dragStart: function(feature, pixel) {\n
        // only change behavior if the feature is not in the vertices array\n
        if(feature != this.feature && !feature.geometry.parent &&\n
           feature != this.dragHandle && feature != this.radiusHandle) {\n
            if(this.standalone === false && this.feature) {\n
                // unselect the currently selected feature\n
                this.selectControl.clickFeature.apply(this.selectControl,\n
                                                      [this.feature]);\n
            }\n
            // check any constraints on the geometry type\n
            if(this.geometryTypes == null ||\n
               OpenLayers.Util.indexOf(this.geometryTypes,\n
                                       feature.geometry.CLASS_NAME) != -1) {\n
                // select the point\n
                this.standalone || this.selectControl.clickFeature.apply(\n
                                            this.selectControl, [feature]);\n
                /**\n
                 * TBD: These lines improve workflow by letting the user\n
                 *     immediately start dragging after the mouse down.\n
                 *     However, it is very ugly to be messing with controls\n
                 *     and their handlers in this way.  I\'d like a better\n
                 *     solution if the workflow change is necessary.\n
                 */\n
                // prepare the point for dragging\n
                this.dragControl.overFeature.apply(this.dragControl,\n
                                                   [feature]);\n
                this.dragControl.lastPixel = pixel;\n
                this.dragControl.handlers.drag.started = true;\n
                this.dragControl.handlers.drag.start = pixel;\n
                this.dragControl.handlers.drag.last = pixel;\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: dragVertex\n
     * Called by the drag feature control with each drag move of a vertex.\n
     *\n
     * Parameters:\n
     * vertex - {<OpenLayers.Feature.Vector>} The vertex being dragged.\n
     * pixel - {<OpenLayers.Pixel>} Pixel location of the mouse event.\n
     */\n
    dragVertex: function(vertex, pixel) {\n
        this.modified = true;\n
        /**\n
         * Five cases:\n
         * 1) dragging a simple point\n
         * 2) dragging a virtual vertex\n
         * 3) dragging a drag handle\n
         * 4) dragging a real vertex\n
         * 5) dragging a radius handle\n
         */\n
        if(this.feature.geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {\n
            // dragging a simple point\n
            if(this.feature != vertex) {\n
                this.feature = vertex;\n
            }\n
            this.layer.events.triggerEvent("vertexmodified", {\n
                vertex: vertex.geometry,\n
                feature: this.feature,\n
                pixel: pixel\n
            });\n
        } else {\n
            if(vertex._index) {\n
                // dragging a virtual vertex\n
                vertex.geometry.parent.addComponent(vertex.geometry,\n
                                                    vertex._index);\n
                // move from virtual to real vertex\n
                delete vertex._index;\n
                OpenLayers.Util.removeItem(this.virtualVertices, vertex);\n
                this.vertices.push(vertex);\n
            } else if(vertex == this.dragHandle) {\n
                // dragging a drag handle\n
                this.layer.removeFeatures(this.vertices, {silent: true});\n
                this.vertices = [];\n
                if(this.radiusHandle) {\n
                    this.layer.destroyFeatures([this.radiusHandle], {silent: true});\n
                    this.radiusHandle = null;\n
                }\n
            } else if(vertex !== this.radiusHandle) {\n
                // dragging a real vertex\n
                this.layer.events.triggerEvent("vertexmodified", {\n
                    vertex: vertex.geometry,\n
                    feature: this.feature,\n
                    pixel: pixel\n
                });\n
            }\n
            // dragging a radius handle - no special treatment\n
            if(this.virtualVertices.length > 0) {\n
                this.layer.destroyFeatures(this.virtualVertices, {silent: true});\n
                this.virtualVertices = [];\n
            }\n
            this.layer.drawFeature(this.feature, this.standalone ? undefined :\n
                                            this.selectControl.renderIntent);\n
        }\n
        // keep the vertex on top so it gets the mouseout after dragging\n
        // this should be removed in favor of an option to draw under or\n
        // maintain node z-index\n
        this.layer.drawFeature(vertex);\n
    },\n
    \n
    /**\n
     * Method: dragComplete\n
     * Called by the drag feature control when the feature dragging is complete.\n
     *\n
     * Parameters:\n
     * vertex - {<OpenLayers.Feature.Vector>} The vertex being dragged.\n
     */\n
    dragComplete: function(vertex) {\n
        this.resetVertices();\n
        this.setFeatureState();\n
        this.onModification(this.feature);\n
        this.layer.events.triggerEvent("featuremodified", \n
                                       {feature: this.feature});\n
    },\n
    \n
    /**\n
     * Method: setFeatureState\n
     * Called when the feature is modified.  If the current state is not\n
     *     INSERT or DELETE, the state is set to UPDATE.\n
     */\n
    setFeatureState: function() {\n
        if(this.feature.state != OpenLayers.State.INSERT &&\n
           this.feature.state != OpenLayers.State.DELETE) {\n
            this.feature.state = OpenLayers.State.UPDATE;\n
            if (this.modified && this._originalGeometry) {\n
                var feature = this.feature;\n
                feature.modified = OpenLayers.Util.extend(feature.modified, {\n
                    geometry: this._originalGeometry\n
                });\n
                delete this._originalGeometry;\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: resetVertices\n
     */\n
    resetVertices: function() {\n
        // if coming from a drag complete we\'re about to destroy the vertex\n
        // that was just dragged. For that reason, the drag feature control\n
        // will never detect a mouse-out on that vertex, meaning that the drag\n
        // handler won\'t be deactivated. This can cause errors because the drag\n
        // feature control still has a feature to drag but that feature is\n
        // destroyed. To prevent this, we call outFeature on the drag feature\n
        // control if the control actually has a feature to drag.\n
        if(this.dragControl.feature) {\n
            this.dragControl.outFeature(this.dragControl.feature);\n
        }\n
        if(this.vertices.length > 0) {\n
            this.layer.removeFeatures(this.vertices, {silent: true});\n
            this.vertices = [];\n
        }\n
        if(this.virtualVertices.length > 0) {\n
            this.layer.removeFeatures(this.virtualVertices, {silent: true});\n
            this.virtualVertices = [];\n
        }\n
        if(this.dragHandle) {\n
            this.layer.destroyFeatures([this.dragHandle], {silent: true});\n
            this.dragHandle = null;\n
        }\n
        if(this.radiusHandle) {\n
            this.layer.destroyFeatures([this.radiusHandle], {silent: true});\n
            this.radiusHandle = null;\n
        }\n
        if(this.feature &&\n
           this.feature.geometry.CLASS_NAME != "OpenLayers.Geometry.Point") {\n
            if((this.mode & OpenLayers.Control.ModifyFeature.DRAG)) {\n
                this.collectDragHandle();\n
            }\n
            if((this.mode & (OpenLayers.Control.ModifyFeature.ROTATE |\n
                             OpenLayers.Control.ModifyFeature.RESIZE))) {\n
                this.collectRadiusHandle();\n
            }\n
            if(this.mode & OpenLayers.Control.ModifyFeature.RESHAPE){\n
                // Don\'t collect vertices when we\'re resizing\n
                if (!(this.mode & OpenLayers.Control.ModifyFeature.RESIZE)){\n
                    this.collectVertices();\n
                }\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: handleKeypress\n
     * Called by the feature handler on keypress.  This is used to delete\n
     *     vertices. If the <deleteCode> property is set, vertices will\n
     *     be deleted when a feature is selected for modification and\n
     *     the mouse is over a vertex.\n
     *\n
     * Parameters:\n
     * evt - {Event} Keypress event.\n
     */\n
    handleKeypress: function(evt) {\n
        var code = evt.keyCode;\n
        \n
        // check for delete key\n
        if(this.feature &&\n
           OpenLayers.Util.indexOf(this.deleteCodes, code) != -1) {\n
            var vertex = this.dragControl.feature;\n
            if(vertex &&\n
               OpenLayers.Util.indexOf(this.vertices, vertex) != -1 &&\n
               !this.dragControl.handlers.drag.dragging &&\n
               vertex.geometry.parent) {\n
                // remove the vertex\n
                vertex.geometry.parent.removeComponent(vertex.geometry);\n
                this.layer.events.triggerEvent("vertexremoved", {\n
                    vertex: vertex.geometry,\n
                    feature: this.feature,\n
                    pixel: evt.xy\n
                });\n
                this.layer.drawFeature(this.feature, this.standalone ?\n
                                       undefined :\n
                                       this.selectControl.renderIntent);\n
                this.modified = true;\n
                this.resetVertices();\n
                this.setFeatureState();\n
                this.onModification(this.feature);\n
                this.layer.events.triggerEvent("featuremodified", \n
                                               {feature: this.feature});\n
            }\n
        }\n
    },\n
\n
    /**\n
     * Method: collectVertices\n
     * Collect the vertices from the modifiable feature\'s geometry and push\n
     *     them on to the control\'s vertices array.\n
     */\n
    collectVertices: function() {\n
        this.vertices = [];\n
        this.virtualVertices = [];        \n
        var control = this;\n
        function collectComponentVertices(geometry) {\n
            var i, vertex, component, len;\n
            if(geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {\n
                vertex = new OpenLayers.Feature.Vector(geometry);\n
                vertex._sketch = true;\n
                vertex.renderIntent = control.vertexRenderIntent;\n
                control.vertices.push(vertex);\n
            } else {\n
                var numVert = geometry.components.length;\n
                if(geometry.CLASS_NAME == "OpenLayers.Geometry.LinearRing") {\n
                    numVert -= 1;\n
                }\n
                for(i=0; i<numVert; ++i) {\n
                    component = geometry.components[i];\n
                    if(component.CLASS_NAME == "OpenLayers.Geometry.Point") {\n
                        vertex = new OpenLayers.Feature.Vector(component);\n
                        vertex._sketch = true;\n
                        vertex.renderIntent = control.vertexRenderIntent;\n
                        control.vertices.push(vertex);\n
                    } else {\n
                        collectComponentVertices(component);\n
                    }\n
                }\n
                \n
                // add virtual vertices in the middle of each edge\n
                if (control.createVertices && geometry.CLASS_NAME != "OpenLayers.Geometry.MultiPoint") {\n
                    for(i=0, len=geometry.components.length; i<len-1; ++i) {\n
                        var prevVertex = geometry.components[i];\n
                        var nextVertex = geometry.components[i + 1];\n
                        if(prevVertex.CLASS_NAME == "OpenLayers.Geometry.Point" &&\n
                           nextVertex.CLASS_NAME == "OpenLayers.Geometry.Point") {\n
                            var x = (prevVertex.x + nextVertex.x) / 2;\n
                            var y = (prevVertex.y + nextVertex.y) / 2;\n
                            var point = new OpenLayers.Feature.Vector(\n
                                new OpenLayers.Geometry.Point(x, y),\n
                                null, control.virtualStyle\n
                            );\n
                            // set the virtual parent and intended index\n
                            point.geometry.parent = geometry;\n
                            point._index = i + 1;\n
                            point._sketch = true;\n
                            control.virtualVertices.push(point);\n
                        }\n
                    }\n
                }\n
            }\n
        }\n
        collectComponentVertices.call(this, this.feature.geometry);\n
        this.layer.addFeatures(this.virtualVertices, {silent: true});\n
        this.layer.addFeatures(this.vertices, {silent: true});\n
    },\n
\n
    /**\n
     * Method: collectDragHandle\n
     * Collect the drag handle for the selected geometry.\n
     */\n
    collectDragHandle: function() {\n
        var geometry = this.feature.geometry;\n
        var center = geometry.getBounds().getCenterLonLat();\n
        var originGeometry = new OpenLayers.Geometry.Point(\n
            center.lon, center.lat\n
        );\n
        var origin = new OpenLayers.Feature.Vector(originGeometry);\n
        originGeometry.move = function(x, y) {\n
            OpenLayers.Geometry.Point.prototype.move.call(this, x, y);\n
            geometry.move(x, y);\n
        };\n
        origin._sketch = true;\n
        this.dragHandle = origin;\n
        this.dragHandle.renderIntent = this.vertexRenderIntent;\n
        this.layer.addFeatures([this.dragHandle], {silent: true});\n
    },\n
\n
    /**\n
     * Method: collectRadiusHandle\n
     * Collect the radius handle for the selected geometry.\n
     */\n
    collectRadiusHandle: function() {\n
        var geometry = this.feature.geometry;\n
        var bounds = geometry.getBounds();\n
        var center = bounds.getCenterLonLat();\n
        var originGeometry = new OpenLayers.Geometry.Point(\n
            center.lon, center.lat\n
        );\n
        var radiusGeometry = new OpenLayers.Geometry.Point(\n
            bounds.right, bounds.bottom\n
        );\n
        var radius = new OpenLayers.Feature.Vector(radiusGeometry);\n
        var resize = (this.mode & OpenLayers.Control.ModifyFeature.RESIZE);\n
        var reshape = (this.mode & OpenLayers.Control.ModifyFeature.RESHAPE);\n
        var rotate = (this.mode & OpenLayers.Control.ModifyFeature.ROTATE);\n
\n
        radiusGeometry.move = function(x, y) {\n
            OpenLayers.Geometry.Point.prototype.move.call(this, x, y);\n
            var dx1 = this.x - originGeometry.x;\n
            var dy1 = this.y - originGeometry.y;\n
            var dx0 = dx1 - x;\n
            var dy0 = dy1 - y;\n
            if(rotate) {\n
                var a0 = Math.atan2(dy0, dx0);\n
                var a1 = Math.atan2(dy1, dx1);\n
                var angle = a1 - a0;\n
                angle *= 180 / Math.PI;\n
                geometry.rotate(angle, originGeometry);\n
            }\n
            if(resize) {\n
                var scale, ratio;\n
                // \'resize\' together with \'reshape\' implies that the aspect \n
                // ratio of the geometry will not be preserved whilst resizing \n
                if (reshape) {\n
                    scale = dy1 / dy0;\n
                    ratio = (dx1 / dx0) / scale;\n
                } else {\n
                    var l0 = Math.sqrt((dx0 * dx0) + (dy0 * dy0));\n
                    var l1 = Math.sqrt((dx1 * dx1) + (dy1 * dy1));\n
                    scale = l1 / l0;\n
                }\n
                geometry.resize(scale, originGeometry, ratio);\n
            }\n
        };\n
        radius._sketch = true;\n
        this.radiusHandle = radius;\n
        this.radiusHandle.renderIntent = this.vertexRenderIntent;\n
        this.layer.addFeatures([this.radiusHandle], {silent: true});\n
    },\n
\n
    /**\n
     * Method: setMap\n
     * Set the map property for the control and all handlers.\n
     *\n
     * Parameters:\n
     * map - {<OpenLayers.Map>} The control\'s map.\n
     */\n
    setMap: function(map) {\n
        this.standalone || this.selectControl.setMap(map);\n
        this.dragControl.setMap(map);\n
        OpenLayers.Control.prototype.setMap.apply(this, arguments);\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Control.ModifyFeature"\n
});\n
\n
/**\n
 * Constant: RESHAPE\n
 * {Integer} Constant used to make the control work in reshape mode\n
 */\n
OpenLayers.Control.ModifyFeature.RESHAPE = 1;\n
/**\n
 * Constant: RESIZE\n
 * {Integer} Constant used to make the control work in resize mode\n
 */\n
OpenLayers.Control.ModifyFeature.RESIZE = 2;\n
/**\n
 * Constant: ROTATE\n
 * {Integer} Constant used to make the control work in rotate mode\n
 */\n
OpenLayers.Control.ModifyFeature.ROTATE = 4;\n
/**\n
 * Constant: DRAG\n
 * {Integer} Constant used to make the control work in drag mode\n
 */\n
OpenLayers.Control.ModifyFeature.DRAG = 8;\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>31212</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
