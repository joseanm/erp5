<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.89</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Feature.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/Handler.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Handler.Feature \n
 * Handler to respond to mouse events related to a drawn feature.  Callbacks\n
 *     with the following keys will be notified of the following events\n
 *     associated with features: click, clickout, over, out, and dblclick.\n
 *\n
 * This handler stops event propagation for mousedown and mouseup if those\n
 *     browser events target features that can be selected.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Handler>\n
 */\n
OpenLayers.Handler.Feature = OpenLayers.Class(OpenLayers.Handler, {\n
\n
    /**\n
     * Property: EVENTMAP\n
     * {Object} A object mapping the browser events to objects with callback\n
     *     keys for in and out.\n
     */\n
    EVENTMAP: {\n
        \'click\': {\'in\': \'click\', \'out\': \'clickout\'},\n
        \'mousemove\': {\'in\': \'over\', \'out\': \'out\'},\n
        \'dblclick\': {\'in\': \'dblclick\', \'out\': null},\n
        \'mousedown\': {\'in\': null, \'out\': null},\n
        \'mouseup\': {\'in\': null, \'out\': null},\n
        \'touchstart\': {\'in\': \'click\', \'out\': \'clickout\'}\n
    },\n
\n
    /**\n
     * Property: feature\n
     * {<OpenLayers.Feature.Vector>} The last feature that was hovered.\n
     */\n
    feature: null,\n
\n
    /**\n
     * Property: lastFeature\n
     * {<OpenLayers.Feature.Vector>} The last feature that was handled.\n
     */\n
    lastFeature: null,\n
\n
    /**\n
     * Property: down\n
     * {<OpenLayers.Pixel>} The location of the last mousedown.\n
     */\n
    down: null,\n
\n
    /**\n
     * Property: up\n
     * {<OpenLayers.Pixel>} The location of the last mouseup.\n
     */\n
    up: null,\n
\n
    /**\n
     * Property: touch\n
     * {Boolean} When a touchstart event is fired, touch will be true and all\n
     *     mouse related listeners will do nothing.\n
     */\n
    touch: false,\n
    \n
    /**\n
     * Property: clickTolerance\n
     * {Number} The number of pixels the mouse can move between mousedown\n
     *     and mouseup for the event to still be considered a click.\n
     *     Dragging the map should not trigger the click and clickout callbacks\n
     *     unless the map is moved by less than this tolerance. Defaults to 4.\n
     */\n
    clickTolerance: 4,\n
\n
    /**\n
     * Property: geometryTypes\n
     * To restrict dragging to a limited set of geometry types, send a list\n
     * of strings corresponding to the geometry class names.\n
     * \n
     * @type Array(String)\n
     */\n
    geometryTypes: null,\n
\n
    /**\n
     * Property: stopClick\n
     * {Boolean} If stopClick is set to true, handled clicks do not\n
     *      propagate to other click listeners. Otherwise, handled clicks\n
     *      do propagate. Unhandled clicks always propagate, whatever the\n
     *      value of stopClick. Defaults to true.\n
     */\n
    stopClick: true,\n
\n
    /**\n
     * Property: stopDown\n
     * {Boolean} If stopDown is set to true, handled mousedowns do not\n
     *      propagate to other mousedown listeners. Otherwise, handled\n
     *      mousedowns do propagate. Unhandled mousedowns always propagate,\n
     *      whatever the value of stopDown. Defaults to true.\n
     */\n
    stopDown: true,\n
\n
    /**\n
     * Property: stopUp\n
     * {Boolean} If stopUp is set to true, handled mouseups do not\n
     *      propagate to other mouseup listeners. Otherwise, handled mouseups\n
     *      do propagate. Unhandled mouseups always propagate, whatever the\n
     *      value of stopUp. Defaults to false.\n
     */\n
    stopUp: false,\n
    \n
    /**\n
     * Constructor: OpenLayers.Handler.Feature\n
     *\n
     * Parameters:\n
     * control - {<OpenLayers.Control>} \n
     * layer - {<OpenLayers.Layer.Vector>}\n
     * callbacks - {Object} An object with a \'over\' property whos value is\n
     *     a function to be called when the mouse is over a feature. The \n
     *     callback should expect to recieve a single argument, the feature.\n
     * options - {Object} \n
     */\n
    initialize: function(control, layer, callbacks, options) {\n
        OpenLayers.Handler.prototype.initialize.apply(this, [control, callbacks, options]);\n
        this.layer = layer;\n
    },\n
\n
    /**\n
     * Method: touchstart\n
     * Handle touchstart events\n
     *\n
     * Parameters:\n
     * evt - {Event}\n
     *\n
     * Returns:\n
     * {Boolean} Let the event propagate.\n
     */\n
    touchstart: function(evt) {\n
        if(!this.touch) {\n
            this.touch =  true;\n
            this.map.events.un({\n
                mousedown: this.mousedown,\n
                mouseup: this.mouseup,\n
                mousemove: this.mousemove,\n
                click: this.click,\n
                dblclick: this.dblclick,\n
                scope: this\n
            });\n
        }\n
        return OpenLayers.Event.isMultiTouch(evt) ?\n
                true : this.mousedown(evt);\n
    },\n
\n
    /**\n
     * Method: touchmove\n
     * Handle touchmove events. We just prevent the browser default behavior,\n
     *    for Android Webkit not to select text when moving the finger after\n
     *    selecting a feature.\n
     *\n
     * Parameters:\n
     * evt - {Event}\n
     */\n
    touchmove: function(evt) {\n
        OpenLayers.Event.stop(evt);\n
    },\n
\n
    /**\n
     * Method: mousedown\n
     * Handle mouse down.  Stop propagation if a feature is targeted by this\n
     *     event (stops map dragging during feature selection).\n
     * \n
     * Parameters:\n
     * evt - {Event} \n
     */\n
    mousedown: function(evt) {\n
        // Feature selection is only done with a left click. Other handlers may stop the\n
        // propagation of left-click mousedown events but not right-click mousedown events.\n
        // This mismatch causes problems when comparing the location of the down and up\n
        // events in the click function so it is important ignore right-clicks.\n
        if (OpenLayers.Event.isLeftClick(evt) || OpenLayers.Event.isSingleTouch(evt)) {\n
            this.down = evt.xy;\n
        }\n
        return this.handle(evt) ? !this.stopDown : true;\n
    },\n
    \n
    /**\n
     * Method: mouseup\n
     * Handle mouse up.  Stop propagation if a feature is targeted by this\n
     *     event.\n
     * \n
     * Parameters:\n
     * evt - {Event} \n
     */\n
    mouseup: function(evt) {\n
        this.up = evt.xy;\n
        return this.handle(evt) ? !this.stopUp : true;\n
    },\n
\n
    /**\n
     * Method: click\n
     * Handle click.  Call the "click" callback if click on a feature,\n
     *     or the "clickout" callback if click outside any feature.\n
     * \n
     * Parameters:\n
     * evt - {Event} \n
     *\n
     * Returns:\n
     * {Boolean}\n
     */\n
    click: function(evt) {\n
        return this.handle(evt) ? !this.stopClick : true;\n
    },\n
        \n
    /**\n
     * Method: mousemove\n
     * Handle mouse moves.  Call the "over" callback if moving in to a feature,\n
     *     or the "out" callback if moving out of a feature.\n
     * \n
     * Parameters:\n
     * evt - {Event} \n
     *\n
     * Returns:\n
     * {Boolean}\n
     */\n
    mousemove: function(evt) {\n
        if (!this.callbacks[\'over\'] && !this.callbacks[\'out\']) {\n
            return true;\n
        }     \n
        this.handle(evt);\n
        return true;\n
    },\n
    \n
    /**\n
     * Method: dblclick\n
     * Handle dblclick.  Call the "dblclick" callback if dblclick on a feature.\n
     *\n
     * Parameters:\n
     * evt - {Event} \n
     *\n
     * Returns:\n
     * {Boolean}\n
     */\n
    dblclick: function(evt) {\n
        return !this.handle(evt);\n
    },\n
\n
    /**\n
     * Method: geometryTypeMatches\n
     * Return true if the geometry type of the passed feature matches\n
     *     one of the geometry types in the geometryTypes array.\n
     *\n
     * Parameters:\n
     * feature - {<OpenLayers.Vector.Feature>}\n
     *\n
     * Returns:\n
     * {Boolean}\n
     */\n
    geometryTypeMatches: function(feature) {\n
        return this.geometryTypes == null ||\n
            OpenLayers.Util.indexOf(this.geometryTypes,\n
                                    feature.geometry.CLASS_NAME) > -1;\n
    },\n
\n
    /**\n
     * Method: handle\n
     *\n
     * Parameters:\n
     * evt - {Event}\n
     *\n
     * Returns:\n
     * {Boolean} The event occurred over a relevant feature.\n
     */\n
    handle: function(evt) {\n
        if(this.feature && !this.feature.layer) {\n
            // feature has been destroyed\n
            this.feature = null;\n
        }\n
        var type = evt.type;\n
        var handled = false;\n
        var previouslyIn = !!(this.feature); // previously in a feature\n
        var click = (type == "click" || type == "dblclick" || type == "touchstart");\n
        this.feature = this.layer.getFeatureFromEvent(evt);\n
        if(this.feature && !this.feature.layer) {\n
            // feature has been destroyed\n
            this.feature = null;\n
        }\n
        if(this.lastFeature && !this.lastFeature.layer) {\n
            // last feature has been destroyed\n
            this.lastFeature = null;\n
        }\n
        if(this.feature) {\n
            if(type === "touchstart") {\n
                // stop the event to prevent Android Webkit from\n
                // "flashing" the map div\n
                OpenLayers.Event.stop(evt);\n
            }\n
            var inNew = (this.feature != this.lastFeature);\n
            if(this.geometryTypeMatches(this.feature)) {\n
                // in to a feature\n
                if(previouslyIn && inNew) {\n
                    // out of last feature and in to another\n
                    if(this.lastFeature) {\n
                        this.triggerCallback(type, \'out\', [this.lastFeature]);\n
                    }\n
                    this.triggerCallback(type, \'in\', [this.feature]);\n
                } else if(!previouslyIn || click) {\n
                    // in feature for the first time\n
                    this.triggerCallback(type, \'in\', [this.feature]);\n
                }\n
                this.lastFeature = this.feature;\n
                handled = true;\n
            } else {\n
                // not in to a feature\n
                if(this.lastFeature && (previouslyIn && inNew || click)) {\n
                    // out of last feature for the first time\n
                    this.triggerCallback(type, \'out\', [this.lastFeature]);\n
                }\n
                // next time the mouse goes in a feature whose geometry type\n
                // doesn\'t match we don\'t want to call the \'out\' callback\n
                // again, so let\'s set this.feature to null so that\n
                // previouslyIn will evaluate to false the next time\n
                // we enter handle. Yes, a bit hackish...\n
                this.feature = null;\n
            }\n
        } else {\n
            if(this.lastFeature && (previouslyIn || click)) {\n
                this.triggerCallback(type, \'out\', [this.lastFeature]);\n
            }\n
        }\n
        return handled;\n
    },\n
    \n
    /**\n
     * Method: triggerCallback\n
     * Call the callback keyed in the event map with the supplied arguments.\n
     *     For click and clickout, the <clickTolerance> is checked first.\n
     *\n
     * Parameters:\n
     * type - {String}\n
     */\n
    triggerCallback: function(type, mode, args) {\n
        var key = this.EVENTMAP[type][mode];\n
        if(key) {\n
            if(type == \'click\' && this.up && this.down) {\n
                // for click/clickout, only trigger callback if tolerance is met\n
                var dpx = Math.sqrt(\n
                    Math.pow(this.up.x - this.down.x, 2) +\n
                    Math.pow(this.up.y - this.down.y, 2)\n
                );\n
                if(dpx <= this.clickTolerance) {\n
                    this.callback(key, args);\n
                }\n
            } else {\n
                this.callback(key, args);\n
            }\n
        }\n
    },\n
\n
    /**\n
     * Method: activate \n
     * Turn on the handler.  Returns false if the handler was already active.\n
     *\n
     * Returns:\n
     * {Boolean}\n
     */\n
    activate: function() {\n
        var activated = false;\n
        if(OpenLayers.Handler.prototype.activate.apply(this, arguments)) {\n
            this.moveLayerToTop();\n
            this.map.events.on({\n
                "removelayer": this.handleMapEvents,\n
                "changelayer": this.handleMapEvents,\n
                scope: this\n
            });\n
            activated = true;\n
        }\n
        return activated;\n
    },\n
    \n
    /**\n
     * Method: deactivate \n
     * Turn off the handler.  Returns false if the handler was already active.\n
     *\n
     * Returns: \n
     * {Boolean}\n
     */\n
    deactivate: function() {\n
        var deactivated = false;\n
        if(OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {\n
            this.moveLayerBack();\n
            this.feature = null;\n
            this.lastFeature = null;\n
            this.down = null;\n
            this.up = null;\n
            this.touch = false;\n
            this.map.events.un({\n
                "removelayer": this.handleMapEvents,\n
                "changelayer": this.handleMapEvents,\n
                scope: this\n
            });\n
            deactivated = true;\n
        }\n
        return deactivated;\n
    },\n
    \n
    /**\n
     * Method: handleMapEvents\n
     * \n
     * Parameters:\n
     * evt - {Object}\n
     */\n
    handleMapEvents: function(evt) {\n
        if (evt.type == "removelayer" || evt.property == "order") {\n
            this.moveLayerToTop();\n
        }\n
    },\n
    \n
    /**\n
     * Method: moveLayerToTop\n
     * Moves the layer for this handler to the top, so mouse events can reach\n
     * it.\n
     */\n
    moveLayerToTop: function() {\n
        var index = Math.max(this.map.Z_INDEX_BASE[\'Feature\'] - 1,\n
            this.layer.getZIndex()) + 1;\n
        this.layer.setZIndex(index);\n
        \n
    },\n
    \n
    /**\n
     * Method: moveLayerBack\n
     * Moves the layer back to the position determined by the map\'s layers\n
     * array.\n
     */\n
    moveLayerBack: function() {\n
        var index = this.layer.getZIndex() - 1;\n
        if (index >= this.map.Z_INDEX_BASE[\'Feature\']) {\n
            this.layer.setZIndex(index);\n
        } else {\n
            this.map.setLayerZIndex(this.layer,\n
                this.map.getLayerIndex(this.layer));\n
        }\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Handler.Feature"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>14095</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
