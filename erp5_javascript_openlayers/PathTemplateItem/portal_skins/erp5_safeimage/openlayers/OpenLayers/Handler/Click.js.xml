<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.88</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Click.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Handler.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Handler.Click\n
 * A handler for mouse clicks.  The intention of this handler is to give\n
 *     controls more flexibility with handling clicks.  Browsers trigger\n
 *     click events twice for a double-click.  In addition, the mousedown,\n
 *     mousemove, mouseup sequence fires a click event.  With this handler,\n
 *     controls can decide whether to ignore clicks associated with a double\n
 *     click.  By setting a <pixelTolerance>, controls can also ignore clicks\n
 *     that include a drag.  Create a new instance with the\n
 *     <OpenLayers.Handler.Click> constructor.\n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Handler> \n
 */\n
OpenLayers.Handler.Click = OpenLayers.Class(OpenLayers.Handler, {\n
    /**\n
     * APIProperty: delay\n
     * {Number} Number of milliseconds between clicks before the event is\n
     *     considered a double-click.\n
     */\n
    delay: 300,\n
    \n
    /**\n
     * APIProperty: single\n
     * {Boolean} Handle single clicks.  Default is true.  If false, clicks\n
     * will not be reported.  If true, single-clicks will be reported.\n
     */\n
    single: true,\n
    \n
    /**\n
     * APIProperty: double\n
     * {Boolean} Handle double-clicks.  Default is false.\n
     */\n
    \'double\': false,\n
    \n
    /**\n
     * APIProperty: pixelTolerance\n
     * {Number} Maximum number of pixels between mouseup and mousedown for an\n
     *     event to be considered a click.  Default is 0.  If set to an\n
     *     integer value, clicks with a drag greater than the value will be\n
     *     ignored.  This property can only be set when the handler is\n
     *     constructed.\n
     */\n
    pixelTolerance: 0,\n
        \n
    /**\n
     * APIProperty: dblclickTolerance\n
     * {Number} Maximum distance in pixels between clicks for a sequence of \n
     *     events to be considered a double click.  Default is 13.  If the\n
     *     distance between two clicks is greater than this value, a double-\n
     *     click will not be fired.\n
     */\n
    dblclickTolerance: 13,\n
        \n
    /**\n
     * APIProperty: stopSingle\n
     * {Boolean} Stop other listeners from being notified of clicks.  Default\n
     *     is false.  If true, any listeners registered before this one for \n
     *     click or rightclick events will not be notified.\n
     */\n
    stopSingle: false,\n
    \n
    /**\n
     * APIProperty: stopDouble\n
     * {Boolean} Stop other listeners from being notified of double-clicks.\n
     *     Default is false.  If true, any click listeners registered before\n
     *     this one will not be notified of *any* double-click events.\n
     * \n
     * The one caveat with stopDouble is that given a map with two click\n
     *     handlers, one with stopDouble true and the other with stopSingle\n
     *     true, the stopSingle handler should be activated last to get\n
     *     uniform cross-browser performance.  Since IE triggers one click\n
     *     with a dblclick and FF triggers two, if a stopSingle handler is\n
     *     activated first, all it gets in IE is a single click when the\n
     *     second handler stops propagation on the dblclick.\n
     */\n
    stopDouble: false,\n
\n
    /**\n
     * Property: timerId\n
     * {Number} The id of the timeout waiting to clear the <delayedCall>.\n
     */\n
    timerId: null,\n
\n
    /**\n
     * Property: touch\n
     * {Boolean} When a touchstart event is fired, touch will be true and all\n
     *     mouse related listeners will do nothing.\n
     */\n
    touch: false,\n
    \n
    /**\n
     * Property: down\n
     * {Object} Object that store relevant information about the last\n
     *     mousedown or touchstart. Its \'xy\' OpenLayers.Pixel property gives\n
     *     the average location of the mouse/touch event. Its \'touches\'\n
     *     property records clientX/clientY of each touches.\n
     */\n
    down: null,\n
\n
    /**\n
     * Property: last\n
     * {Object} Object that store relevant information about the last\n
     *     mousemove or touchmove. Its \'xy\' OpenLayers.Pixel property gives\n
     *     the average location of the mouse/touch event. Its \'touches\'\n
     *     property records clientX/clientY of each touches.\n
     */\n
    last: null,\n
\n
    /** \n
     * Property: first\n
     * {Object} When waiting for double clicks, this object will store \n
     *     information about the first click in a two click sequence.\n
     */\n
    first: null,\n
\n
    /**\n
     * Property: rightclickTimerId\n
     * {Number} The id of the right mouse timeout waiting to clear the \n
     *     <delayedEvent>.\n
     */\n
    rightclickTimerId: null,\n
    \n
    /**\n
     * Constructor: OpenLayers.Handler.Click\n
     * Create a new click handler.\n
     * \n
     * Parameters:\n
     * control - {<OpenLayers.Control>} The control that is making use of\n
     *     this handler.  If a handler is being used without a control, the\n
     *     handler\'s setMap method must be overridden to deal properly with\n
     *     the map.\n
     * callbacks - {Object} An object with keys corresponding to callbacks\n
     *     that will be called by the handler. The callbacks should\n
     *     expect to recieve a single argument, the click event.\n
     *     Callbacks for \'click\' and \'dblclick\' are supported.\n
     * options - {Object} Optional object whose properties will be set on the\n
     *     handler.\n
     */\n
    \n
    /**\n
     * Method: touchstart\n
     * Handle touchstart.\n
     *\n
     * Returns:\n
     * {Boolean} Continue propagating this event.\n
     */\n
    touchstart: function(evt) {\n
        if (!this.touch) {\n
            this.unregisterMouseListeners();\n
            this.touch = true;\n
        }\n
        this.down = this.getEventInfo(evt);\n
        this.last = this.getEventInfo(evt);\n
        return true;\n
    },\n
    \n
    /**\n
     * Method: touchmove\n
     *    Store position of last move, because touchend event can have\n
     *    an empty "touches" property.\n
     *\n
     * Returns:\n
     * {Boolean} Continue propagating this event.\n
     */\n
    touchmove: function(evt) {\n
        this.last = this.getEventInfo(evt);\n
        return true;\n
    },\n
\n
    /**\n
     * Method: touchend\n
     *   Correctly set event xy property, and add lastTouches to have\n
     *   touches property from last touchstart or touchmove\n
     *\n
     * Returns:\n
     * {Boolean} Continue propagating this event.\n
     */\n
    touchend: function(evt) {\n
        // touchstart may not have been allowed to propagate\n
        if (this.down) {\n
            evt.xy = this.last.xy;\n
            evt.lastTouches = this.last.touches;\n
            this.handleSingle(evt);\n
            this.down = null;\n
        }\n
        return true;\n
    },\n
    \n
    /**\n
     * Method: unregisterMouseListeners\n
     * In a touch environment, we don\'t want to handle mouse events.\n
     */\n
    unregisterMouseListeners: function() {\n
        this.map.events.un({\n
            mousedown: this.mousedown,\n
            mouseup: this.mouseup,\n
            click: this.click,\n
            dblclick: this.dblclick,\n
            scope: this\n
        });\n
    },\n
\n
    /**\n
     * Method: mousedown\n
     * Handle mousedown.\n
     *\n
     * Returns:\n
     * {Boolean} Continue propagating this event.\n
     */\n
    mousedown: function(evt) {\n
        this.down = this.getEventInfo(evt);\n
        this.last = this.getEventInfo(evt);\n
        return true;\n
    },\n
\n
    /**\n
     * Method: mouseup\n
     * Handle mouseup.  Installed to support collection of right mouse events.\n
     * \n
     * Returns:\n
     * {Boolean} Continue propagating this event.\n
     */\n
    mouseup: function (evt) {\n
        var propagate = true;\n
\n
        // Collect right mouse clicks from the mouseup\n
        //  IE - ignores the second right click in mousedown so using\n
        //  mouseup instead\n
        if (this.checkModifiers(evt) && this.control.handleRightClicks &&\n
           OpenLayers.Event.isRightClick(evt)) {\n
            propagate = this.rightclick(evt);\n
        }\n
\n
        return propagate;\n
    },\n
    \n
    /**\n
     * Method: rightclick\n
     * Handle rightclick.  For a dblrightclick, we get two clicks so we need \n
     *     to always register for dblrightclick to properly handle single \n
     *     clicks.\n
     *     \n
     * Returns:\n
     * {Boolean} Continue propagating this event.\n
     */\n
    rightclick: function(evt) {\n
        if(this.passesTolerance(evt)) {\n
           if(this.rightclickTimerId != null) {\n
                //Second click received before timeout this must be \n
                // a double click\n
                this.clearTimer();\n
                this.callback(\'dblrightclick\', [evt]);\n
                return !this.stopDouble;\n
            } else { \n
                //Set the rightclickTimerId, send evt only if double is \n
                // true else trigger single\n
                var clickEvent = this[\'double\'] ?\n
                    OpenLayers.Util.extend({}, evt) : \n
                    this.callback(\'rightclick\', [evt]);\n
\n
                var delayedRightCall = OpenLayers.Function.bind(\n
                    this.delayedRightCall, \n
                    this, \n
                    clickEvent\n
                );\n
                this.rightclickTimerId = window.setTimeout(\n
                    delayedRightCall, this.delay\n
                );\n
            } \n
        }\n
        return !this.stopSingle;\n
    },\n
    \n
    /**\n
     * Method: delayedRightCall\n
     * Sets <rightclickTimerId> to null.  And optionally triggers the \n
     *     rightclick callback if evt is set.\n
     */\n
    delayedRightCall: function(evt) {\n
        this.rightclickTimerId = null;\n
        if (evt) {\n
           this.callback(\'rightclick\', [evt]);\n
        }\n
    },\n
    \n
    /**\n
     * Method: click\n
     * Handle click events from the browser.  This is registered as a listener\n
     *     for click events and should not be called from other events in this\n
     *     handler.\n
     *\n
     * Returns:\n
     * {Boolean} Continue propagating this event.\n
     */\n
    click: function(evt) {\n
        if (!this.last) {\n
            this.last = this.getEventInfo(evt);\n
        }\n
        this.handleSingle(evt);\n
        return !this.stopSingle;\n
    },\n
\n
    /**\n
     * Method: dblclick\n
     * Handle dblclick.  For a dblclick, we get two clicks in some browsers\n
     *     (FF) and one in others (IE).  So we need to always register for\n
     *     dblclick to properly handle single clicks.  This method is registered\n
     *     as a listener for the dblclick browser event.  It should *not* be\n
     *     called by other methods in this handler.\n
     *     \n
     * Returns:\n
     * {Boolean} Continue propagating this event.\n
     */\n
    dblclick: function(evt) {\n
        this.handleDouble(evt);\n
        return !this.stopDouble;\n
    },\n
    \n
    /** \n
     * Method: handleDouble\n
     * Handle double-click sequence.\n
     */\n
    handleDouble: function(evt) {\n
        if (this.passesDblclickTolerance(evt)) {\n
            if (this["double"]) {\n
                this.callback("dblclick", [evt]);\n
            }\n
            // to prevent a dblclick from firing the click callback in IE\n
            this.clearTimer();\n
        }\n
    },\n
    \n
    /** \n
     * Method: handleSingle\n
     * Handle single click sequence.\n
     */\n
    handleSingle: function(evt) {\n
        if (this.passesTolerance(evt)) {\n
            if (this.timerId != null) {\n
                // already received a click\n
                if (this.last.touches && this.last.touches.length === 1) {\n
                    // touch device, no dblclick event - this may be a double\n
                    if (this["double"]) {\n
                        // on Android don\'t let the browser zoom on the page\n
                        OpenLayers.Event.stop(evt);\n
                    }\n
                    this.handleDouble(evt);\n
                }\n
                // if we\'re not in a touch environment we clear the click timer\n
                // if we\'ve got a second touch, we\'ll get two touchend events\n
                if (!this.last.touches || this.last.touches.length !== 2) {\n
                    this.clearTimer();\n
                }\n
            } else {\n
                // remember the first click info so we can compare to the second\n
                this.first = this.getEventInfo(evt);\n
                // set the timer, send evt only if single is true\n
                //use a clone of the event object because it will no longer \n
                //be a valid event object in IE in the timer callback\n
                var clickEvent = this.single ?\n
                    OpenLayers.Util.extend({}, evt) : null;\n
                this.queuePotentialClick(clickEvent);\n
            }\n
        }\n
    },\n
    \n
    /** \n
     * Method: queuePotentialClick\n
     * This method is separated out largely to make testing easier (so we\n
     *     don\'t have to override window.setTimeout)\n
     */\n
    queuePotentialClick: function(evt) {\n
        this.timerId = window.setTimeout(\n
            OpenLayers.Function.bind(this.delayedCall, this, evt),\n
            this.delay\n
        );\n
    },\n
\n
    /**\n
     * Method: passesTolerance\n
     * Determine whether the event is within the optional pixel tolerance.  Note\n
     *     that the pixel tolerance check only works if mousedown events get to\n
     *     the listeners registered here.  If they are stopped by other elements,\n
     *     the <pixelTolerance> will have no effect here (this method will always\n
     *     return true).\n
     *\n
     * Returns:\n
     * {Boolean} The click is within the pixel tolerance (if specified).\n
     */\n
    passesTolerance: function(evt) {\n
        var passes = true;\n
        if (this.pixelTolerance != null && this.down && this.down.xy) {\n
            passes = this.pixelTolerance >= this.down.xy.distanceTo(evt.xy);\n
            // for touch environments, we also enforce that all touches\n
            // start and end within the given tolerance to be considered a click\n
            if (passes && this.touch && \n
                this.down.touches.length === this.last.touches.length) {\n
                // the touchend event doesn\'t come with touches, so we check\n
                // down and last\n
                for (var i=0, ii=this.down.touches.length; i<ii; ++i) {\n
                    if (this.getTouchDistance(\n
                            this.down.touches[i], \n
                            this.last.touches[i]\n
                        ) > this.pixelTolerance) {\n
                        passes = false;\n
                        break;\n
                    }\n
                }\n
            }\n
        }\n
        return passes;\n
    },\n
    \n
    /** \n
     * Method: getTouchDistance\n
     *\n
     * Returns:\n
     * {Boolean} The pixel displacement between two touches.\n
     */\n
    getTouchDistance: function(from, to) {\n
        return Math.sqrt(\n
            Math.pow(from.clientX - to.clientX, 2) +\n
            Math.pow(from.clientY - to.clientY, 2)\n
        );\n
    },\n
    \n
    /**\n
     * Method: passesDblclickTolerance\n
     * Determine whether the event is within the optional double-cick pixel \n
     *     tolerance.\n
     *\n
     * Returns:\n
     * {Boolean} The click is within the double-click pixel tolerance.\n
     */\n
    passesDblclickTolerance: function(evt) {\n
        var passes = true;\n
        if (this.down && this.first) {\n
            passes = this.down.xy.distanceTo(this.first.xy) <= this.dblclickTolerance;\n
        }\n
        return passes;\n
    },\n
\n
    /**\n
     * Method: clearTimer\n
     * Clear the timer and set <timerId> to null.\n
     */\n
    clearTimer: function() {\n
        if (this.timerId != null) {\n
            window.clearTimeout(this.timerId);\n
            this.timerId = null;\n
        }\n
        if (this.rightclickTimerId != null) {\n
            window.clearTimeout(this.rightclickTimerId);\n
            this.rightclickTimerId = null;\n
        }\n
    },\n
    \n
    /**\n
     * Method: delayedCall\n
     * Sets <timerId> to null.  And optionally triggers the click callback if\n
     *     evt is set.\n
     */\n
    delayedCall: function(evt) {\n
        this.timerId = null;\n
        if (evt) {\n
            this.callback("click", [evt]);\n
        }\n
    },\n
\n
    /**\n
     * Method: getEventInfo\n
     * This method allows us to store event information without storing the\n
     *     actual event.  In touch devices (at least), the same event is \n
     *     modified between touchstart, touchmove, and touchend.\n
     *\n
     * Returns:\n
     * {Object} An object with event related info.\n
     */\n
    getEventInfo: function(evt) {\n
        var touches;\n
        if (evt.touches) {\n
            var len = evt.touches.length;\n
            touches = new Array(len);\n
            var touch;\n
            for (var i=0; i<len; i++) {\n
                touch = evt.touches[i];\n
                touches[i] = {\n
                    clientX: touch.clientX,\n
                    clientY: touch.clientY\n
                };\n
            }\n
        }\n
        return {\n
            xy: evt.xy,\n
            touches: touches\n
        };\n
    },\n
\n
    /**\n
     * APIMethod: deactivate\n
     * Deactivate the handler.\n
     *\n
     * Returns:\n
     * {Boolean} The handler was successfully deactivated.\n
     */\n
    deactivate: function() {\n
        var deactivated = false;\n
        if(OpenLayers.Handler.prototype.deactivate.apply(this, arguments)) {\n
            this.clearTimer();\n
            this.down = null;\n
            this.first = null;\n
            this.last = null;\n
            this.touch = false;\n
            deactivated = true;\n
        }\n
        return deactivated;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Handler.Click"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>17540</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
