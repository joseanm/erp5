<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.89</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Polygon.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/Handler/Path.js\n
 * @requires OpenLayers/Geometry/Polygon.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Handler.Polygon\n
 * Handler to draw a polygon on the map.  Polygon is displayed on mouse down,\n
 * moves on mouse move, and is finished on mouse up.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Handler.Path>\n
 *  - <OpenLayers.Handler>\n
 */\n
OpenLayers.Handler.Polygon = OpenLayers.Class(OpenLayers.Handler.Path, {\n
    \n
    /** \n
     * APIProperty: holeModifier\n
     * {String} Key modifier to trigger hole digitizing.  Acceptable values are\n
     *     "altKey", "shiftKey", or "ctrlKey".  If not set, no hole digitizing\n
     *     will take place.  Default is null.\n
     */\n
    holeModifier: null,\n
    \n
    /**\n
     * Property: drawingHole\n
     * {Boolean} Currently drawing an interior ring.\n
     */\n
    drawingHole: false,\n
    \n
    /**\n
     * Property: polygon\n
     * {<OpenLayers.Feature.Vector>}\n
     */\n
    polygon: null,\n
\n
    /**\n
     * Constructor: OpenLayers.Handler.Polygon\n
     * Create a Polygon Handler.\n
     *\n
     * Parameters:\n
     * control - {<OpenLayers.Control>} The control that owns this handler\n
     * callbacks - {Object} An object with a properties whose values are\n
     *     functions.  Various callbacks described below.\n
     * options - {Object} An optional object with properties to be set on the\n
     *           handler\n
     *\n
     * Named callbacks:\n
     * create - Called when a sketch is first created.  Callback called with\n
     *     the creation point geometry and sketch feature.\n
     * modify - Called with each move of a vertex with the vertex (point)\n
     *     geometry and the sketch feature.\n
     * point - Called as each point is added.  Receives the new point geometry.\n
     * done - Called when the point drawing is finished.  The callback will\n
     *     recieve a single argument, the polygon geometry.\n
     * cancel - Called when the handler is deactivated while drawing.  The\n
     *     cancel callback will receive a geometry.\n
     */\n
    \n
    /**\n
     * Method: createFeature\n
     * Add temporary geometries\n
     *\n
     * Parameters:\n
     * pixel - {<OpenLayers.Pixel>} The initial pixel location for the new\n
     *     feature.\n
     */\n
    createFeature: function(pixel) {\n
        var lonlat = this.layer.getLonLatFromViewPortPx(pixel);\n
        var geometry = new OpenLayers.Geometry.Point(\n
            lonlat.lon, lonlat.lat\n
        );\n
        this.point = new OpenLayers.Feature.Vector(geometry);\n
        this.line = new OpenLayers.Feature.Vector(\n
            new OpenLayers.Geometry.LinearRing([this.point.geometry])\n
        );\n
        this.polygon = new OpenLayers.Feature.Vector(\n
            new OpenLayers.Geometry.Polygon([this.line.geometry])\n
        );\n
        this.callback("create", [this.point.geometry, this.getSketch()]);\n
        this.point.geometry.clearBounds();\n
        this.layer.addFeatures([this.polygon, this.point], {silent: true});\n
    },\n
\n
    /**\n
     * Method: addPoint\n
     * Add point to geometry.\n
     *\n
     * Parameters:\n
     * pixel - {<OpenLayers.Pixel>} The pixel location for the new point.\n
     */\n
    addPoint: function(pixel) {\n
        if(!this.drawingHole && this.holeModifier &&\n
           this.evt && this.evt[this.holeModifier]) {\n
            var geometry = this.point.geometry;\n
            var features = this.control.layer.features;\n
            var candidate, polygon;\n
            // look for intersections, last drawn gets priority\n
            for (var i=features.length-1; i>=0; --i) {\n
                candidate = features[i].geometry;\n
                if ((candidate instanceof OpenLayers.Geometry.Polygon || \n
                    candidate instanceof OpenLayers.Geometry.MultiPolygon) && \n
                    candidate.intersects(geometry)) {\n
                    polygon = features[i];\n
                    this.control.layer.removeFeatures([polygon], {silent: true});\n
                    this.control.layer.events.registerPriority(\n
                        "sketchcomplete", this, this.finalizeInteriorRing\n
                    );\n
                    this.control.layer.events.registerPriority(\n
                        "sketchmodified", this, this.enforceTopology\n
                    );\n
                    polygon.geometry.addComponent(this.line.geometry);\n
                    this.polygon = polygon;\n
                    this.drawingHole = true;\n
                    break;\n
                }\n
            }\n
        }\n
        OpenLayers.Handler.Path.prototype.addPoint.apply(this, arguments);\n
    },\n
\n
    /**\n
     * Method: getCurrentPointIndex\n
     * \n
     * Returns:\n
     * {Number} The index of the most recently drawn point.\n
     */\n
    getCurrentPointIndex: function() {\n
        return this.line.geometry.components.length - 2;\n
    },\n
\n
    /**\n
     * Method: enforceTopology\n
     * Simple topology enforcement for drawing interior rings.  Ensures vertices\n
     *     of interior rings are contained by exterior ring.  Other topology \n
     *     rules are enforced in <finalizeInteriorRing> to allow drawing of \n
     *     rings that intersect only during the sketch (e.g. a "C" shaped ring\n
     *     that nearly encloses another ring).\n
     */\n
    enforceTopology: function(event) {\n
        var point = event.vertex;\n
        var components = this.line.geometry.components;\n
        // ensure that vertices of interior ring are contained by exterior ring\n
        if (!this.polygon.geometry.intersects(point)) {\n
            var last = components[components.length-3];\n
            point.x = last.x;\n
            point.y = last.y;\n
        }\n
    },\n
\n
    /**\n
     * Method: finishGeometry\n
     * Finish the geometry and send it back to the control.\n
     */\n
    finishGeometry: function() {\n
        var index = this.line.geometry.components.length - 2;\n
        this.line.geometry.removeComponent(this.line.geometry.components[index]);\n
        this.removePoint();\n
        this.finalize();\n
    },\n
\n
    /**\n
     * Method: finalizeInteriorRing\n
     * Enforces that new ring has some area and doesn\'t contain vertices of any\n
     *     other rings.\n
     */\n
    finalizeInteriorRing: function() {\n
        var ring = this.line.geometry;\n
        // ensure that ring has some area\n
        var modified = (ring.getArea() !== 0);\n
        if (modified) {\n
            // ensure that new ring doesn\'t intersect any other rings\n
            var rings = this.polygon.geometry.components;\n
            for (var i=rings.length-2; i>=0; --i) {\n
                if (ring.intersects(rings[i])) {\n
                    modified = false;\n
                    break;\n
                }\n
            }\n
            if (modified) {\n
                // ensure that new ring doesn\'t contain any other rings\n
                var target;\n
                outer: for (var i=rings.length-2; i>0; --i) {\n
                    var points = rings[i].components;\n
                    for (var j=0, jj=points.length; j<jj; ++j) {\n
                        if (ring.containsPoint(points[j])) {\n
                            modified = false;\n
                            break outer;\n
                        }\n
                    }\n
                }\n
            }\n
        }\n
        if (modified) {\n
            if (this.polygon.state !== OpenLayers.State.INSERT) {\n
                this.polygon.state = OpenLayers.State.UPDATE;\n
            }\n
        } else {\n
            this.polygon.geometry.removeComponent(ring);\n
        }\n
        this.restoreFeature();\n
        return false;\n
    },\n
\n
    /**\n
     * APIMethod: cancel\n
     * Finish the geometry and call the "cancel" callback.\n
     */\n
    cancel: function() {\n
        if (this.drawingHole) {\n
            this.polygon.geometry.removeComponent(this.line.geometry);\n
            this.restoreFeature(true);\n
        }\n
        return OpenLayers.Handler.Path.prototype.cancel.apply(this, arguments);\n
    },\n
    \n
    /**\n
     * Method: restoreFeature\n
     * Move the feature from the sketch layer to the target layer.\n
     *\n
     * Properties: \n
     * cancel - {Boolean} Cancel drawing.  If falsey, the "sketchcomplete" event\n
     *     will be fired.\n
     */\n
    restoreFeature: function(cancel) {\n
        this.control.layer.events.unregister(\n
            "sketchcomplete", this, this.finalizeInteriorRing\n
        );\n
        this.control.layer.events.unregister(\n
            "sketchmodified", this, this.enforceTopology\n
        );\n
        this.layer.removeFeatures([this.polygon], {silent: true});\n
        this.control.layer.addFeatures([this.polygon], {silent: true});\n
        this.drawingHole = false;\n
        if (!cancel) {\n
            // Re-trigger "sketchcomplete" so other listeners can do their\n
            // business.  While this is somewhat sloppy (if a listener is \n
            // registered with registerPriority - not common - between the start\n
            // and end of a single ring drawing - very uncommon - it will be \n
            // called twice).\n
            // TODO: In 3.0, collapse sketch handlers into geometry specific\n
            // drawing controls.\n
            this.control.layer.events.triggerEvent(\n
                "sketchcomplete", {feature : this.polygon}\n
            );\n
        }\n
    },\n
\n
    /**\n
     * Method: destroyFeature\n
     * Destroy temporary geometries\n
     *\n
     * Parameters:\n
     * force - {Boolean} Destroy even if persist is true.\n
     */\n
    destroyFeature: function(force) {\n
        OpenLayers.Handler.Path.prototype.destroyFeature.call(\n
            this, force);\n
        this.polygon = null;\n
    },\n
\n
    /**\n
     * Method: drawFeature\n
     * Render geometries on the temporary layer.\n
     */\n
    drawFeature: function() {\n
        this.layer.drawFeature(this.polygon, this.style);\n
        this.layer.drawFeature(this.point, this.style);\n
    },\n
    \n
    /**\n
     * Method: getSketch\n
     * Return the sketch feature.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Feature.Vector>}\n
     */\n
    getSketch: function() {\n
        return this.polygon;\n
    },\n
\n
    /**\n
     * Method: getGeometry\n
     * Return the sketch geometry.  If <multi> is true, this will return\n
     *     a multi-part geometry.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Geometry.Polygon>}\n
     */\n
    getGeometry: function() {\n
        var geometry = this.polygon && this.polygon.geometry;\n
        if(geometry && this.multi) {\n
            geometry = new OpenLayers.Geometry.MultiPolygon([geometry]);\n
        }\n
        return geometry;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Handler.Polygon"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>10643</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
