<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.89</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Path.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/Handler/Point.js\n
 * @requires OpenLayers/Geometry/Point.js\n
 * @requires OpenLayers/Geometry/LineString.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Handler.Path\n
 * Handler to draw a path on the map.  Path is displayed on mouse down,\n
 * moves on mouse move, and is finished on mouse up.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Handler.Point>\n
 */\n
OpenLayers.Handler.Path = OpenLayers.Class(OpenLayers.Handler.Point, {\n
    \n
    /**\n
     * Property: line\n
     * {<OpenLayers.Feature.Vector>}\n
     */\n
    line: null,\n
\n
    /**\n
     * APIProperty: maxVertices\n
     * {Number} The maximum number of vertices which can be drawn by this\n
     * handler. When the number of vertices reaches maxVertices, the\n
     * geometry is automatically finalized. Default is null.\n
     */\n
    maxVertices: null,\n
\n
    /**\n
     * Property: doubleTouchTolerance\n
     * {Number} Maximum number of pixels between two touches for\n
     *     the gesture to be considered a "finalize feature" action.\n
     *     Default is 20.\n
     */\n
    doubleTouchTolerance: 20,\n
\n
    /**\n
     * Property: freehand\n
     * {Boolean} In freehand mode, the handler starts the path on mouse down,\n
     * adds a point for every mouse move, and finishes the path on mouse up.\n
     * Outside of freehand mode, a point is added to the path on every mouse\n
     * click and double-click finishes the path.\n
     */\n
    freehand: false,\n
    \n
    /**\n
     * Property: freehandToggle\n
     * {String} If set, freehandToggle is checked on mouse events and will set\n
     * the freehand mode to the opposite of this.freehand.  To disallow\n
     * toggling between freehand and non-freehand mode, set freehandToggle to\n
     * null.  Acceptable toggle values are \'shiftKey\', \'ctrlKey\', and \'altKey\'.\n
     */\n
    freehandToggle: \'shiftKey\',\n
\n
    /**\n
     * Property: timerId\n
     * {Integer} The timer used to test the double touch.\n
     */\n
    timerId: null,\n
\n
    /**\n
     * Property: redoStack\n
     * {Array} Stack containing points removed with <undo>.\n
     */\n
    redoStack: null,\n
\n
    /**\n
     * Constructor: OpenLayers.Handler.Path\n
     * Create a new path hander\n
     *\n
     * Parameters:\n
     * control - {<OpenLayers.Control>} The control that owns this handler\n
     * callbacks - {Object} An object with a properties whose values are\n
     *     functions.  Various callbacks described below.\n
     * options - {Object} An optional object with properties to be set on the\n
     *           handler\n
     *\n
     * Named callbacks:\n
     * create - Called when a sketch is first created.  Callback called with\n
     *     the creation point geometry and sketch feature.\n
     * modify - Called with each move of a vertex with the vertex (point)\n
     *     geometry and the sketch feature.\n
     * point - Called as each point is added.  Receives the new point geometry.\n
     * done - Called when the point drawing is finished.  The callback will\n
     *     recieve a single argument, the linestring geometry.\n
     * cancel - Called when the handler is deactivated while drawing.  The\n
     *     cancel callback will receive a geometry.\n
     */\n
\n
    /**\n
     * Method: createFeature\n
     * Add temporary geometries\n
     *\n
     * Parameters:\n
     * pixel - {<OpenLayers.Pixel>} The initial pixel location for the new\n
     *     feature.\n
     */\n
    createFeature: function(pixel) {\n
        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); \n
        var geometry = new OpenLayers.Geometry.Point(\n
            lonlat.lon, lonlat.lat\n
        );\n
        this.point = new OpenLayers.Feature.Vector(geometry);\n
        this.line = new OpenLayers.Feature.Vector(\n
            new OpenLayers.Geometry.LineString([this.point.geometry])\n
        );\n
        this.callback("create", [this.point.geometry, this.getSketch()]);\n
        this.point.geometry.clearBounds();\n
        this.layer.addFeatures([this.line, this.point], {silent: true});\n
    },\n
        \n
    /**\n
     * Method: destroyFeature\n
     * Destroy temporary geometries\n
     *\n
     * Parameters:\n
     * force - {Boolean} Destroy even if persist is true.\n
     */\n
    destroyFeature: function(force) {\n
        OpenLayers.Handler.Point.prototype.destroyFeature.call(\n
            this, force);\n
        this.line = null;\n
    },\n
\n
    /**\n
     * Method: destroyPersistedFeature\n
     * Destroy the persisted feature.\n
     */\n
    destroyPersistedFeature: function() {\n
        var layer = this.layer;\n
        if(layer && layer.features.length > 2) {\n
            this.layer.features[0].destroy();\n
        }\n
    },\n
\n
    /**\n
     * Method: removePoint\n
     * Destroy the temporary point.\n
     */\n
    removePoint: function() {\n
        if(this.point) {\n
            this.layer.removeFeatures([this.point]);\n
        }\n
    },\n
    \n
    /**\n
     * Method: addPoint\n
     * Add point to geometry.  Send the point index to override\n
     * the behavior of LinearRing that disregards adding duplicate points.\n
     *\n
     * Parameters:\n
     * pixel - {<OpenLayers.Pixel>} The pixel location for the new point.\n
     */\n
    addPoint: function(pixel) {\n
        this.layer.removeFeatures([this.point]);\n
        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); \n
        this.point = new OpenLayers.Feature.Vector(\n
            new OpenLayers.Geometry.Point(lonlat.lon, lonlat.lat)\n
        );\n
        this.line.geometry.addComponent(\n
            this.point.geometry, this.line.geometry.components.length\n
        );\n
        this.layer.addFeatures([this.point]);\n
        this.callback("point", [this.point.geometry, this.getGeometry()]);\n
        this.callback("modify", [this.point.geometry, this.getSketch()]);\n
        this.drawFeature();\n
        delete this.redoStack;\n
    },\n
    \n
    /**\n
     * Method: insertXY\n
     * Insert a point in the current sketch given x & y coordinates.  The new\n
     *     point is inserted immediately before the most recently drawn point.\n
     *\n
     * Parameters:\n
     * x - {Number} The x-coordinate of the point.\n
     * y - {Number} The y-coordinate of the point.\n
     */\n
    insertXY: function(x, y) {\n
        this.line.geometry.addComponent(\n
            new OpenLayers.Geometry.Point(x, y), \n
            this.getCurrentPointIndex()\n
        );\n
        this.drawFeature();\n
        delete this.redoStack;\n
    },\n
\n
    /**\n
     * Method: insertDeltaXY\n
     * Insert a point given offsets from the previously inserted point.\n
     *\n
     * Parameters:\n
     * dx - {Number} The x-coordinate offset of the point.\n
     * dy - {Number} The y-coordinate offset of the point.\n
     */\n
    insertDeltaXY: function(dx, dy) {\n
        var previousIndex = this.getCurrentPointIndex() - 1;\n
        var p0 = this.line.geometry.components[previousIndex];\n
        if (p0 && !isNaN(p0.x) && !isNaN(p0.y)) {\n
            this.insertXY(p0.x + dx, p0.y + dy);\n
        }\n
    },\n
\n
    /**\n
     * Method: insertDirectionLength\n
     * Insert a point in the current sketch given a direction and a length.\n
     *\n
     * Parameters:\n
     * direction - {Number} Degrees clockwise from the positive x-axis.\n
     * length - {Number} Distance from the previously drawn point.\n
     */\n
    insertDirectionLength: function(direction, length) {\n
        direction *= Math.PI / 180;\n
        var dx = length * Math.cos(direction);\n
        var dy = length * Math.sin(direction);\n
        this.insertDeltaXY(dx, dy);\n
    },\n
\n
    /**\n
     * Method: insertDeflectionLength\n
     * Insert a point in the current sketch given a deflection and a length.\n
     *     The deflection should be degrees clockwise from the previously \n
     *     digitized segment.\n
     *\n
     * Parameters:\n
     * deflection - {Number} Degrees clockwise from the previous segment.\n
     * length - {Number} Distance from the previously drawn point.\n
     */\n
    insertDeflectionLength: function(deflection, length) {\n
        var previousIndex = this.getCurrentPointIndex() - 1;\n
        if (previousIndex > 0) {\n
            var p1 = this.line.geometry.components[previousIndex];\n
            var p0 = this.line.geometry.components[previousIndex-1];\n
            var theta = Math.atan2(p1.y - p0.y, p1.x - p0.x);\n
            this.insertDirectionLength(\n
                (theta * 180 / Math.PI) + deflection, length\n
            );\n
        }\n
    },\n
\n
    /**\n
     * Method: getCurrentPointIndex\n
     * \n
     * Returns:\n
     * {Number} The index of the most recently drawn point.\n
     */\n
    getCurrentPointIndex: function() {\n
        return this.line.geometry.components.length - 1;\n
    },\n
    \n
    \n
    /**\n
     * Method: undo\n
     * Remove the most recently added point in the sketch geometry.\n
     *\n
     * Returns: \n
     * {Boolean} A point was removed.\n
     */\n
    undo: function() {\n
        var geometry = this.line.geometry;\n
        var components = geometry.components;\n
        var index = this.getCurrentPointIndex() - 1;\n
        var target = components[index];\n
        var undone = geometry.removeComponent(target);\n
        if (undone) {\n
            if (!this.redoStack) {\n
                this.redoStack = [];\n
            }\n
            this.redoStack.push(target);\n
            this.drawFeature();\n
        }\n
        return undone;\n
    },\n
    \n
    /**\n
     * Method: redo\n
     * Reinsert the most recently removed point resulting from an <undo> call.\n
     *     The undo stack is deleted whenever a point is added by other means.\n
     *\n
     * Returns: \n
     * {Boolean} A point was added.\n
     */\n
    redo: function() {\n
        var target = this.redoStack && this.redoStack.pop();\n
        if (target) {\n
            this.line.geometry.addComponent(target, this.getCurrentPointIndex());\n
            this.drawFeature();\n
        }\n
        return !!target;\n
    },\n
    \n
    /**\n
     * Method: freehandMode\n
     * Determine whether to behave in freehand mode or not.\n
     *\n
     * Returns:\n
     * {Boolean}\n
     */\n
    freehandMode: function(evt) {\n
        return (this.freehandToggle && evt[this.freehandToggle]) ?\n
                    !this.freehand : this.freehand;\n
    },\n
\n
    /**\n
     * Method: modifyFeature\n
     * Modify the existing geometry given the new point\n
     *\n
     * Parameters:\n
     * pixel - {<OpenLayers.Pixel>} The updated pixel location for the latest\n
     *     point.\n
     * drawing - {Boolean} Indicate if we\'re currently drawing.\n
     */\n
    modifyFeature: function(pixel, drawing) {\n
        if(!this.line) {\n
            this.createFeature(pixel);\n
        }\n
        var lonlat = this.layer.getLonLatFromViewPortPx(pixel); \n
        this.point.geometry.x = lonlat.lon;\n
        this.point.geometry.y = lonlat.lat;\n
        this.callback("modify", [this.point.geometry, this.getSketch(), drawing]);\n
        this.point.geometry.clearBounds();\n
        this.drawFeature();\n
    },\n
\n
    /**\n
     * Method: drawFeature\n
     * Render geometries on the temporary layer.\n
     */\n
    drawFeature: function() {\n
        this.layer.drawFeature(this.line, this.style);\n
        this.layer.drawFeature(this.point, this.style);\n
    },\n
\n
    /**\n
     * Method: getSketch\n
     * Return the sketch feature.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Feature.Vector>}\n
     */\n
    getSketch: function() {\n
        return this.line;\n
    },\n
\n
    /**\n
     * Method: getGeometry\n
     * Return the sketch geometry.  If <multi> is true, this will return\n
     *     a multi-part geometry.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Geometry.LineString>}\n
     */\n
    getGeometry: function() {\n
        var geometry = this.line && this.line.geometry;\n
        if(geometry && this.multi) {\n
            geometry = new OpenLayers.Geometry.MultiLineString([geometry]);\n
        }\n
        return geometry;\n
    },\n
\n
    /**\n
     * method: touchstart\n
     * handle touchstart.\n
     *\n
     * parameters:\n
     * evt - {event} the browser event\n
     *\n
     * returns:\n
     * {boolean} allow event propagation\n
     */\n
    touchstart: function(evt) {\n
        if (this.timerId &&\n
            this.passesTolerance(this.lastTouchPx, evt.xy,\n
                                 this.doubleTouchTolerance)) {\n
            // double-tap, finalize the geometry\n
            this.finishGeometry();\n
            window.clearTimeout(this.timerId);\n
            this.timerId = null;\n
            return false;\n
        } else {\n
            if (this.timerId) {\n
                window.clearTimeout(this.timerId);\n
                this.timerId = null;\n
            }\n
            this.timerId = window.setTimeout(\n
                OpenLayers.Function.bind(function() {\n
                    this.timerId = null;\n
                }, this), 300);\n
            return OpenLayers.Handler.Point.prototype.touchstart.call(this, evt);\n
        }\n
    },\n
\n
    /**\n
     * Method: down\n
     * Handle mousedown and touchstart.  Add a new point to the geometry and\n
     * render it. Return determines whether to propagate the event on the map.\n
     * \n
     * Parameters:\n
     * evt - {Event} The browser event\n
     *\n
     * Returns: \n
     * {Boolean} Allow event propagation\n
     */\n
    down: function(evt) {\n
        var stopDown = this.stopDown;\n
        if(this.freehandMode(evt)) {\n
            stopDown = true;\n
            if (this.touch) {\n
                this.modifyFeature(evt.xy, !!this.lastUp);\n
                OpenLayers.Event.stop(evt);\n
            }\n
        }\n
        if (!this.touch && (!this.lastDown ||\n
                            !this.passesTolerance(this.lastDown, evt.xy,\n
                                                  this.pixelTolerance))) {\n
            this.modifyFeature(evt.xy, !!this.lastUp);\n
        }\n
        this.mouseDown = true;\n
        this.lastDown = evt.xy;\n
        this.stoppedDown = stopDown;\n
        return !stopDown;\n
    },\n
\n
    /**\n
     * Method: move\n
     * Handle mousemove and touchmove.  Adjust the geometry and redraw.\n
     * Return determines whether to propagate the event on the map.\n
     * \n
     * Parameters:\n
     * evt - {Event} The browser event\n
     *\n
     * Returns: \n
     * {Boolean} Allow event propagation\n
     */\n
    move: function (evt) {\n
        if(this.stoppedDown && this.freehandMode(evt)) {\n
            if(this.persist) {\n
                this.destroyPersistedFeature();\n
            }\n
            if(this.maxVertices && this.line &&\n
                    this.line.geometry.components.length === this.maxVertices) {\n
                this.removePoint();\n
                this.finalize();\n
            } else {\n
                this.addPoint(evt.xy);\n
            }\n
            return false;\n
        }\n
        if (!this.touch && (!this.mouseDown || this.stoppedDown)) {\n
            this.modifyFeature(evt.xy, !!this.lastUp);\n
        }\n
        return true;\n
    },\n
    \n
    /**\n
     * Method: up\n
     * Handle mouseup and touchend.  Send the latest point in the geometry to\n
     * the control. Return determines whether to propagate the event on the map.\n
     * \n
     * Parameters:\n
     * evt - {Event} The browser event\n
     *\n
     * Returns: \n
     * {Boolean} Allow event propagation\n
     */\n
    up: function (evt) {\n
        if (this.mouseDown && (!this.lastUp || !this.lastUp.equals(evt.xy))) {\n
            if(this.stoppedDown && this.freehandMode(evt)) {\n
                if (this.persist) {\n
                    this.destroyPersistedFeature();\n
                }\n
                this.removePoint();\n
                this.finalize();\n
            } else {\n
                if (this.passesTolerance(this.lastDown, evt.xy,\n
                                         this.pixelTolerance)) {\n
                    if (this.touch) {\n
                        this.modifyFeature(evt.xy);\n
                    }\n
                    if(this.lastUp == null && this.persist) {\n
                        this.destroyPersistedFeature();\n
                    }\n
                    this.addPoint(evt.xy);\n
                    this.lastUp = evt.xy;\n
                    if(this.line.geometry.components.length === this.maxVertices + 1) {\n
                        this.finishGeometry();\n
                    }\n
                }\n
            }\n
        }\n
        this.stoppedDown = this.stopDown;\n
        this.mouseDown = false;\n
        return !this.stopUp;\n
    },\n
\n
    /**\n
     * APIMethod: finishGeometry\n
     * Finish the geometry and send it back to the control.\n
     */\n
    finishGeometry: function() {\n
        var index = this.line.geometry.components.length - 1;\n
        this.line.geometry.removeComponent(this.line.geometry.components[index]);\n
        this.removePoint();\n
        this.finalize();\n
    },\n
  \n
    /**\n
     * Method: dblclick \n
     * Handle double-clicks.\n
     * \n
     * Parameters:\n
     * evt - {Event} The browser event\n
     *\n
     * Returns: \n
     * {Boolean} Allow event propagation\n
     */\n
    dblclick: function(evt) {\n
        if(!this.freehandMode(evt)) {\n
            this.finishGeometry();\n
        }\n
        return false;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Handler.Path"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>16921</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
