<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.83</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>MultiLineString.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Geometry/Collection.js\n
 * @requires OpenLayers/Geometry/LineString.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Geometry.MultiLineString\n
 * A MultiLineString is a geometry with multiple <OpenLayers.Geometry.LineString>\n
 * components.\n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Geometry.Collection>\n
 *  - <OpenLayers.Geometry> \n
 */\n
OpenLayers.Geometry.MultiLineString = OpenLayers.Class(\n
  OpenLayers.Geometry.Collection, {\n
\n
    /**\n
     * Property: componentTypes\n
     * {Array(String)} An array of class names representing the types of\n
     * components that the collection can include.  A null value means the\n
     * component types are not restricted.\n
     */\n
    componentTypes: ["OpenLayers.Geometry.LineString"],\n
\n
    /**\n
     * Constructor: OpenLayers.Geometry.MultiLineString\n
     * Constructor for a MultiLineString Geometry.\n
     *\n
     * Parameters: \n
     * components - {Array(<OpenLayers.Geometry.LineString>)} \n
     *\n
     */\n
    \n
    /**\n
     * Method: split\n
     * Use this geometry (the source) to attempt to split a target geometry.\n
     * \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} The target geometry.\n
     * options - {Object} Properties of this object will be used to determine\n
     *     how the split is conducted.\n
     *\n
     * Valid options:\n
     * mutual - {Boolean} Split the source geometry in addition to the target\n
     *     geometry.  Default is false.\n
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is\n
     *     true.  If false, a vertex on the source must be within the tolerance\n
     *     distance of the intersection to be considered a split.\n
     * tolerance - {Number} If a non-null value is provided, intersections\n
     *     within the tolerance distance of an existing vertex on the source\n
     *     will be assumed to occur at the vertex.\n
     * \n
     * Returns:\n
     * {Array} A list of geometries (of this same type as the target) that\n
     *     result from splitting the target with the source geometry.  The\n
     *     source and target geometry will remain unmodified.  If no split\n
     *     results, null will be returned.  If mutual is true and a split\n
     *     results, return will be an array of two arrays - the first will be\n
     *     all geometries that result from splitting the source geometry and\n
     *     the second will be all geometries that result from splitting the\n
     *     target geometry.\n
     */\n
    split: function(geometry, options) {\n
        var results = null;\n
        var mutual = options && options.mutual;\n
        var splits, sourceLine, sourceLines, sourceSplit, targetSplit;\n
        var sourceParts = [];\n
        var targetParts = [geometry];\n
        for(var i=0, len=this.components.length; i<len; ++i) {\n
            sourceLine = this.components[i];\n
            sourceSplit = false;\n
            for(var j=0; j < targetParts.length; ++j) { \n
                splits = sourceLine.split(targetParts[j], options);\n
                if(splits) {\n
                    if(mutual) {\n
                        sourceLines = splits[0];\n
                        for(var k=0, klen=sourceLines.length; k<klen; ++k) {\n
                            if(k===0 && sourceParts.length) {\n
                                sourceParts[sourceParts.length-1].addComponent(\n
                                    sourceLines[k]\n
                                );\n
                            } else {\n
                                sourceParts.push(\n
                                    new OpenLayers.Geometry.MultiLineString([\n
                                        sourceLines[k]\n
                                    ])\n
                                );\n
                            }\n
                        }\n
                        sourceSplit = true;\n
                        splits = splits[1];\n
                    }\n
                    if(splits.length) {\n
                        // splice in new target parts\n
                        splits.unshift(j, 1);\n
                        Array.prototype.splice.apply(targetParts, splits);\n
                        break;\n
                    }\n
                }\n
            }\n
            if(!sourceSplit) {\n
                // source line was not hit\n
                if(sourceParts.length) {\n
                    // add line to existing multi\n
                    sourceParts[sourceParts.length-1].addComponent(\n
                        sourceLine.clone()\n
                    );\n
                } else {\n
                    // create a fresh multi\n
                    sourceParts = [\n
                        new OpenLayers.Geometry.MultiLineString(\n
                            sourceLine.clone()\n
                        )\n
                    ];\n
                }\n
            }\n
        }\n
        if(sourceParts && sourceParts.length > 1) {\n
            sourceSplit = true;\n
        } else {\n
            sourceParts = [];\n
        }\n
        if(targetParts && targetParts.length > 1) {\n
            targetSplit = true;\n
        } else {\n
            targetParts = [];\n
        }\n
        if(sourceSplit || targetSplit) {\n
            if(mutual) {\n
                results = [sourceParts, targetParts];\n
            } else {\n
                results = targetParts;\n
            }\n
        }\n
        return results;\n
    },\n
    \n
    /**\n
     * Method: splitWith\n
     * Split this geometry (the target) with the given geometry (the source).\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} A geometry used to split this\n
     *     geometry (the source).\n
     * options - {Object} Properties of this object will be used to determine\n
     *     how the split is conducted.\n
     *\n
     * Valid options:\n
     * mutual - {Boolean} Split the source geometry in addition to the target\n
     *     geometry.  Default is false.\n
     * edge - {Boolean} Allow splitting when only edges intersect.  Default is\n
     *     true.  If false, a vertex on the source must be within the tolerance\n
     *     distance of the intersection to be considered a split.\n
     * tolerance - {Number} If a non-null value is provided, intersections\n
     *     within the tolerance distance of an existing vertex on the source\n
     *     will be assumed to occur at the vertex.\n
     * \n
     * Returns:\n
     * {Array} A list of geometries (of this same type as the target) that\n
     *     result from splitting the target with the source geometry.  The\n
     *     source and target geometry will remain unmodified.  If no split\n
     *     results, null will be returned.  If mutual is true and a split\n
     *     results, return will be an array of two arrays - the first will be\n
     *     all geometries that result from splitting the source geometry and\n
     *     the second will be all geometries that result from splitting the\n
     *     target geometry.\n
     */\n
    splitWith: function(geometry, options) {\n
        var results = null;\n
        var mutual = options && options.mutual;\n
        var splits, targetLine, sourceLines, sourceSplit, targetSplit, sourceParts, targetParts;\n
        if(geometry instanceof OpenLayers.Geometry.LineString) {\n
            targetParts = [];\n
            sourceParts = [geometry];\n
            for(var i=0, len=this.components.length; i<len; ++i) {\n
                targetSplit = false;\n
                targetLine = this.components[i];\n
                for(var j=0; j<sourceParts.length; ++j) {\n
                    splits = sourceParts[j].split(targetLine, options);\n
                    if(splits) {\n
                        if(mutual) {\n
                            sourceLines = splits[0];\n
                            if(sourceLines.length) {\n
                                // splice in new source parts\n
                                sourceLines.unshift(j, 1);\n
                                Array.prototype.splice.apply(sourceParts, sourceLines);\n
                                j += sourceLines.length - 2;\n
                            }\n
                            splits = splits[1];\n
                            if(splits.length === 0) {\n
                                splits = [targetLine.clone()];\n
                            }\n
                        }\n
                        for(var k=0, klen=splits.length; k<klen; ++k) {\n
                            if(k===0 && targetParts.length) {\n
                                targetParts[targetParts.length-1].addComponent(\n
                                    splits[k]\n
                                );\n
                            } else {\n
                                targetParts.push(\n
                                    new OpenLayers.Geometry.MultiLineString([\n
                                        splits[k]\n
                                    ])\n
                                );\n
                            }\n
                        }\n
                        targetSplit = true;                    \n
                    }\n
                }\n
                if(!targetSplit) {\n
                    // target component was not hit\n
                    if(targetParts.length) {\n
                        // add it to any existing multi-line\n
                        targetParts[targetParts.length-1].addComponent(\n
                            targetLine.clone()\n
                        );\n
                    } else {\n
                        // or start with a fresh multi-line\n
                        targetParts = [\n
                            new OpenLayers.Geometry.MultiLineString([\n
                                targetLine.clone()\n
                            ])\n
                        ];\n
                    }\n
                    \n
                }\n
            }\n
        } else {\n
            results = geometry.split(this);\n
        }\n
        if(sourceParts && sourceParts.length > 1) {\n
            sourceSplit = true;\n
        } else {\n
            sourceParts = [];\n
        }\n
        if(targetParts && targetParts.length > 1) {\n
            targetSplit = true;\n
        } else {\n
            targetParts = [];\n
        }\n
        if(sourceSplit || targetSplit) {\n
            if(mutual) {\n
                results = [sourceParts, targetParts];\n
            } else {\n
                results = targetParts;\n
            }\n
        }\n
        return results;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Geometry.MultiLineString"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>10486</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
