<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.83</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Collection.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Geometry.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Geometry.Collection\n
 * A Collection is exactly what it sounds like: A collection of different \n
 * Geometries. These are stored in the local parameter <components> (which\n
 * can be passed as a parameter to the constructor). \n
 * \n
 * As new geometries are added to the collection, they are NOT cloned. \n
 * When removing geometries, they need to be specified by reference (ie you \n
 * have to pass in the *exact* geometry to be removed).\n
 * \n
 * The <getArea> and <getLength> functions here merely iterate through\n
 * the components, summing their respective areas and lengths.\n
 *\n
 * Create a new instance with the <OpenLayers.Geometry.Collection> constructor.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Geometry> \n
 */\n
OpenLayers.Geometry.Collection = OpenLayers.Class(OpenLayers.Geometry, {\n
\n
    /**\n
     * APIProperty: components\n
     * {Array(<OpenLayers.Geometry>)} The component parts of this geometry\n
     */\n
    components: null,\n
    \n
    /**\n
     * Property: componentTypes\n
     * {Array(String)} An array of class names representing the types of\n
     * components that the collection can include.  A null value means the\n
     * component types are not restricted.\n
     */\n
    componentTypes: null,\n
\n
    /**\n
     * Constructor: OpenLayers.Geometry.Collection\n
     * Creates a Geometry Collection -- a list of geoms.\n
     *\n
     * Parameters: \n
     * components - {Array(<OpenLayers.Geometry>)} Optional array of geometries\n
     *\n
     */\n
    initialize: function (components) {\n
        OpenLayers.Geometry.prototype.initialize.apply(this, arguments);\n
        this.components = [];\n
        if (components != null) {\n
            this.addComponents(components);\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: destroy\n
     * Destroy this geometry.\n
     */\n
    destroy: function () {\n
        this.components.length = 0;\n
        this.components = null;\n
        OpenLayers.Geometry.prototype.destroy.apply(this, arguments);\n
    },\n
\n
    /**\n
     * APIMethod: clone\n
     * Clone this geometry.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Geometry.Collection>} An exact clone of this collection\n
     */\n
    clone: function() {\n
        var geometry = eval("new " + this.CLASS_NAME + "()");\n
        for(var i=0, len=this.components.length; i<len; i++) {\n
            geometry.addComponent(this.components[i].clone());\n
        }\n
        \n
        // catch any randomly tagged-on properties\n
        OpenLayers.Util.applyDefaults(geometry, this);\n
        \n
        return geometry;\n
    },\n
\n
    /**\n
     * Method: getComponentsString\n
     * Get a string representing the components for this collection\n
     * \n
     * Returns:\n
     * {String} A string representation of the components of this geometry\n
     */\n
    getComponentsString: function(){\n
        var strings = [];\n
        for(var i=0, len=this.components.length; i<len; i++) {\n
            strings.push(this.components[i].toShortString()); \n
        }\n
        return strings.join(",");\n
    },\n
\n
    /**\n
     * APIMethod: calculateBounds\n
     * Recalculate the bounds by iterating through the components and \n
     * calling calling extendBounds() on each item.\n
     */\n
    calculateBounds: function() {\n
        this.bounds = null;\n
        var bounds = new OpenLayers.Bounds();\n
        var components = this.components;\n
        if (components) {\n
            for (var i=0, len=components.length; i<len; i++) {\n
                bounds.extend(components[i].getBounds());\n
            }\n
        }\n
        // to preserve old behavior, we only set bounds if non-null\n
        // in the future, we could add bounds.isEmpty()\n
        if (bounds.left != null && bounds.bottom != null && \n
            bounds.right != null && bounds.top != null) {\n
            this.setBounds(bounds);\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: addComponents\n
     * Add components to this geometry.\n
     *\n
     * Parameters:\n
     * components - {Array(<OpenLayers.Geometry>)} An array of geometries to add\n
     */\n
    addComponents: function(components){\n
        if(!(OpenLayers.Util.isArray(components))) {\n
            components = [components];\n
        }\n
        for(var i=0, len=components.length; i<len; i++) {\n
            this.addComponent(components[i]);\n
        }\n
    },\n
\n
    /**\n
     * Method: addComponent\n
     * Add a new component (geometry) to the collection.  If this.componentTypes\n
     * is set, then the component class name must be in the componentTypes array.\n
     *\n
     * The bounds cache is reset.\n
     * \n
     * Parameters:\n
     * component - {<OpenLayers.Geometry>} A geometry to add\n
     * index - {int} Optional index into the array to insert the component\n
     *\n
     * Returns:\n
     * {Boolean} The component geometry was successfully added\n
     */    \n
    addComponent: function(component, index) {\n
        var added = false;\n
        if(component) {\n
            if(this.componentTypes == null ||\n
               (OpenLayers.Util.indexOf(this.componentTypes,\n
                                        component.CLASS_NAME) > -1)) {\n
\n
                if(index != null && (index < this.components.length)) {\n
                    var components1 = this.components.slice(0, index);\n
                    var components2 = this.components.slice(index, \n
                                                           this.components.length);\n
                    components1.push(component);\n
                    this.components = components1.concat(components2);\n
                } else {\n
                    this.components.push(component);\n
                }\n
                component.parent = this;\n
                this.clearBounds();\n
                added = true;\n
            }\n
        }\n
        return added;\n
    },\n
    \n
    /**\n
     * APIMethod: removeComponents\n
     * Remove components from this geometry.\n
     *\n
     * Parameters:\n
     * components - {Array(<OpenLayers.Geometry>)} The components to be removed\n
     *\n
     * Returns: \n
     * {Boolean} A component was removed.\n
     */\n
    removeComponents: function(components) {\n
        var removed = false;\n
\n
        if(!(OpenLayers.Util.isArray(components))) {\n
            components = [components];\n
        }\n
        for(var i=components.length-1; i>=0; --i) {\n
            removed = this.removeComponent(components[i]) || removed;\n
        }\n
        return removed;\n
    },\n
    \n
    /**\n
     * Method: removeComponent\n
     * Remove a component from this geometry.\n
     *\n
     * Parameters:\n
     * component - {<OpenLayers.Geometry>} \n
     *\n
     * Returns: \n
     * {Boolean} The component was removed.\n
     */\n
    removeComponent: function(component) {\n
        \n
        OpenLayers.Util.removeItem(this.components, component);\n
        \n
        // clearBounds() so that it gets recalculated on the next call\n
        // to this.getBounds();\n
        this.clearBounds();\n
        return true;\n
    },\n
\n
    /**\n
     * APIMethod: getLength\n
     * Calculate the length of this geometry\n
     *\n
     * Returns:\n
     * {Float} The length of the geometry\n
     */\n
    getLength: function() {\n
        var length = 0.0;\n
        for (var i=0, len=this.components.length; i<len; i++) {\n
            length += this.components[i].getLength();\n
        }\n
        return length;\n
    },\n
    \n
    /**\n
     * APIMethod: getArea\n
     * Calculate the area of this geometry. Note how this function is overridden\n
     * in <OpenLayers.Geometry.Polygon>.\n
     *\n
     * Returns:\n
     * {Float} The area of the collection by summing its parts\n
     */\n
    getArea: function() {\n
        var area = 0.0;\n
        for (var i=0, len=this.components.length; i<len; i++) {\n
            area += this.components[i].getArea();\n
        }\n
        return area;\n
    },\n
\n
    /** \n
     * APIMethod: getGeodesicArea\n
     * Calculate the approximate area of the polygon were it projected onto\n
     *     the earth.\n
     *\n
     * Parameters:\n
     * projection - {<OpenLayers.Projection>} The spatial reference system\n
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is\n
     *     assumed.\n
     * \n
     * Reference:\n
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for\n
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion\n
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n
     *\n
     * Returns:\n
     * {float} The approximate geodesic area of the geometry in square meters.\n
     */\n
    getGeodesicArea: function(projection) {\n
        var area = 0.0;\n
        for(var i=0, len=this.components.length; i<len; i++) {\n
            area += this.components[i].getGeodesicArea(projection);\n
        }\n
        return area;\n
    },\n
    \n
    /**\n
     * APIMethod: getCentroid\n
     *\n
     * Compute the centroid for this geometry collection.\n
     *\n
     * Parameters:\n
     * weighted - {Boolean} Perform the getCentroid computation recursively,\n
     * returning an area weighted average of all geometries in this collection.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Geometry.Point>} The centroid of the collection\n
     */\n
    getCentroid: function(weighted) {\n
        if (!weighted) {\n
            return this.components.length && this.components[0].getCentroid();\n
        }\n
        var len = this.components.length;\n
        if (!len) {\n
            return false;\n
        }\n
        \n
        var areas = [];\n
        var centroids = [];\n
        var areaSum = 0;\n
        var minArea = Number.MAX_VALUE;\n
        var component;\n
        for (var i=0; i<len; ++i) {\n
            component = this.components[i];\n
            var area = component.getArea();\n
            var centroid = component.getCentroid(true);\n
            if (isNaN(area) || isNaN(centroid.x) || isNaN(centroid.y)) {\n
                continue;\n
            }\n
            areas.push(area);\n
            areaSum += area;\n
            minArea = (area < minArea && area > 0) ? area : minArea;\n
            centroids.push(centroid);\n
        }\n
        len = areas.length;\n
        if (areaSum === 0) {\n
            // all the components in this collection have 0 area\n
            // probably a collection of points -- weight all the points the same\n
            for (var i=0; i<len; ++i) {\n
                areas[i] = 1;\n
            }\n
            areaSum = areas.length;\n
        } else {\n
            // normalize all the areas where the smallest area will get\n
            // a value of 1\n
            for (var i=0; i<len; ++i) {\n
                areas[i] /= minArea;\n
            }\n
            areaSum /= minArea;\n
        }\n
        \n
        var xSum = 0, ySum = 0, centroid, area;\n
        for (var i=0; i<len; ++i) {\n
            centroid = centroids[i];\n
            area = areas[i];\n
            xSum += centroid.x * area;\n
            ySum += centroid.y * area;\n
        }\n
        \n
        return new OpenLayers.Geometry.Point(xSum/areaSum, ySum/areaSum);\n
    },\n
\n
    /**\n
     * APIMethod: getGeodesicLength\n
     * Calculate the approximate length of the geometry were it projected onto\n
     *     the earth.\n
     *\n
     * projection - {<OpenLayers.Projection>} The spatial reference system\n
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is\n
     *     assumed.\n
     * \n
     * Returns:\n
     * {Float} The appoximate geodesic length of the geometry in meters.\n
     */\n
    getGeodesicLength: function(projection) {\n
        var length = 0.0;\n
        for(var i=0, len=this.components.length; i<len; i++) {\n
            length += this.components[i].getGeodesicLength(projection);\n
        }\n
        return length;\n
    },\n
\n
    /**\n
     * APIMethod: move\n
     * Moves a geometry by the given displacement along positive x and y axes.\n
     *     This modifies the position of the geometry and clears the cached\n
     *     bounds.\n
     *\n
     * Parameters:\n
     * x - {Float} Distance to move geometry in positive x direction. \n
     * y - {Float} Distance to move geometry in positive y direction.\n
     */\n
    move: function(x, y) {\n
        for(var i=0, len=this.components.length; i<len; i++) {\n
            this.components[i].move(x, y);\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: rotate\n
     * Rotate a geometry around some origin\n
     *\n
     * Parameters:\n
     * angle - {Float} Rotation angle in degrees (measured counterclockwise\n
     *                 from the positive x-axis)\n
     * origin - {<OpenLayers.Geometry.Point>} Center point for the rotation\n
     */\n
    rotate: function(angle, origin) {\n
        for(var i=0, len=this.components.length; i<len; ++i) {\n
            this.components[i].rotate(angle, origin);\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: resize\n
     * Resize a geometry relative to some origin.  Use this method to apply\n
     *     a uniform scaling to a geometry.\n
     *\n
     * Parameters:\n
     * scale - {Float} Factor by which to scale the geometry.  A scale of 2\n
     *                 doubles the size of the geometry in each dimension\n
     *                 (lines, for example, will be twice as long, and polygons\n
     *                 will have four times the area).\n
     * origin - {<OpenLayers.Geometry.Point>} Point of origin for resizing\n
     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.\n
     * \n
     * Returns:\n
     * {<OpenLayers.Geometry>} - The current geometry. \n
     */\n
    resize: function(scale, origin, ratio) {\n
        for(var i=0; i<this.components.length; ++i) {\n
            this.components[i].resize(scale, origin, ratio);\n
        }\n
        return this;\n
    },\n
\n
    /**\n
     * APIMethod: distanceTo\n
     * Calculate the closest distance between two geometries (on the x-y plane).\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} The target geometry.\n
     * options - {Object} Optional properties for configuring the distance\n
     *     calculation.\n
     *\n
     * Valid options:\n
     * details - {Boolean} Return details from the distance calculation.\n
     *     Default is false.\n
     * edge - {Boolean} Calculate the distance from this geometry to the\n
     *     nearest edge of the target geometry.  Default is true.  If true,\n
     *     calling distanceTo from a geometry that is wholly contained within\n
     *     the target will result in a non-zero distance.  If false, whenever\n
     *     geometries intersect, calling distanceTo will return 0.  If false,\n
     *     details cannot be returned.\n
     *\n
     * Returns:\n
     * {Number | Object} The distance between this geometry and the target.\n
     *     If details is true, the return will be an object with distance,\n
     *     x0, y0, x1, and y1 properties.  The x0 and y0 properties represent\n
     *     the coordinates of the closest point on this geometry. The x1 and y1\n
     *     properties represent the coordinates of the closest point on the\n
     *     target geometry.\n
     */\n
    distanceTo: function(geometry, options) {\n
        var edge = !(options && options.edge === false);\n
        var details = edge && options && options.details;\n
        var result, best, distance;\n
        var min = Number.POSITIVE_INFINITY;\n
        for(var i=0, len=this.components.length; i<len; ++i) {\n
            result = this.components[i].distanceTo(geometry, options);\n
            distance = details ? result.distance : result;\n
            if(distance < min) {\n
                min = distance;\n
                best = result;\n
                if(min == 0) {\n
                    break;\n
                }\n
            }\n
        }\n
        return best;\n
    },\n
\n
    /** \n
     * APIMethod: equals\n
     * Determine whether another geometry is equivalent to this one.  Geometries\n
     *     are considered equivalent if all components have the same coordinates.\n
     * \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} The geometry to test. \n
     *\n
     * Returns:\n
     * {Boolean} The supplied geometry is equivalent to this geometry.\n
     */\n
    equals: function(geometry) {\n
        var equivalent = true;\n
        if(!geometry || !geometry.CLASS_NAME ||\n
           (this.CLASS_NAME != geometry.CLASS_NAME)) {\n
            equivalent = false;\n
        } else if(!(OpenLayers.Util.isArray(geometry.components)) ||\n
                  (geometry.components.length != this.components.length)) {\n
            equivalent = false;\n
        } else {\n
            for(var i=0, len=this.components.length; i<len; ++i) {\n
                if(!this.components[i].equals(geometry.components[i])) {\n
                    equivalent = false;\n
                    break;\n
                }\n
            }\n
        }\n
        return equivalent;\n
    },\n
\n
    /**\n
     * APIMethod: transform\n
     * Reproject the components geometry from source to dest.\n
     * \n
     * Parameters:\n
     * source - {<OpenLayers.Projection>} \n
     * dest - {<OpenLayers.Projection>}\n
     * \n
     * Returns:\n
     * {<OpenLayers.Geometry>} \n
     */\n
    transform: function(source, dest) {\n
        if (source && dest) {\n
            for (var i=0, len=this.components.length; i<len; i++) {  \n
                var component = this.components[i];\n
                component.transform(source, dest);\n
            }\n
            this.bounds = null;\n
        }\n
        return this;\n
    },\n
\n
    /**\n
     * APIMethod: intersects\n
     * Determine if the input geometry intersects this one.\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} Any type of geometry.\n
     *\n
     * Returns:\n
     * {Boolean} The input geometry intersects this one.\n
     */\n
    intersects: function(geometry) {\n
        var intersect = false;\n
        for(var i=0, len=this.components.length; i<len; ++ i) {\n
            intersect = geometry.intersects(this.components[i]);\n
            if(intersect) {\n
                break;\n
            }\n
        }\n
        return intersect;\n
    },\n
\n
    /**\n
     * APIMethod: getVertices\n
     * Return a list of all points in this geometry.\n
     *\n
     * Parameters:\n
     * nodes - {Boolean} For lines, only return vertices that are\n
     *     endpoints.  If false, for lines, only vertices that are not\n
     *     endpoints will be returned.  If not provided, all vertices will\n
     *     be returned.\n
     *\n
     * Returns:\n
     * {Array} A list of all vertices in the geometry.\n
     */\n
    getVertices: function(nodes) {\n
        var vertices = [];\n
        for(var i=0, len=this.components.length; i<len; ++i) {\n
            Array.prototype.push.apply(\n
                vertices, this.components[i].getVertices(nodes)\n
            );\n
        }\n
        return vertices;\n
    },\n
\n
\n
    CLASS_NAME: "OpenLayers.Geometry.Collection"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>18626</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
