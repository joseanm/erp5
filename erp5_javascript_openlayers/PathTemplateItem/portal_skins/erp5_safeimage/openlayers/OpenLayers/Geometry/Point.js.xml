<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.84</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Point.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Geometry.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Geometry.Point\n
 * Point geometry class. \n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Geometry> \n
 */\n
OpenLayers.Geometry.Point = OpenLayers.Class(OpenLayers.Geometry, {\n
\n
    /** \n
     * APIProperty: x \n
     * {float} \n
     */\n
    x: null,\n
\n
    /** \n
     * APIProperty: y \n
     * {float} \n
     */\n
    y: null,\n
\n
    /**\n
     * Constructor: OpenLayers.Geometry.Point\n
     * Construct a point geometry.\n
     *\n
     * Parameters:\n
     * x - {float} \n
     * y - {float}\n
     * \n
     */\n
    initialize: function(x, y) {\n
        OpenLayers.Geometry.prototype.initialize.apply(this, arguments);\n
        \n
        this.x = parseFloat(x);\n
        this.y = parseFloat(y);\n
    },\n
\n
    /**\n
     * APIMethod: clone\n
     * \n
     * Returns:\n
     * {<OpenLayers.Geometry.Point>} An exact clone of this OpenLayers.Geometry.Point\n
     */\n
    clone: function(obj) {\n
        if (obj == null) {\n
            obj = new OpenLayers.Geometry.Point(this.x, this.y);\n
        }\n
\n
        // catch any randomly tagged-on properties\n
        OpenLayers.Util.applyDefaults(obj, this);\n
\n
        return obj;\n
    },\n
\n
    /** \n
     * Method: calculateBounds\n
     * Create a new Bounds based on the lon/lat\n
     */\n
    calculateBounds: function () {\n
        this.bounds = new OpenLayers.Bounds(this.x, this.y,\n
                                            this.x, this.y);\n
    },\n
\n
    /**\n
     * APIMethod: distanceTo\n
     * Calculate the closest distance between two geometries (on the x-y plane).\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} The target geometry.\n
     * options - {Object} Optional properties for configuring the distance\n
     *     calculation.\n
     *\n
     * Valid options:\n
     * details - {Boolean} Return details from the distance calculation.\n
     *     Default is false.\n
     * edge - {Boolean} Calculate the distance from this geometry to the\n
     *     nearest edge of the target geometry.  Default is true.  If true,\n
     *     calling distanceTo from a geometry that is wholly contained within\n
     *     the target will result in a non-zero distance.  If false, whenever\n
     *     geometries intersect, calling distanceTo will return 0.  If false,\n
     *     details cannot be returned.\n
     *\n
     * Returns:\n
     * {Number | Object} The distance between this geometry and the target.\n
     *     If details is true, the return will be an object with distance,\n
     *     x0, y0, x1, and x2 properties.  The x0 and y0 properties represent\n
     *     the coordinates of the closest point on this geometry. The x1 and y1\n
     *     properties represent the coordinates of the closest point on the\n
     *     target geometry.\n
     */\n
    distanceTo: function(geometry, options) {\n
        var edge = !(options && options.edge === false);\n
        var details = edge && options && options.details;\n
        var distance, x0, y0, x1, y1, result;\n
        if(geometry instanceof OpenLayers.Geometry.Point) {\n
            x0 = this.x;\n
            y0 = this.y;\n
            x1 = geometry.x;\n
            y1 = geometry.y;\n
            distance = Math.sqrt(Math.pow(x0 - x1, 2) + Math.pow(y0 - y1, 2));\n
            result = !details ?\n
                distance : {x0: x0, y0: y0, x1: x1, y1: y1, distance: distance};\n
        } else {\n
            result = geometry.distanceTo(this, options);\n
            if(details) {\n
                // switch coord order since this geom is target\n
                result = {\n
                    x0: result.x1, y0: result.y1,\n
                    x1: result.x0, y1: result.y0,\n
                    distance: result.distance\n
                };\n
            }\n
        }\n
        return result;\n
    },\n
    \n
    /** \n
     * APIMethod: equals\n
     * Determine whether another geometry is equivalent to this one.  Geometries\n
     *     are considered equivalent if all components have the same coordinates.\n
     * \n
     * Parameters:\n
     * geom - {<OpenLayers.Geometry.Point>} The geometry to test. \n
     *\n
     * Returns:\n
     * {Boolean} The supplied geometry is equivalent to this geometry.\n
     */\n
    equals: function(geom) {\n
        var equals = false;\n
        if (geom != null) {\n
            equals = ((this.x == geom.x && this.y == geom.y) ||\n
                      (isNaN(this.x) && isNaN(this.y) && isNaN(geom.x) && isNaN(geom.y)));\n
        }\n
        return equals;\n
    },\n
    \n
    /**\n
     * Method: toShortString\n
     *\n
     * Returns:\n
     * {String} Shortened String representation of Point object. \n
     *         (ex. <i>"5, 42"</i>)\n
     */\n
    toShortString: function() {\n
        return (this.x + ", " + this.y);\n
    },\n
    \n
    /**\n
     * APIMethod: move\n
     * Moves a geometry by the given displacement along positive x and y axes.\n
     *     This modifies the position of the geometry and clears the cached\n
     *     bounds.\n
     *\n
     * Parameters:\n
     * x - {Float} Distance to move geometry in positive x direction. \n
     * y - {Float} Distance to move geometry in positive y direction.\n
     */\n
    move: function(x, y) {\n
        this.x = this.x + x;\n
        this.y = this.y + y;\n
        this.clearBounds();\n
    },\n
\n
    /**\n
     * APIMethod: rotate\n
     * Rotate a point around another.\n
     *\n
     * Parameters:\n
     * angle - {Float} Rotation angle in degrees (measured counterclockwise\n
     *                 from the positive x-axis)\n
     * origin - {<OpenLayers.Geometry.Point>} Center point for the rotation\n
     */\n
    rotate: function(angle, origin) {\n
        angle *= Math.PI / 180;\n
        var radius = this.distanceTo(origin);\n
        var theta = angle + Math.atan2(this.y - origin.y, this.x - origin.x);\n
        this.x = origin.x + (radius * Math.cos(theta));\n
        this.y = origin.y + (radius * Math.sin(theta));\n
        this.clearBounds();\n
    },\n
    \n
    /**\n
     * APIMethod: getCentroid\n
     *\n
     * Returns:\n
     * {<OpenLayers.Geometry.Point>} The centroid of the collection\n
     */\n
    getCentroid: function() {\n
        return new OpenLayers.Geometry.Point(this.x, this.y);\n
    },\n
\n
    /**\n
     * APIMethod: resize\n
     * Resize a point relative to some origin.  For points, this has the effect\n
     *     of scaling a vector (from the origin to the point).  This method is\n
     *     more useful on geometry collection subclasses.\n
     *\n
     * Parameters:\n
     * scale - {Float} Ratio of the new distance from the origin to the old\n
     *                 distance from the origin.  A scale of 2 doubles the\n
     *                 distance between the point and origin.\n
     * origin - {<OpenLayers.Geometry.Point>} Point of origin for resizing\n
     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.\n
     * \n
     * Returns:\n
     * {<OpenLayers.Geometry>} - The current geometry. \n
     */\n
    resize: function(scale, origin, ratio) {\n
        ratio = (ratio == undefined) ? 1 : ratio;\n
        this.x = origin.x + (scale * ratio * (this.x - origin.x));\n
        this.y = origin.y + (scale * (this.y - origin.y));\n
        this.clearBounds();\n
        return this;\n
    },\n
    \n
    /**\n
     * APIMethod: intersects\n
     * Determine if the input geometry intersects this one.\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} Any type of geometry.\n
     *\n
     * Returns:\n
     * {Boolean} The input geometry intersects this one.\n
     */\n
    intersects: function(geometry) {\n
        var intersect = false;\n
        if(geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {\n
            intersect = this.equals(geometry);\n
        } else {\n
            intersect = geometry.intersects(this);\n
        }\n
        return intersect;\n
    },\n
    \n
    /**\n
     * APIMethod: transform\n
     * Translate the x,y properties of the point from source to dest.\n
     * \n
     * Parameters:\n
     * source - {<OpenLayers.Projection>} \n
     * dest - {<OpenLayers.Projection>}\n
     * \n
     * Returns:\n
     * {<OpenLayers.Geometry>} \n
     */\n
    transform: function(source, dest) {\n
        if ((source && dest)) {\n
            OpenLayers.Projection.transform(\n
                this, source, dest); \n
            this.bounds = null;\n
        }       \n
        return this;\n
    },\n
\n
    /**\n
     * APIMethod: getVertices\n
     * Return a list of all points in this geometry.\n
     *\n
     * Parameters:\n
     * nodes - {Boolean} For lines, only return vertices that are\n
     *     endpoints.  If false, for lines, only vertices that are not\n
     *     endpoints will be returned.  If not provided, all vertices will\n
     *     be returned.\n
     *\n
     * Returns:\n
     * {Array} A list of all vertices in the geometry.\n
     */\n
    getVertices: function(nodes) {\n
        return [this];\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Geometry.Point"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>8912</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
