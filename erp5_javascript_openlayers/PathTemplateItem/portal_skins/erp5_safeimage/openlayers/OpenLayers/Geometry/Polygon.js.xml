<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.84</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Polygon.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Geometry/Collection.js\n
 * @requires OpenLayers/Geometry/LinearRing.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Geometry.Polygon \n
 * Polygon is a collection of Geometry.LinearRings. \n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Geometry.Collection> \n
 *  - <OpenLayers.Geometry> \n
 */\n
OpenLayers.Geometry.Polygon = OpenLayers.Class(\n
  OpenLayers.Geometry.Collection, {\n
\n
    /**\n
     * Property: componentTypes\n
     * {Array(String)} An array of class names representing the types of\n
     * components that the collection can include.  A null value means the\n
     * component types are not restricted.\n
     */\n
    componentTypes: ["OpenLayers.Geometry.LinearRing"],\n
\n
    /**\n
     * Constructor: OpenLayers.Geometry.Polygon\n
     * Constructor for a Polygon geometry. \n
     * The first ring (this.component[0])is the outer bounds of the polygon and \n
     * all subsequent rings (this.component[1-n]) are internal holes.\n
     *\n
     *\n
     * Parameters:\n
     * components - {Array(<OpenLayers.Geometry.LinearRing>)} \n
     */\n
\n
    /** \n
     * APIMethod: getArea\n
     * Calculated by subtracting the areas of the internal holes from the \n
     *   area of the outer hole.\n
     * \n
     * Returns:\n
     * {float} The area of the geometry\n
     */\n
    getArea: function() {\n
        var area = 0.0;\n
        if ( this.components && (this.components.length > 0)) {\n
            area += Math.abs(this.components[0].getArea());\n
            for (var i=1, len=this.components.length; i<len; i++) {\n
                area -= Math.abs(this.components[i].getArea());\n
            }\n
        }\n
        return area;\n
    },\n
\n
    /** \n
     * APIMethod: getGeodesicArea\n
     * Calculate the approximate area of the polygon were it projected onto\n
     *     the earth.\n
     *\n
     * Parameters:\n
     * projection - {<OpenLayers.Projection>} The spatial reference system\n
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is\n
     *     assumed.\n
     * \n
     * Reference:\n
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for\n
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion\n
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n
     *\n
     * Returns:\n
     * {float} The approximate geodesic area of the polygon in square meters.\n
     */\n
    getGeodesicArea: function(projection) {\n
        var area = 0.0;\n
        if(this.components && (this.components.length > 0)) {\n
            area += Math.abs(this.components[0].getGeodesicArea(projection));\n
            for(var i=1, len=this.components.length; i<len; i++) {\n
                area -= Math.abs(this.components[i].getGeodesicArea(projection));\n
            }\n
        }\n
        return area;\n
    },\n
\n
    /**\n
     * Method: containsPoint\n
     * Test if a point is inside a polygon.  Points on a polygon edge are\n
     *     considered inside.\n
     *\n
     * Parameters:\n
     * point - {<OpenLayers.Geometry.Point>}\n
     *\n
     * Returns:\n
     * {Boolean | Number} The point is inside the polygon.  Returns 1 if the\n
     *     point is on an edge.  Returns boolean otherwise.\n
     */\n
    containsPoint: function(point) {\n
        var numRings = this.components.length;\n
        var contained = false;\n
        if(numRings > 0) {\n
            // check exterior ring - 1 means on edge, boolean otherwise\n
            contained = this.components[0].containsPoint(point);\n
            if(contained !== 1) {\n
                if(contained && numRings > 1) {\n
                    // check interior rings\n
                    var hole;\n
                    for(var i=1; i<numRings; ++i) {\n
                        hole = this.components[i].containsPoint(point);\n
                        if(hole) {\n
                            if(hole === 1) {\n
                                // on edge\n
                                contained = 1;\n
                            } else {\n
                                // in hole\n
                                contained = false;\n
                            }                            \n
                            break;\n
                        }\n
                    }\n
                }\n
            }\n
        }\n
        return contained;\n
    },\n
\n
    /**\n
     * APIMethod: intersects\n
     * Determine if the input geometry intersects this one.\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} Any type of geometry.\n
     *\n
     * Returns:\n
     * {Boolean} The input geometry intersects this one.\n
     */\n
    intersects: function(geometry) {\n
        var intersect = false;\n
        var i, len;\n
        if(geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {\n
            intersect = this.containsPoint(geometry);\n
        } else if(geometry.CLASS_NAME == "OpenLayers.Geometry.LineString" ||\n
                  geometry.CLASS_NAME == "OpenLayers.Geometry.LinearRing") {\n
            // check if rings/linestrings intersect\n
            for(i=0, len=this.components.length; i<len; ++i) {\n
                intersect = geometry.intersects(this.components[i]);\n
                if(intersect) {\n
                    break;\n
                }\n
            }\n
            if(!intersect) {\n
                // check if this poly contains points of the ring/linestring\n
                for(i=0, len=geometry.components.length; i<len; ++i) {\n
                    intersect = this.containsPoint(geometry.components[i]);\n
                    if(intersect) {\n
                        break;\n
                    }\n
                }\n
            }\n
        } else {\n
            for(i=0, len=geometry.components.length; i<len; ++ i) {\n
                intersect = this.intersects(geometry.components[i]);\n
                if(intersect) {\n
                    break;\n
                }\n
            }\n
        }\n
        // check case where this poly is wholly contained by another\n
        if(!intersect && geometry.CLASS_NAME == "OpenLayers.Geometry.Polygon") {\n
            // exterior ring points will be contained in the other geometry\n
            var ring = this.components[0];\n
            for(i=0, len=ring.components.length; i<len; ++i) {\n
                intersect = geometry.containsPoint(ring.components[i]);\n
                if(intersect) {\n
                    break;\n
                }\n
            }\n
        }\n
        return intersect;\n
    },\n
\n
    /**\n
     * APIMethod: distanceTo\n
     * Calculate the closest distance between two geometries (on the x-y plane).\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} The target geometry.\n
     * options - {Object} Optional properties for configuring the distance\n
     *     calculation.\n
     *\n
     * Valid options:\n
     * details - {Boolean} Return details from the distance calculation.\n
     *     Default is false.\n
     * edge - {Boolean} Calculate the distance from this geometry to the\n
     *     nearest edge of the target geometry.  Default is true.  If true,\n
     *     calling distanceTo from a geometry that is wholly contained within\n
     *     the target will result in a non-zero distance.  If false, whenever\n
     *     geometries intersect, calling distanceTo will return 0.  If false,\n
     *     details cannot be returned.\n
     *\n
     * Returns:\n
     * {Number | Object} The distance between this geometry and the target.\n
     *     If details is true, the return will be an object with distance,\n
     *     x0, y0, x1, and y1 properties.  The x0 and y0 properties represent\n
     *     the coordinates of the closest point on this geometry. The x1 and y1\n
     *     properties represent the coordinates of the closest point on the\n
     *     target geometry.\n
     */\n
    distanceTo: function(geometry, options) {\n
        var edge = !(options && options.edge === false);\n
        var result;\n
        // this is the case where we might not be looking for distance to edge\n
        if(!edge && this.intersects(geometry)) {\n
            result = 0;\n
        } else {\n
            result = OpenLayers.Geometry.Collection.prototype.distanceTo.apply(\n
                this, [geometry, options]\n
            );\n
        }\n
        return result;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Geometry.Polygon"\n
});\n
\n
/**\n
 * APIMethod: createRegularPolygon\n
 * Create a regular polygon around a radius. Useful for creating circles \n
 * and the like.\n
 *\n
 * Parameters:\n
 * origin - {<OpenLayers.Geometry.Point>} center of polygon.\n
 * radius - {Float} distance to vertex, in map units.\n
 * sides - {Integer} Number of sides. 20 approximates a circle.\n
 * rotation - {Float} original angle of rotation, in degrees.\n
 */\n
OpenLayers.Geometry.Polygon.createRegularPolygon = function(origin, radius, sides, rotation) {  \n
    var angle = Math.PI * ((1/sides) - (1/2));\n
    if(rotation) {\n
        angle += (rotation / 180) * Math.PI;\n
    }\n
    var rotatedAngle, x, y;\n
    var points = [];\n
    for(var i=0; i<sides; ++i) {\n
        rotatedAngle = angle + (i * 2 * Math.PI / sides);\n
        x = origin.x + (radius * Math.cos(rotatedAngle));\n
        y = origin.y + (radius * Math.sin(rotatedAngle));\n
        points.push(new OpenLayers.Geometry.Point(x, y));\n
    }\n
    var ring = new OpenLayers.Geometry.LinearRing(points);\n
    return new OpenLayers.Geometry.Polygon([ring]);\n
};\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>9394</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
