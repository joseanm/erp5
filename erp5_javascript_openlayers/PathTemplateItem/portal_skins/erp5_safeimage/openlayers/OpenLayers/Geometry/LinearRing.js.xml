<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.83</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>LinearRing.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Geometry/LineString.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Geometry.LinearRing\n
 * \n
 * A Linear Ring is a special LineString which is closed. It closes itself \n
 * automatically on every addPoint/removePoint by adding a copy of the first\n
 * point as the last point. \n
 * \n
 * Also, as it is the first in the line family to close itself, a getArea()\n
 * function is defined to calculate the enclosed area of the linearRing\n
 * \n
 * Inherits:\n
 *  - <OpenLayers.Geometry.LineString>\n
 */\n
OpenLayers.Geometry.LinearRing = OpenLayers.Class(\n
  OpenLayers.Geometry.LineString, {\n
\n
    /**\n
     * Property: componentTypes\n
     * {Array(String)} An array of class names representing the types of \n
     *                 components that the collection can include.  A null \n
     *                 value means the component types are not restricted.\n
     */\n
    componentTypes: ["OpenLayers.Geometry.Point"],\n
\n
    /**\n
     * Constructor: OpenLayers.Geometry.LinearRing\n
     * Linear rings are constructed with an array of points.  This array\n
     *     can represent a closed or open ring.  If the ring is open (the last\n
     *     point does not equal the first point), the constructor will close\n
     *     the ring.  If the ring is already closed (the last point does equal\n
     *     the first point), it will be left closed.\n
     * \n
     * Parameters:\n
     * points - {Array(<OpenLayers.Geometry.Point>)} points\n
     */\n
\n
    /**\n
     * APIMethod: addComponent\n
     * Adds a point to geometry components.  If the point is to be added to\n
     *     the end of the components array and it is the same as the last point\n
     *     already in that array, the duplicate point is not added.  This has \n
     *     the effect of closing the ring if it is not already closed, and \n
     *     doing the right thing if it is already closed.  This behavior can \n
     *     be overridden by calling the method with a non-null index as the \n
     *     second argument.\n
     *\n
     * Parameters:\n
     * point - {<OpenLayers.Geometry.Point>}\n
     * index - {Integer} Index into the array to insert the component\n
     * \n
     * Returns:\n
     * {Boolean} Was the Point successfully added?\n
     */\n
    addComponent: function(point, index) {\n
        var added = false;\n
\n
        //remove last point\n
        var lastPoint = this.components.pop();\n
\n
        // given an index, add the point\n
        // without an index only add non-duplicate points\n
        if(index != null || !point.equals(lastPoint)) {\n
            added = OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, \n
                                                                    arguments);\n
        }\n
\n
        //append copy of first point\n
        var firstPoint = this.components[0];\n
        OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, \n
                                                                [firstPoint]);\n
        \n
        return added;\n
    },\n
    \n
    /**\n
     * APIMethod: removeComponent\n
     * Removes a point from geometry components.\n
     *\n
     * Parameters:\n
     * point - {<OpenLayers.Geometry.Point>}\n
     *\n
     * Returns: \n
     * {Boolean} The component was removed.\n
     */\n
    removeComponent: function(point) {\n
        var removed = this.components && (this.components.length > 3);\n
        if (removed) {\n
            //remove last point\n
            this.components.pop();\n
            \n
            //remove our point\n
            OpenLayers.Geometry.Collection.prototype.removeComponent.apply(this, \n
                                                                    arguments);\n
            //append copy of first point\n
            var firstPoint = this.components[0];\n
            OpenLayers.Geometry.Collection.prototype.addComponent.apply(this, \n
                                                                [firstPoint]);\n
        }\n
        return removed;\n
    },\n
    \n
    /**\n
     * APIMethod: move\n
     * Moves a geometry by the given displacement along positive x and y axes.\n
     *     This modifies the position of the geometry and clears the cached\n
     *     bounds.\n
     *\n
     * Parameters:\n
     * x - {Float} Distance to move geometry in positive x direction. \n
     * y - {Float} Distance to move geometry in positive y direction.\n
     */\n
    move: function(x, y) {\n
        for(var i = 0, len=this.components.length; i<len - 1; i++) {\n
            this.components[i].move(x, y);\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: rotate\n
     * Rotate a geometry around some origin\n
     *\n
     * Parameters:\n
     * angle - {Float} Rotation angle in degrees (measured counterclockwise\n
     *                 from the positive x-axis)\n
     * origin - {<OpenLayers.Geometry.Point>} Center point for the rotation\n
     */\n
    rotate: function(angle, origin) {\n
        for(var i=0, len=this.components.length; i<len - 1; ++i) {\n
            this.components[i].rotate(angle, origin);\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: resize\n
     * Resize a geometry relative to some origin.  Use this method to apply\n
     *     a uniform scaling to a geometry.\n
     *\n
     * Parameters:\n
     * scale - {Float} Factor by which to scale the geometry.  A scale of 2\n
     *                 doubles the size of the geometry in each dimension\n
     *                 (lines, for example, will be twice as long, and polygons\n
     *                 will have four times the area).\n
     * origin - {<OpenLayers.Geometry.Point>} Point of origin for resizing\n
     * ratio - {Float} Optional x:y ratio for resizing.  Default ratio is 1.\n
     * \n
     * Returns:\n
     * {<OpenLayers.Geometry>} - The current geometry. \n
     */\n
    resize: function(scale, origin, ratio) {\n
        for(var i=0, len=this.components.length; i<len - 1; ++i) {\n
            this.components[i].resize(scale, origin, ratio);\n
        }\n
        return this;\n
    },\n
    \n
    /**\n
     * APIMethod: transform\n
     * Reproject the components geometry from source to dest.\n
     *\n
     * Parameters:\n
     * source - {<OpenLayers.Projection>}\n
     * dest - {<OpenLayers.Projection>}\n
     * \n
     * Returns:\n
     * {<OpenLayers.Geometry>} \n
     */\n
    transform: function(source, dest) {\n
        if (source && dest) {\n
            for (var i=0, len=this.components.length; i<len - 1; i++) {\n
                var component = this.components[i];\n
                component.transform(source, dest);\n
            }\n
            this.bounds = null;\n
        }\n
        return this;\n
    },\n
    \n
    /**\n
     * APIMethod: getCentroid\n
     *\n
     * Returns:\n
     * {<OpenLayers.Geometry.Point>} The centroid of the collection\n
     */\n
    getCentroid: function() {\n
        if (this.components && (this.components.length > 2)) {\n
            var sumX = 0.0;\n
            var sumY = 0.0;\n
            for (var i = 0; i < this.components.length - 1; i++) {\n
                var b = this.components[i];\n
                var c = this.components[i+1];\n
                sumX += (b.x + c.x) * (b.x * c.y - c.x * b.y);\n
                sumY += (b.y + c.y) * (b.x * c.y - c.x * b.y);\n
            }\n
            var area = -1 * this.getArea();\n
            var x = sumX / (6 * area);\n
            var y = sumY / (6 * area);\n
            return new OpenLayers.Geometry.Point(x, y);\n
        } else {\n
            return null;\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: getArea\n
     * Note - The area is positive if the ring is oriented CW, otherwise\n
     *         it will be negative.\n
     * \n
     * Returns:\n
     * {Float} The signed area for a ring.\n
     */\n
    getArea: function() {\n
        var area = 0.0;\n
        if ( this.components && (this.components.length > 2)) {\n
            var sum = 0.0;\n
            for (var i=0, len=this.components.length; i<len - 1; i++) {\n
                var b = this.components[i];\n
                var c = this.components[i+1];\n
                sum += (b.x + c.x) * (c.y - b.y);\n
            }\n
            area = - sum / 2.0;\n
        }\n
        return area;\n
    },\n
    \n
    /**\n
     * APIMethod: getGeodesicArea\n
     * Calculate the approximate area of the polygon were it projected onto\n
     *     the earth.  Note that this area will be positive if ring is oriented\n
     *     clockwise, otherwise it will be negative.\n
     *\n
     * Parameters:\n
     * projection - {<OpenLayers.Projection>} The spatial reference system\n
     *     for the geometry coordinates.  If not provided, Geographic/WGS84 is\n
     *     assumed.\n
     * \n
     * Reference:\n
     * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for\n
     *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion\n
     *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409\n
     *\n
     * Returns:\n
     * {float} The approximate signed geodesic area of the polygon in square\n
     *     meters.\n
     */\n
    getGeodesicArea: function(projection) {\n
        var ring = this;  // so we can work with a clone if needed\n
        if(projection) {\n
            var gg = new OpenLayers.Projection("EPSG:4326");\n
            if(!gg.equals(projection)) {\n
                ring = this.clone().transform(projection, gg);\n
            }\n
        }\n
        var area = 0.0;\n
        var len = ring.components && ring.components.length;\n
        if(len > 2) {\n
            var p1, p2;\n
            for(var i=0; i<len-1; i++) {\n
                p1 = ring.components[i];\n
                p2 = ring.components[i+1];\n
                area += OpenLayers.Util.rad(p2.x - p1.x) *\n
                        (2 + Math.sin(OpenLayers.Util.rad(p1.y)) +\n
                        Math.sin(OpenLayers.Util.rad(p2.y)));\n
            }\n
            area = area * 6378137.0 * 6378137.0 / 2.0;\n
        }\n
        return area;\n
    },\n
    \n
    /**\n
     * Method: containsPoint\n
     * Test if a point is inside a linear ring.  For the case where a point\n
     *     is coincident with a linear ring edge, returns 1.  Otherwise,\n
     *     returns boolean.\n
     *\n
     * Parameters:\n
     * point - {<OpenLayers.Geometry.Point>}\n
     *\n
     * Returns:\n
     * {Boolean | Number} The point is inside the linear ring.  Returns 1 if\n
     *     the point is coincident with an edge.  Returns boolean otherwise.\n
     */\n
    containsPoint: function(point) {\n
        var approx = OpenLayers.Number.limitSigDigs;\n
        var digs = 14;\n
        var px = approx(point.x, digs);\n
        var py = approx(point.y, digs);\n
        function getX(y, x1, y1, x2, y2) {\n
            return (y - y2) * ((x2 - x1) / (y2 - y1)) + x2;\n
        }\n
        var numSeg = this.components.length - 1;\n
        var start, end, x1, y1, x2, y2, cx, cy;\n
        var crosses = 0;\n
        for(var i=0; i<numSeg; ++i) {\n
            start = this.components[i];\n
            x1 = approx(start.x, digs);\n
            y1 = approx(start.y, digs);\n
            end = this.components[i + 1];\n
            x2 = approx(end.x, digs);\n
            y2 = approx(end.y, digs);\n
            \n
            /**\n
             * The following conditions enforce five edge-crossing rules:\n
             *    1. points coincident with edges are considered contained;\n
             *    2. an upward edge includes its starting endpoint, and\n
             *    excludes its final endpoint;\n
             *    3. a downward edge excludes its starting endpoint, and\n
             *    includes its final endpoint;\n
             *    4. horizontal edges are excluded; and\n
             *    5. the edge-ray intersection point must be strictly right\n
             *    of the point P.\n
             */\n
            if(y1 == y2) {\n
                // horizontal edge\n
                if(py == y1) {\n
                    // point on horizontal line\n
                    if(x1 <= x2 && (px >= x1 && px <= x2) || // right or vert\n
                       x1 >= x2 && (px <= x1 && px >= x2)) { // left or vert\n
                        // point on edge\n
                        crosses = -1;\n
                        break;\n
                    }\n
                }\n
                // ignore other horizontal edges\n
                continue;\n
            }\n
            cx = approx(getX(py, x1, y1, x2, y2), digs);\n
            if(cx == px) {\n
                // point on line\n
                if(y1 < y2 && (py >= y1 && py <= y2) || // upward\n
                   y1 > y2 && (py <= y1 && py >= y2)) { // downward\n
                    // point on edge\n
                    crosses = -1;\n
                    break;\n
                }\n
            }\n
            if(cx <= px) {\n
                // no crossing to the right\n
                continue;\n
            }\n
            if(x1 != x2 && (cx < Math.min(x1, x2) || cx > Math.max(x1, x2))) {\n
                // no crossing\n
                continue;\n
            }\n
            if(y1 < y2 && (py >= y1 && py < y2) || // upward\n
               y1 > y2 && (py < y1 && py >= y2)) { // downward\n
                ++crosses;\n
            }\n
        }\n
        var contained = (crosses == -1) ?\n
            // on edge\n
            1 :\n
            // even (out) or odd (in)\n
            !!(crosses & 1);\n
\n
        return contained;\n
    },\n
\n
    /**\n
     * APIMethod: intersects\n
     * Determine if the input geometry intersects this one.\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} Any type of geometry.\n
     *\n
     * Returns:\n
     * {Boolean} The input geometry intersects this one.\n
     */\n
    intersects: function(geometry) {\n
        var intersect = false;\n
        if(geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {\n
            intersect = this.containsPoint(geometry);\n
        } else if(geometry.CLASS_NAME == "OpenLayers.Geometry.LineString") {\n
            intersect = geometry.intersects(this);\n
        } else if(geometry.CLASS_NAME == "OpenLayers.Geometry.LinearRing") {\n
            intersect = OpenLayers.Geometry.LineString.prototype.intersects.apply(\n
                this, [geometry]\n
            );\n
        } else {\n
            // check for component intersections\n
            for(var i=0, len=geometry.components.length; i<len; ++ i) {\n
                intersect = geometry.components[i].intersects(this);\n
                if(intersect) {\n
                    break;\n
                }\n
            }\n
        }\n
        return intersect;\n
    },\n
\n
    /**\n
     * APIMethod: getVertices\n
     * Return a list of all points in this geometry.\n
     *\n
     * Parameters:\n
     * nodes - {Boolean} For lines, only return vertices that are\n
     *     endpoints.  If false, for lines, only vertices that are not\n
     *     endpoints will be returned.  If not provided, all vertices will\n
     *     be returned.\n
     *\n
     * Returns:\n
     * {Array} A list of all vertices in the geometry.\n
     */\n
    getVertices: function(nodes) {\n
        return (nodes === true) ? [] : this.components.slice(0, this.components.length-1);\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Geometry.LinearRing"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>14975</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
