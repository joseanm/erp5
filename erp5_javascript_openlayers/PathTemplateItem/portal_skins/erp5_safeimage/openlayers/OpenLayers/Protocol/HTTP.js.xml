<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.82</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>HTTP.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Protocol.js\n
 * @requires OpenLayers/Request/XMLHttpRequest.js\n
 */\n
\n
/**\n
 * if application uses the query string, for example, for BBOX parameters,\n
 * OpenLayers/Format/QueryStringFilter.js should be included in the build config file\n
 */\n
\n
/**\n
 * Class: OpenLayers.Protocol.HTTP\n
 * A basic HTTP protocol for vector layers.  Create a new instance with the\n
 *     <OpenLayers.Protocol.HTTP> constructor.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Protocol>\n
 */\n
OpenLayers.Protocol.HTTP = OpenLayers.Class(OpenLayers.Protocol, {\n
\n
    /**\n
     * Property: url\n
     * {String} Service URL, read-only, set through the options\n
     *     passed to constructor.\n
     */\n
    url: null,\n
\n
    /**\n
     * Property: headers\n
     * {Object} HTTP request headers, read-only, set through the options\n
     *     passed to the constructor,\n
     *     Example: {\'Content-Type\': \'plain/text\'}\n
     */\n
    headers: null,\n
\n
    /**\n
     * Property: params\n
     * {Object} Parameters of GET requests, read-only, set through the options\n
     *     passed to the constructor,\n
     *     Example: {\'bbox\': \'5,5,5,5\'}\n
     */\n
    params: null,\n
    \n
    /**\n
     * Property: callback\n
     * {Object} Function to be called when the <read>, <create>,\n
     *     <update>, <delete> or <commit> operation completes, read-only,\n
     *     set through the options passed to the constructor.\n
     */\n
    callback: null,\n
\n
    /**\n
     * Property: scope\n
     * {Object} Callback execution scope, read-only, set through the\n
     *     options passed to the constructor.\n
     */\n
    scope: null,\n
\n
    /**\n
     * APIProperty: readWithPOST\n
     * {Boolean} true if read operations are done with POST requests\n
     *     instead of GET, defaults to false.\n
     */\n
    readWithPOST: false,\n
\n
    /**\n
     * APIProperty: updateWithPOST\n
     * {Boolean} true if update operations are done with POST requests\n
     *     defaults to false.\n
     */\n
    updateWithPOST: false,\n
    \n
    /**\n
     * APIProperty: deleteWithPOST\n
     * {Boolean} true if delete operations are done with POST requests\n
     *     defaults to false.\n
     *     if true, POST data is set to output of format.write().\n
     */\n
    deleteWithPOST: false,\n
\n
    /**\n
     * Property: wildcarded.\n
     * {Boolean} If true percent signs are added around values\n
     *     read from LIKE filters, for example if the protocol\n
     *     read method is passed a LIKE filter whose property\n
     *     is "foo" and whose value is "bar" the string\n
     *     "foo__ilike=%bar%" will be sent in the query string;\n
     *     defaults to false.\n
     */\n
    wildcarded: false,\n
\n
    /**\n
     * APIProperty: srsInBBOX\n
     * {Boolean} Include the SRS identifier in BBOX query string parameter.  \n
     *     Default is false.  If true and the layer has a projection object set,\n
     *     any BBOX filter will be serialized with a fifth item identifying the\n
     *     projection.  E.g. bbox=-1000,-1000,1000,1000,EPSG:900913\n
     */\n
    srsInBBOX: false,\n
\n
    /**\n
     * Constructor: OpenLayers.Protocol.HTTP\n
     * A class for giving layers generic HTTP protocol.\n
     *\n
     * Parameters:\n
     * options - {Object} Optional object whose properties will be set on the\n
     *     instance.\n
     *\n
     * Valid options include:\n
     * url - {String}\n
     * headers - {Object} \n
     * params - {Object} URL parameters for GET requests\n
     * format - {<OpenLayers.Format>}\n
     * callback - {Function}\n
     * scope - {Object}\n
     */\n
    initialize: function(options) {\n
        options = options || {};\n
        this.params = {};\n
        this.headers = {};\n
        OpenLayers.Protocol.prototype.initialize.apply(this, arguments);\n
\n
        if (!this.filterToParams && OpenLayers.Format.QueryStringFilter) {\n
            var format = new OpenLayers.Format.QueryStringFilter({\n
                wildcarded: this.wildcarded,\n
                srsInBBOX: this.srsInBBOX\n
            });\n
            this.filterToParams = function(filter, params) {\n
                return format.write(filter, params);\n
            };\n
        }\n
    },\n
    \n
    /**\n
     * APIMethod: destroy\n
     * Clean up the protocol.\n
     */\n
    destroy: function() {\n
        this.params = null;\n
        this.headers = null;\n
        OpenLayers.Protocol.prototype.destroy.apply(this);\n
    },\n
\n
    /**\n
     * APIMethod: filterToParams\n
     * Optional method to translate an <OpenLayers.Filter> object into an object\n
     *     that can be serialized as request query string provided.  If a custom\n
     *     method is not provided, the filter will be serialized using the \n
     *     <OpenLayers.Format.QueryStringFilter> class.\n
     *\n
     * Parameters:\n
     * filter - {<OpenLayers.Filter>} filter to convert.\n
     * params - {Object} The parameters object.\n
     *\n
     * Returns:\n
     * {Object} The resulting parameters object.\n
     */\n
    \n
    /**\n
     * APIMethod: read\n
     * Construct a request for reading new features.\n
     *\n
     * Parameters:\n
     * options - {Object} Optional object for configuring the request.\n
     *     This object is modified and should not be reused.\n
     *\n
     * Valid options:\n
     * url - {String} Url for the request.\n
     * params - {Object} Parameters to get serialized as a query string.\n
     * headers - {Object} Headers to be set on the request.\n
     * filter - {<OpenLayers.Filter>} Filter to get serialized as a\n
     *     query string.\n
     * readWithPOST - {Boolean} If the request should be done with POST.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Protocol.Response>} A response object, whose "priv" property\n
     *     references the HTTP request, this object is also passed to the\n
     *     callback function when the request completes, its "features" property\n
     *     is then populated with the features received from the server.\n
     */\n
    read: function(options) {\n
        OpenLayers.Protocol.prototype.read.apply(this, arguments);\n
        options = options || {};\n
        options.params = OpenLayers.Util.applyDefaults(\n
            options.params, this.options.params);\n
        options = OpenLayers.Util.applyDefaults(options, this.options);\n
        if (options.filter && this.filterToParams) {\n
            options.params = this.filterToParams(\n
                options.filter, options.params\n
            );\n
        }\n
        var readWithPOST = (options.readWithPOST !== undefined) ?\n
                           options.readWithPOST : this.readWithPOST;\n
        var resp = new OpenLayers.Protocol.Response({requestType: "read"});\n
        if(readWithPOST) {\n
            var headers = options.headers || {};\n
            headers["Content-Type"] = "application/x-www-form-urlencoded";\n
            resp.priv = OpenLayers.Request.POST({\n
                url: options.url,\n
                callback: this.createCallback(this.handleRead, resp, options),\n
                data: OpenLayers.Util.getParameterString(options.params),\n
                headers: headers\n
            });\n
        } else {\n
            resp.priv = OpenLayers.Request.GET({\n
                url: options.url,\n
                callback: this.createCallback(this.handleRead, resp, options),\n
                params: options.params,\n
                headers: options.headers\n
            });\n
        }\n
        return resp;\n
    },\n
\n
    /**\n
     * Method: handleRead\n
     * Individual callbacks are created for read, create and update, should\n
     *     a subclass need to override each one separately.\n
     *\n
     * Parameters:\n
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to\n
     *     the user callback.\n
     * options - {Object} The user options passed to the read call.\n
     */\n
    handleRead: function(resp, options) {\n
        this.handleResponse(resp, options);\n
    },\n
\n
    /**\n
     * APIMethod: create\n
     * Construct a request for writing newly created features.\n
     *\n
     * Parameters:\n
     * features - {Array({<OpenLayers.Feature.Vector>})} or\n
     *     {<OpenLayers.Feature.Vector>}\n
     * options - {Object} Optional object for configuring the request.\n
     *     This object is modified and should not be reused.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>\n
     *     object, whose "priv" property references the HTTP request, this \n
     *     object is also passed to the callback function when the request\n
     *     completes, its "features" property is then populated with the\n
     *     the features received from the server.\n
     */\n
    create: function(features, options) {\n
        options = OpenLayers.Util.applyDefaults(options, this.options);\n
\n
        var resp = new OpenLayers.Protocol.Response({\n
            reqFeatures: features,\n
            requestType: "create"\n
        });\n
\n
        resp.priv = OpenLayers.Request.POST({\n
            url: options.url,\n
            callback: this.createCallback(this.handleCreate, resp, options),\n
            headers: options.headers,\n
            data: this.format.write(features)\n
        });\n
\n
        return resp;\n
    },\n
\n
    /**\n
     * Method: handleCreate\n
     * Called the the request issued by <create> is complete.  May be overridden\n
     *     by subclasses.\n
     *\n
     * Parameters:\n
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to\n
     *     any user callback.\n
     * options - {Object} The user options passed to the create call.\n
     */\n
    handleCreate: function(resp, options) {\n
        this.handleResponse(resp, options);\n
    },\n
\n
    /**\n
     * APIMethod: update\n
     * Construct a request updating modified feature.\n
     *\n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>}\n
     * options - {Object} Optional object for configuring the request.\n
     *     This object is modified and should not be reused.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>\n
     *     object, whose "priv" property references the HTTP request, this \n
     *     object is also passed to the callback function when the request\n
     *     completes, its "features" property is then populated with the\n
     *     the feature received from the server.\n
     */\n
    update: function(feature, options) {\n
        options = options || {};\n
        var url = options.url ||\n
                  feature.url ||\n
                  this.options.url + "/" + feature.fid;\n
        options = OpenLayers.Util.applyDefaults(options, this.options);\n
\n
        var resp = new OpenLayers.Protocol.Response({\n
            reqFeatures: feature,\n
            requestType: "update"\n
        });\n
\n
        var method = this.updateWithPOST ? "POST" : "PUT";\n
        resp.priv = OpenLayers.Request[method]({\n
            url: url,\n
            callback: this.createCallback(this.handleUpdate, resp, options),\n
            headers: options.headers,\n
            data: this.format.write(feature)\n
        });\n
\n
        return resp;\n
    },\n
\n
    /**\n
     * Method: handleUpdate\n
     * Called the the request issued by <update> is complete.  May be overridden\n
     *     by subclasses.\n
     *\n
     * Parameters:\n
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to\n
     *     any user callback.\n
     * options - {Object} The user options passed to the update call.\n
     */\n
    handleUpdate: function(resp, options) {\n
        this.handleResponse(resp, options);\n
    },\n
\n
    /**\n
     * APIMethod: delete\n
     * Construct a request deleting a removed feature.\n
     *\n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>}\n
     * options - {Object} Optional object for configuring the request.\n
     *     This object is modified and should not be reused.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Protocol.Response>} An <OpenLayers.Protocol.Response>\n
     *     object, whose "priv" property references the HTTP request, this \n
     *     object is also passed to the callback function when the request\n
     *     completes.\n
     */\n
    "delete": function(feature, options) {\n
        options = options || {};\n
        var url = options.url ||\n
                  feature.url ||\n
                  this.options.url + "/" + feature.fid;\n
        options = OpenLayers.Util.applyDefaults(options, this.options);\n
\n
        var resp = new OpenLayers.Protocol.Response({\n
            reqFeatures: feature,\n
            requestType: "delete"\n
        });\n
\n
        var method = this.deleteWithPOST ? "POST" : "DELETE";\n
        var requestOptions = {\n
            url: url,\n
            callback: this.createCallback(this.handleDelete, resp, options),\n
            headers: options.headers\n
        };\n
        if (this.deleteWithPOST) {\n
            requestOptions.data = this.format.write(feature);\n
        }\n
        resp.priv = OpenLayers.Request[method](requestOptions);\n
\n
        return resp;\n
    },\n
\n
    /**\n
     * Method: handleDelete\n
     * Called the the request issued by <delete> is complete.  May be overridden\n
     *     by subclasses.\n
     *\n
     * Parameters:\n
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to\n
     *     any user callback.\n
     * options - {Object} The user options passed to the delete call.\n
     */\n
    handleDelete: function(resp, options) {\n
        this.handleResponse(resp, options);\n
    },\n
\n
    /**\n
     * Method: handleResponse\n
     * Called by CRUD specific handlers.\n
     *\n
     * Parameters:\n
     * resp - {<OpenLayers.Protocol.Response>} The response object to pass to\n
     *     any user callback.\n
     * options - {Object} The user options passed to the create, read, update,\n
     *     or delete call.\n
     */\n
    handleResponse: function(resp, options) {\n
        var request = resp.priv;\n
        if(options.callback) {\n
            if(request.status >= 200 && request.status < 300) {\n
                // success\n
                if(resp.requestType != "delete") {\n
                    resp.features = this.parseFeatures(request);\n
                }\n
                resp.code = OpenLayers.Protocol.Response.SUCCESS;\n
            } else {\n
                // failure\n
                resp.code = OpenLayers.Protocol.Response.FAILURE;\n
            }\n
            options.callback.call(options.scope, resp);\n
        }\n
    },\n
\n
    /**\n
     * Method: parseFeatures\n
     * Read HTTP response body and return features.\n
     *\n
     * Parameters:\n
     * request - {XMLHttpRequest} The request object\n
     *\n
     * Returns:\n
     * {Array({<OpenLayers.Feature.Vector>})} or\n
     *     {<OpenLayers.Feature.Vector>} Array of features or a single feature.\n
     */\n
    parseFeatures: function(request) {\n
        var doc = request.responseXML;\n
        if (!doc || !doc.documentElement) {\n
            doc = request.responseText;\n
        }\n
        if (!doc || doc.length <= 0) {\n
            return null;\n
        }\n
        return this.format.read(doc);\n
    },\n
\n
    /**\n
     * APIMethod: commit\n
     * Iterate over each feature and take action based on the feature state.\n
     *     Possible actions are create, update and delete.\n
     *\n
     * Parameters:\n
     * features - {Array({<OpenLayers.Feature.Vector>})}\n
     * options - {Object} Optional object for setting up intermediate commit\n
     *     callbacks.\n
     *\n
     * Valid options:\n
     * create - {Object} Optional object to be passed to the <create> method.\n
     * update - {Object} Optional object to be passed to the <update> method.\n
     * delete - {Object} Optional object to be passed to the <delete> method.\n
     * callback - {Function} Optional function to be called when the commit\n
     *     is complete.\n
     * scope - {Object} Optional object to be set as the scope of the callback.\n
     *\n
     * Returns:\n
     * {Array(<OpenLayers.Protocol.Response>)} An array of response objects,\n
     *     one per request made to the server, each object\'s "priv" property\n
     *     references the corresponding HTTP request.\n
     */\n
    commit: function(features, options) {\n
        options = OpenLayers.Util.applyDefaults(options, this.options);\n
        var resp = [], nResponses = 0;\n
        \n
        // Divide up features before issuing any requests.  This properly\n
        // counts requests in the event that any responses come in before\n
        // all requests have been issued.\n
        var types = {};\n
        types[OpenLayers.State.INSERT] = [];\n
        types[OpenLayers.State.UPDATE] = [];\n
        types[OpenLayers.State.DELETE] = [];\n
        var feature, list, requestFeatures = [];\n
        for(var i=0, len=features.length; i<len; ++i) {\n
            feature = features[i];\n
            list = types[feature.state];\n
            if(list) {\n
                list.push(feature);\n
                requestFeatures.push(feature); \n
            }\n
        }\n
        // tally up number of requests\n
        var nRequests = (types[OpenLayers.State.INSERT].length > 0 ? 1 : 0) +\n
            types[OpenLayers.State.UPDATE].length +\n
            types[OpenLayers.State.DELETE].length;\n
        \n
        // This response will be sent to the final callback after all the others\n
        // have been fired.\n
        var success = true;\n
        var finalResponse = new OpenLayers.Protocol.Response({\n
            reqFeatures: requestFeatures        \n
        });\n
        \n
        function insertCallback(response) {\n
            var len = response.features ? response.features.length : 0;\n
            var fids = new Array(len);\n
            for(var i=0; i<len; ++i) {\n
                fids[i] = response.features[i].fid;\n
            }   \n
            finalResponse.insertIds = fids;\n
            callback.apply(this, [response]);\n
        }\n
 \n
        function callback(response) {\n
            this.callUserCallback(response, options);\n
            success = success && response.success();\n
            nResponses++;\n
            if (nResponses >= nRequests) {\n
                if (options.callback) {\n
                    finalResponse.code = success ? \n
                        OpenLayers.Protocol.Response.SUCCESS :\n
                        OpenLayers.Protocol.Response.FAILURE;\n
                    options.callback.apply(options.scope, [finalResponse]);\n
                }    \n
            }\n
        }\n
\n
        // start issuing requests\n
        var queue = types[OpenLayers.State.INSERT];\n
        if(queue.length > 0) {\n
            resp.push(this.create(\n
                queue, OpenLayers.Util.applyDefaults(\n
                    {callback: insertCallback, scope: this}, options.create\n
                )\n
            ));\n
        }\n
        queue = types[OpenLayers.State.UPDATE];\n
        for(var i=queue.length-1; i>=0; --i) {\n
            resp.push(this.update(\n
                queue[i], OpenLayers.Util.applyDefaults(\n
                    {callback: callback, scope: this}, options.update\n
                ))\n
            );\n
        }\n
        queue = types[OpenLayers.State.DELETE];\n
        for(var i=queue.length-1; i>=0; --i) {\n
            resp.push(this["delete"](\n
                queue[i], OpenLayers.Util.applyDefaults(\n
                    {callback: callback, scope: this}, options["delete"]\n
                ))\n
            );\n
        }\n
        return resp;\n
    },\n
\n
    /**\n
     * APIMethod: abort\n
     * Abort an ongoing request, the response object passed to\n
     * this method must come from this HTTP protocol (as a result\n
     * of a create, read, update, delete or commit operation).\n
     *\n
     * Parameters:\n
     * response - {<OpenLayers.Protocol.Response>}\n
     */\n
    abort: function(response) {\n
        if (response) {\n
            response.priv.abort();\n
        }\n
    },\n
\n
    /**\n
     * Method: callUserCallback\n
     * This method is used from within the commit method each time an\n
     *     an HTTP response is received from the server, it is responsible\n
     *     for calling the user-supplied callbacks.\n
     *\n
     * Parameters:\n
     * resp - {<OpenLayers.Protocol.Response>}\n
     * options - {Object} The map of options passed to the commit call.\n
     */\n
    callUserCallback: function(resp, options) {\n
        var opt = options[resp.requestType];\n
        if(opt && opt.callback) {\n
            opt.callback.call(opt.scope, resp);\n
        }\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Protocol.HTTP" \n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>20226</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
