<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.82</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Script.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Protocol.js\n
 * @requires OpenLayers/Feature/Vector.js\n
 * @requires OpenLayers/Format/GeoJSON.js\n
 */\n
\n
/**\n
 * if application uses the query string, for example, for BBOX parameters,\n
 * OpenLayers/Format/QueryStringFilter.js should be included in the build config file\n
 */\n
\n
/**\n
 * Class: OpenLayers.Protocol.Script\n
 * A basic Script protocol for vector layers.  Create a new instance with the\n
 *     <OpenLayers.Protocol.Script> constructor.  A script protocol is used to\n
 *     get around the same origin policy.  It works with services that return\n
 *     JSONP - that is, JSON wrapped in a client-specified callback.  The\n
 *     protocol handles fetching and parsing of feature data and sends parsed\n
 *     features to the <callback> configured with the protocol.  The protocol\n
 *     expects features serialized as GeoJSON by default, but can be configured\n
 *     to work with other formats by setting the <format> property.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Protocol>\n
 */\n
OpenLayers.Protocol.Script = OpenLayers.Class(OpenLayers.Protocol, {\n
\n
    /**\n
     * APIProperty: url\n
     * {String} Service URL.  The service is expected to return serialized \n
     *     features wrapped in a named callback (where the callback name is\n
     *     generated by this protocol).\n
     *     Read-only, set through the options passed to the constructor.\n
     */\n
    url: null,\n
\n
    /**\n
     * APIProperty: params\n
     * {Object} Query string parameters to be appended to the URL.\n
     *     Read-only, set through the options passed to the constructor.\n
     *     Example: {maxFeatures: 50}\n
     */\n
    params: null,\n
    \n
    /**\n
     * APIProperty: callback\n
     * {Object} Function to be called when the <read> operation completes.\n
     */\n
    callback: null,\n
\n
    /**\n
     * APIProperty: callbackTemplate\n
     * {String} Template for creating a unique callback function name\n
     * for the registry. Should include ${id}.  The ${id} variable will be\n
     * replaced with a string identifier prefixed with a "c" (e.g. c1, c2).\n
     * Default is "OpenLayers.Protocol.Script.registry.${id}".\n
     */\n
    callbackTemplate: "OpenLayers.Protocol.Script.registry.${id}",\n
\n
    /**\n
     * APIProperty: callbackKey\n
     * {String} The name of the query string parameter that the service \n
     *     recognizes as the callback identifier.  Default is "callback".\n
     *     This key is used to generate the URL for the script.  For example\n
     *     setting <callbackKey> to "myCallback" would result in a URL like \n
     *     http://example.com/?myCallback=...\n
     */\n
    callbackKey: "callback",\n
\n
    /**\n
     * APIProperty: callbackPrefix\n
     * {String} Where a service requires that the callback query string \n
     *     parameter value is prefixed by some string, this value may be set.\n
     *     For example, setting <callbackPrefix> to "foo:" would result in a\n
     *     URL like http://example.com/?callback=foo:...  Default is "".\n
     */\n
    callbackPrefix: "",\n
\n
    /**\n
     * APIProperty: scope\n
     * {Object} Optional ``this`` object for the callback. Read-only, set \n
     *     through the options passed to the constructor.\n
     */\n
    scope: null,\n
\n
    /**\n
     * APIProperty: format\n
     * {<OpenLayers.Format>} Format for parsing features.  Default is an \n
     *     <OpenLayers.Format.GeoJSON> format.  If an alternative is provided,\n
     *     the format\'s read method must take an object and return an array\n
     *     of features.\n
     */\n
    format: null,\n
\n
    /**\n
     * Property: pendingRequests\n
     * {Object} References all pending requests.  Property names are script \n
     *     identifiers and property values are script elements.\n
     */\n
    pendingRequests: null,\n
\n
    /**\n
     * APIProperty: srsInBBOX\n
     * {Boolean} Include the SRS identifier in BBOX query string parameter.\n
     *     Setting this property has no effect if a custom filterToParams method\n
     *     is provided.   Default is false.  If true and the layer has a \n
     *     projection object set, any BBOX filter will be serialized with a \n
     *     fifth item identifying the projection.  \n
     *     E.g. bbox=-1000,-1000,1000,1000,EPSG:900913\n
     */\n
    srsInBBOX: false,\n
\n
    /**\n
     * Constructor: OpenLayers.Protocol.Script\n
     * A class for giving layers generic Script protocol.\n
     *\n
     * Parameters:\n
     * options - {Object} Optional object whose properties will be set on the\n
     *     instance.\n
     *\n
     * Valid options include:\n
     * url - {String}\n
     * params - {Object}\n
     * callback - {Function}\n
     * scope - {Object}\n
     */\n
    initialize: function(options) {\n
        options = options || {};\n
        this.params = {};\n
        this.pendingRequests = {};\n
        OpenLayers.Protocol.prototype.initialize.apply(this, arguments);\n
        if (!this.format) {\n
            this.format = new OpenLayers.Format.GeoJSON();\n
        }\n
\n
        if (!this.filterToParams && OpenLayers.Format.QueryStringFilter) {\n
            var format = new OpenLayers.Format.QueryStringFilter({\n
                srsInBBOX: this.srsInBBOX\n
            });\n
            this.filterToParams = function(filter, params) {\n
                return format.write(filter, params);\n
            };\n
        }\n
    },\n
    \n
    /**\n
     * APIMethod: read\n
     * Construct a request for reading new features.\n
     *\n
     * Parameters:\n
     * options - {Object} Optional object for configuring the request.\n
     *     This object is modified and should not be reused.\n
     *\n
     * Valid options:\n
     * url - {String} Url for the request.\n
     * params - {Object} Parameters to get serialized as a query string.\n
     * filter - {<OpenLayers.Filter>} Filter to get serialized as a\n
     *     query string.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Protocol.Response>} A response object, whose "priv" property\n
     *     references the injected script.  This object is also passed to the\n
     *     callback function when the request completes, its "features" property\n
     *     is then populated with the features received from the server.\n
     */\n
    read: function(options) {\n
        OpenLayers.Protocol.prototype.read.apply(this, arguments);\n
        options = OpenLayers.Util.applyDefaults(options, this.options);\n
        options.params = OpenLayers.Util.applyDefaults(\n
            options.params, this.options.params\n
        );\n
        if (options.filter && this.filterToParams) {\n
            options.params = this.filterToParams(\n
                options.filter, options.params\n
            );\n
        }\n
        var response = new OpenLayers.Protocol.Response({requestType: "read"});\n
        var request = this.createRequest(\n
            options.url, \n
            options.params, \n
            OpenLayers.Function.bind(function(data) {\n
                response.data = data;\n
                this.handleRead(response, options);\n
            }, this)\n
        );\n
        response.priv = request;\n
        return response;\n
    },\n
\n
    /** \n
     * APIMethod: filterToParams \n
     * Optional method to translate an <OpenLayers.Filter> object into an object \n
     *     that can be serialized as request query string provided.  If a custom \n
     *     method is not provided, any filter will not be serialized. \n
     * \n
     * Parameters: \n
     * filter - {<OpenLayers.Filter>} filter to convert. \n
     * params - {Object} The parameters object. \n
     * \n
     * Returns: \n
     * {Object} The resulting parameters object. \n
     */\n
\n
    /** \n
     * Method: createRequest\n
     * Issues a request for features by creating injecting a script in the \n
     *     document head.\n
     *\n
     * Parameters:\n
     * url - {String} Service URL.\n
     * params - {Object} Query string parameters.\n
     * callback - {Function} Callback to be called with resulting data.\n
     *\n
     * Returns:\n
     * {HTMLScriptElement} The script pending execution.\n
     */\n
    createRequest: function(url, params, callback) {\n
        var id = OpenLayers.Protocol.Script.register(callback);\n
        var name = OpenLayers.String.format(this.callbackTemplate, {id: id});\n
        params = OpenLayers.Util.extend({}, params);\n
        params[this.callbackKey] = this.callbackPrefix + name;\n
        url = OpenLayers.Util.urlAppend(\n
            url, OpenLayers.Util.getParameterString(params)\n
        );\n
        var script = document.createElement("script");\n
        script.type = "text/javascript";\n
        script.src = url;\n
        script.id = "OpenLayers_Protocol_Script_" + id;\n
        this.pendingRequests[script.id] = script;\n
        var head = document.getElementsByTagName("head")[0];\n
        head.appendChild(script);\n
        return script;\n
    },\n
    \n
    /** \n
     * Method: destroyRequest\n
     * Remove a script node associated with a response from the document.  Also\n
     *     unregisters the callback and removes the script from the \n
     *     <pendingRequests> object.\n
     *\n
     * Parameters:\n
     * script - {HTMLScriptElement}\n
     */\n
    destroyRequest: function(script) {\n
        OpenLayers.Protocol.Script.unregister(script.id.split("_").pop());\n
        delete this.pendingRequests[script.id];\n
        if (script.parentNode) {\n
            script.parentNode.removeChild(script);\n
        }\n
    },\n
\n
    /**\n
     * Method: handleRead\n
     * Individual callbacks are created for read, create and update, should\n
     *     a subclass need to override each one separately.\n
     *\n
     * Parameters:\n
     * response - {<OpenLayers.Protocol.Response>} The response object to pass to\n
     *     the user callback.\n
     * options - {Object} The user options passed to the read call.\n
     */\n
    handleRead: function(response, options) {\n
        this.handleResponse(response, options);\n
    },\n
\n
    /**\n
     * Method: handleResponse\n
     * Called by CRUD specific handlers.\n
     *\n
     * Parameters:\n
     * response - {<OpenLayers.Protocol.Response>} The response object to pass to\n
     *     any user callback.\n
     * options - {Object} The user options passed to the create, read, update,\n
     *     or delete call.\n
     */\n
    handleResponse: function(response, options) {\n
        if (options.callback) {\n
            if (response.data) {\n
                response.features = this.parseFeatures(response.data);\n
                response.code = OpenLayers.Protocol.Response.SUCCESS;\n
            } else {\n
                response.code = OpenLayers.Protocol.Response.FAILURE;\n
            }\n
            this.destroyRequest(response.priv);\n
            options.callback.call(options.scope, response);\n
        }\n
    },\n
\n
    /**\n
     * Method: parseFeatures\n
     * Read Script response body and return features.\n
     *\n
     * Parameters:\n
     * data - {Object} The data sent to the callback function by the server.\n
     *\n
     * Returns:\n
     * {Array({<OpenLayers.Feature.Vector>})} or\n
     *     {<OpenLayers.Feature.Vector>} Array of features or a single feature.\n
     */\n
    parseFeatures: function(data) {\n
        return this.format.read(data);\n
    },\n
\n
    /**\n
     * APIMethod: abort\n
     * Abort an ongoing request.  If no response is provided, all pending \n
     *     requests will be aborted.\n
     *\n
     * Parameters:\n
     * response - {<OpenLayers.Protocol.Response>} The response object returned\n
     *     from a <read> request.\n
     */\n
    abort: function(response) {\n
        if (response) {\n
            this.destroyRequest(response.priv);\n
        } else {\n
            for (var key in this.pendingRequests) {\n
                this.destroyRequest(this.pendingRequests[key]);\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * APIMethod: destroy\n
     * Clean up the protocol.\n
     */\n
    destroy: function() {\n
        this.abort();\n
        delete this.params;\n
        delete this.format;\n
        OpenLayers.Protocol.prototype.destroy.apply(this);\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Protocol.Script" \n
});\n
\n
(function() {\n
    var o = OpenLayers.Protocol.Script;\n
    var counter = 0;\n
    o.registry = {};\n
    \n
    /**\n
     * Function: OpenLayers.Protocol.Script.register\n
     * Register a callback for a newly created script.\n
     *\n
     * Parameters:\n
     * callback - {Function} The callback to be executed when the newly added\n
     *     script loads.  This callback will be called with a single argument\n
     *     that is the JSON returned by the service.\n
     *\n
     * Returns:\n
     * {Number} An identifier for retrieving the registered callback.\n
     */\n
    o.register = function(callback) {\n
        var id = "c"+(++counter);\n
        o.registry[id] = function() {\n
            callback.apply(this, arguments);\n
        };\n
        return id;\n
    };\n
    \n
    /**\n
     * Function: OpenLayers.Protocol.Script.unregister\n
     * Unregister a callback previously registered with the register function.\n
     *\n
     * Parameters:\n
     * id - {Number} The identifer returned by the register function.\n
     */\n
    o.unregister = function(id) {\n
        delete o.registry[id];\n
    };\n
})();\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>13112</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
