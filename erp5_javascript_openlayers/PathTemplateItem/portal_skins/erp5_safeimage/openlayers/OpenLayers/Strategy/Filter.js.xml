<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.88</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Filter.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Strategy.js\n
 * @requires OpenLayers/Filter.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Strategy.Filter\n
 * Strategy for limiting features that get added to a layer by \n
 *     evaluating a filter.  The strategy maintains a cache of\n
 *     all features until removeFeatures is called on the layer.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Strategy>\n
 */\n
OpenLayers.Strategy.Filter = OpenLayers.Class(OpenLayers.Strategy, {\n
    \n
    /**\n
     * APIProperty: filter\n
     * {<OpenLayers.Filter>}  Filter for limiting features sent to the layer.\n
     *     Use the <setFilter> method to update this filter after construction.\n
     */\n
    filter: null,\n
    \n
    /**\n
     * Property: cache\n
     * {Array(<OpenLayers.Feature.Vector>)} List of currently cached\n
     *     features.\n
     */\n
    cache: null,\n
    \n
    /**\n
     * Property: caching\n
     * {Boolean} The filter is currently caching features.\n
     */\n
    caching: false,\n
    \n
    /**\n
     * Constructor: OpenLayers.Strategy.Filter\n
     * Create a new filter strategy.\n
     *\n
     * Parameters:\n
     * options - {Object} Optional object whose properties will be set on the\n
     *     instance.\n
     */\n
\n
    /**\n
     * APIMethod: activate\n
     * Activate the strategy.  Register any listeners, do appropriate setup.\n
     *     By default, this strategy automatically activates itself when a layer\n
     *     is added to a map.\n
     *\n
     * Returns:\n
     * {Boolean} True if the strategy was successfully activated or false if\n
     *      the strategy was already active.\n
     */\n
    activate: function() {\n
        var activated = OpenLayers.Strategy.prototype.activate.apply(this, arguments);\n
        if (activated) {\n
            this.cache = [];\n
            this.layer.events.on({\n
                "beforefeaturesadded": this.handleAdd,\n
                "beforefeaturesremoved": this.handleRemove,\n
                scope: this\n
            });\n
        }\n
        return activated;\n
    },\n
    \n
    /**\n
     * APIMethod: deactivate\n
     * Deactivate the strategy.  Clear the feature cache.\n
     *\n
     * Returns:\n
     * {Boolean} True if the strategy was successfully deactivated or false if\n
     *      the strategy was already inactive.\n
     */\n
    deactivate: function() {\n
        this.cache = null;\n
        if (this.layer && this.layer.events) {\n
            this.layer.events.un({\n
                "beforefeaturesadded": this.handleAdd,\n
                "beforefeaturesremoved": this.handleRemove,\n
                scope: this\n
            });            \n
        }\n
        return OpenLayers.Strategy.prototype.deactivate.apply(this, arguments);\n
    },\n
    \n
    /**\n
     * Method: handleAdd\n
     */\n
    handleAdd: function(event) {\n
        if (!this.caching && this.filter) {\n
            var features = event.features;\n
            event.features = [];\n
            var feature;\n
            for (var i=0, ii=features.length; i<ii; ++i) {\n
                feature = features[i];\n
                if (this.filter.evaluate(feature)) {\n
                    event.features.push(feature);\n
                } else {\n
                    this.cache.push(feature);\n
                }\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: handleRemove\n
     */\n
    handleRemove: function(event) {\n
        if (!this.caching) {\n
            this.cache = [];\n
        }\n
    },\n
\n
    /** \n
     * APIMethod: setFilter\n
     * Update the filter for this strategy.  This will re-evaluate\n
     *     any features on the layer and in the cache.  Only features\n
     *     for which filter.evalute(feature) returns true will be\n
     *     added to the layer.  Others will be cached by the strategy.\n
     *\n
     * Parameters:\n
     * filter - {<OpenLayers.Filter>} A filter for evaluating features.\n
     */\n
    setFilter: function(filter) {\n
        this.filter = filter;\n
        var previousCache = this.cache;\n
        this.cache = [];\n
        // look through layer for features to remove from layer\n
        this.handleAdd({features: this.layer.features});\n
        // cache now contains features to remove from layer\n
        if (this.cache.length > 0) {\n
            this.caching = true;\n
            this.layer.removeFeatures(this.cache.slice());\n
            this.caching = false;\n
        }\n
        // now look through previous cache for features to add to layer\n
        if (previousCache.length > 0) {\n
            var event = {features: previousCache};\n
            this.handleAdd(event);\n
            if (event.features.length > 0) {\n
                // event has features to add to layer\n
                this.caching = true;\n
                this.layer.addFeatures(event.features);\n
                this.caching = false;\n
            }\n
        }\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Strategy.Filter"\n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>4979</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
