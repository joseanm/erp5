<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.77</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>BaseTypes.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/SingleFile.js\n
 */\n
\n
/** \n
 * Header: OpenLayers Base Types\n
 * OpenLayers custom string, number and function functions are described here.\n
 */\n
\n
/**\n
 * Namespace: OpenLayers.String\n
 * Contains convenience functions for string manipulation.\n
 */\n
OpenLayers.String = {\n
\n
    /**\n
     * APIFunction: startsWith\n
     * Test whether a string starts with another string. \n
     * \n
     * Parameters:\n
     * str - {String} The string to test.\n
     * sub - {String} The substring to look for.\n
     *  \n
     * Returns:\n
     * {Boolean} The first string starts with the second.\n
     */\n
    startsWith: function(str, sub) {\n
        return (str.indexOf(sub) == 0);\n
    },\n
\n
    /**\n
     * APIFunction: contains\n
     * Test whether a string contains another string.\n
     * \n
     * Parameters:\n
     * str - {String} The string to test.\n
     * sub - {String} The substring to look for.\n
     * \n
     * Returns:\n
     * {Boolean} The first string contains the second.\n
     */\n
    contains: function(str, sub) {\n
        return (str.indexOf(sub) != -1);\n
    },\n
    \n
    /**\n
     * APIFunction: trim\n
     * Removes leading and trailing whitespace characters from a string.\n
     * \n
     * Parameters:\n
     * str - {String} The (potentially) space padded string.  This string is not\n
     *     modified.\n
     * \n
     * Returns:\n
     * {String} A trimmed version of the string with all leading and \n
     *     trailing spaces removed.\n
     */\n
    trim: function(str) {\n
        return str.replace(/^\\s\\s*/, \'\').replace(/\\s\\s*$/, \'\');\n
    },\n
    \n
    /**\n
     * APIFunction: camelize\n
     * Camel-case a hyphenated string. \n
     *     Ex. "chicken-head" becomes "chickenHead", and\n
     *     "-chicken-head" becomes "ChickenHead".\n
     *\n
     * Parameters:\n
     * str - {String} The string to be camelized.  The original is not modified.\n
     * \n
     * Returns:\n
     * {String} The string, camelized\n
     */\n
    camelize: function(str) {\n
        var oStringList = str.split(\'-\');\n
        var camelizedString = oStringList[0];\n
        for (var i=1, len=oStringList.length; i<len; i++) {\n
            var s = oStringList[i];\n
            camelizedString += s.charAt(0).toUpperCase() + s.substring(1);\n
        }\n
        return camelizedString;\n
    },\n
    \n
    /**\n
     * APIFunction: format\n
     * Given a string with tokens in the form ${token}, return a string\n
     *     with tokens replaced with properties from the given context\n
     *     object.  Represent a literal "${" by doubling it, e.g. "${${".\n
     *\n
     * Parameters:\n
     * template - {String} A string with tokens to be replaced.  A template\n
     *     has the form "literal ${token}" where the token will be replaced\n
     *     by the value of context["token"].\n
     * context - {Object} An optional object with properties corresponding\n
     *     to the tokens in the format string.  If no context is sent, the\n
     *     window object will be used.\n
     * args - {Array} Optional arguments to pass to any functions found in\n
     *     the context.  If a context property is a function, the token\n
     *     will be replaced by the return from the function called with\n
     *     these arguments.\n
     *\n
     * Returns:\n
     * {String} A string with tokens replaced from the context object.\n
     */\n
    format: function(template, context, args) {\n
        if(!context) {\n
            context = window;\n
        }\n
\n
        // Example matching: \n
        // str   = ${foo.bar}\n
        // match = foo.bar\n
        var replacer = function(str, match) {\n
            var replacement;\n
\n
            // Loop through all subs. Example: ${a.b.c}\n
            // 0 -> replacement = context[a];\n
            // 1 -> replacement = context[a][b];\n
            // 2 -> replacement = context[a][b][c];\n
            var subs = match.split(/\\.+/);\n
            for (var i=0; i< subs.length; i++) {\n
                if (i == 0) {\n
                    replacement = context;\n
                }\n
\n
                replacement = replacement[subs[i]];\n
            }\n
\n
            if(typeof replacement == "function") {\n
                replacement = args ?\n
                    replacement.apply(null, args) :\n
                    replacement();\n
            }\n
\n
            // If replacement is undefined, return the string \'undefined\'.\n
            // This is a workaround for a bugs in browsers not properly \n
            // dealing with non-participating groups in regular expressions:\n
            // http://blog.stevenlevithan.com/archives/npcg-javascript\n
            if (typeof replacement == \'undefined\') {\n
                return \'undefined\';\n
            } else {\n
                return replacement; \n
            }\n
        };\n
\n
        return template.replace(OpenLayers.String.tokenRegEx, replacer);\n
    },\n
\n
    /**\n
     * Property: tokenRegEx\n
     * Used to find tokens in a string.\n
     * Examples: ${a}, ${a.b.c}, ${a-b}, ${5}\n
     */\n
    tokenRegEx:  /\\$\\{([\\w.]+?)\\}/g,\n
    \n
    /**\n
     * Property: numberRegEx\n
     * Used to test strings as numbers.\n
     */\n
    numberRegEx: /^([+-]?)(?=\\d|\\.\\d)\\d*(\\.\\d*)?([Ee]([+-]?\\d+))?$/,\n
    \n
    /**\n
     * APIFunction: isNumeric\n
     * Determine whether a string contains only a numeric value.\n
     *\n
     * Examples:\n
     * (code)\n
     * OpenLayers.String.isNumeric("6.02e23") // true\n
     * OpenLayers.String.isNumeric("12 dozen") // false\n
     * OpenLayers.String.isNumeric("4") // true\n
     * OpenLayers.String.isNumeric(" 4 ") // false\n
     * (end)\n
     *\n
     * Returns:\n
     * {Boolean} String contains only a number.\n
     */\n
    isNumeric: function(value) {\n
        return OpenLayers.String.numberRegEx.test(value);\n
    },\n
    \n
    /**\n
     * APIFunction: numericIf\n
     * Converts a string that appears to be a numeric value into a number.\n
     * \n
     * Parameters:\n
     * value - {String}\n
     *\n
     * Returns:\n
     * {Number|String} a Number if the passed value is a number, a String\n
     *     otherwise. \n
     */\n
    numericIf: function(value) {\n
        return OpenLayers.String.isNumeric(value) ? parseFloat(value) : value;\n
    }\n
\n
};\n
\n
/**\n
 * Namespace: OpenLayers.Number\n
 * Contains convenience functions for manipulating numbers.\n
 */\n
OpenLayers.Number = {\n
\n
    /**\n
     * Property: decimalSeparator\n
     * Decimal separator to use when formatting numbers.\n
     */\n
    decimalSeparator: ".",\n
    \n
    /**\n
     * Property: thousandsSeparator\n
     * Thousands separator to use when formatting numbers.\n
     */\n
    thousandsSeparator: ",",\n
    \n
    /**\n
     * APIFunction: limitSigDigs\n
     * Limit the number of significant digits on a float.\n
     * \n
     * Parameters:\n
     * num - {Float}\n
     * sig - {Integer}\n
     * \n
     * Returns:\n
     * {Float} The number, rounded to the specified number of significant\n
     *     digits.\n
     */\n
    limitSigDigs: function(num, sig) {\n
        var fig = 0;\n
        if (sig > 0) {\n
            fig = parseFloat(num.toPrecision(sig));\n
        }\n
        return fig;\n
    },\n
    \n
    /**\n
     * APIFunction: format\n
     * Formats a number for output.\n
     * \n
     * Parameters:\n
     * num  - {Float}\n
     * dec  - {Integer} Number of decimal places to round to.\n
     *        Defaults to 0. Set to null to leave decimal places unchanged.\n
     * tsep - {String} Thousands separator.\n
     *        Default is ",".\n
     * dsep - {String} Decimal separator.\n
     *        Default is ".".\n
     *\n
     * Returns:\n
     * {String} A string representing the formatted number.\n
     */\n
    format: function(num, dec, tsep, dsep) {\n
        dec = (typeof dec != "undefined") ? dec : 0; \n
        tsep = (typeof tsep != "undefined") ? tsep :\n
            OpenLayers.Number.thousandsSeparator; \n
        dsep = (typeof dsep != "undefined") ? dsep :\n
            OpenLayers.Number.decimalSeparator;\n
\n
        if (dec != null) {\n
            num = parseFloat(num.toFixed(dec));\n
        }\n
\n
        var parts = num.toString().split(".");\n
        if (parts.length == 1 && dec == null) {\n
            // integer where we do not want to touch the decimals\n
            dec = 0;\n
        }\n
        \n
        var integer = parts[0];\n
        if (tsep) {\n
            var thousands = /(-?[0-9]+)([0-9]{3})/; \n
            while(thousands.test(integer)) { \n
                integer = integer.replace(thousands, "$1" + tsep + "$2"); \n
            }\n
        }\n
        \n
        var str;\n
        if (dec == 0) {\n
            str = integer;\n
        } else {\n
            var rem = parts.length > 1 ? parts[1] : "0";\n
            if (dec != null) {\n
                rem = rem + new Array(dec - rem.length + 1).join("0");\n
            }\n
            str = integer + dsep + rem;\n
        }\n
        return str;\n
    }\n
};\n
\n
/**\n
 * Namespace: OpenLayers.Function\n
 * Contains convenience functions for function manipulation.\n
 */\n
OpenLayers.Function = {\n
    /**\n
     * APIFunction: bind\n
     * Bind a function to an object.  Method to easily create closures with\n
     *     \'this\' altered.\n
     * \n
     * Parameters:\n
     * func - {Function} Input function.\n
     * object - {Object} The object to bind to the input function (as this).\n
     * \n
     * Returns:\n
     * {Function} A closure with \'this\' set to the passed in object.\n
     */\n
    bind: function(func, object) {\n
        // create a reference to all arguments past the second one\n
        var args = Array.prototype.slice.apply(arguments, [2]);\n
        return function() {\n
            // Push on any additional arguments from the actual function call.\n
            // These will come after those sent to the bind call.\n
            var newArgs = args.concat(\n
                Array.prototype.slice.apply(arguments, [0])\n
            );\n
            return func.apply(object, newArgs);\n
        };\n
    },\n
    \n
    /**\n
     * APIFunction: bindAsEventListener\n
     * Bind a function to an object, and configure it to receive the event\n
     *     object as first parameter when called. \n
     * \n
     * Parameters:\n
     * func - {Function} Input function to serve as an event listener.\n
     * object - {Object} A reference to this.\n
     * \n
     * Returns:\n
     * {Function}\n
     */\n
    bindAsEventListener: function(func, object) {\n
        return function(event) {\n
            return func.call(object, event || window.event);\n
        };\n
    },\n
    \n
    /**\n
     * APIFunction: False\n
     * A simple function to that just does "return false". We use this to \n
     * avoid attaching anonymous functions to DOM event handlers, which \n
     * causes "issues" on IE<8.\n
     * \n
     * Usage:\n
     * document.onclick = OpenLayers.Function.False;\n
     * \n
     * Returns:\n
     * {Boolean}\n
     */\n
    False : function() {\n
        return false;\n
    },\n
\n
    /**\n
     * APIFunction: True\n
     * A simple function to that just does "return true". We use this to \n
     * avoid attaching anonymous functions to DOM event handlers, which \n
     * causes "issues" on IE<8.\n
     * \n
     * Usage:\n
     * document.onclick = OpenLayers.Function.True;\n
     * \n
     * Returns:\n
     * {Boolean}\n
     */\n
    True : function() {\n
        return true;\n
    },\n
    \n
    /**\n
     * APIFunction: Void\n
     * A reusable function that returns ``undefined``.\n
     *\n
     * Returns:\n
     * {undefined}\n
     */\n
    Void: function() {}\n
\n
};\n
\n
/**\n
 * Namespace: OpenLayers.Array\n
 * Contains convenience functions for array manipulation.\n
 */\n
OpenLayers.Array = {\n
\n
    /**\n
     * APIMethod: filter\n
     * Filter an array.  Provides the functionality of the\n
     *     Array.prototype.filter extension to the ECMA-262 standard.  Where\n
     *     available, Array.prototype.filter will be used.\n
     *\n
     * Based on well known example from http://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/Array/filter\n
     *\n
     * Parameters:\n
     * array - {Array} The array to be filtered.  This array is not mutated.\n
     *     Elements added to this array by the callback will not be visited.\n
     * callback - {Function} A function that is called for each element in\n
     *     the array.  If this function returns true, the element will be\n
     *     included in the return.  The function will be called with three\n
     *     arguments: the element in the array, the index of that element, and\n
     *     the array itself.  If the optional caller parameter is specified\n
     *     the callback will be called with this set to caller.\n
     * caller - {Object} Optional object to be set as this when the callback\n
     *     is called.\n
     *\n
     * Returns:\n
     * {Array} An array of elements from the passed in array for which the\n
     *     callback returns true.\n
     */\n
    filter: function(array, callback, caller) {\n
        var selected = [];\n
        if (Array.prototype.filter) {\n
            selected = array.filter(callback, caller);\n
        } else {\n
            var len = array.length;\n
            if (typeof callback != "function") {\n
                throw new TypeError();\n
            }\n
            for(var i=0; i<len; i++) {\n
                if (i in array) {\n
                    var val = array[i];\n
                    if (callback.call(caller, val, i, array)) {\n
                        selected.push(val);\n
                    }\n
                }\n
            }        \n
        }\n
        return selected;\n
    }\n
    \n
};\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>13356</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
