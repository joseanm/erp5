<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.83</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Framed.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Popup/Anchored.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Popup.Framed\n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Popup.Anchored>\n
 */\n
OpenLayers.Popup.Framed =\n
  OpenLayers.Class(OpenLayers.Popup.Anchored, {\n
\n
    /**\n
     * Property: imageSrc\n
     * {String} location of the image to be used as the popup frame\n
     */\n
    imageSrc: null,\n
\n
    /**\n
     * Property: imageSize\n
     * {<OpenLayers.Size>} Size (measured in pixels) of the image located\n
     *     by the \'imageSrc\' property.\n
     */\n
    imageSize: null,\n
\n
    /**\n
     * APIProperty: isAlphaImage\n
     * {Boolean} The image has some alpha and thus needs to use the alpha \n
     *     image hack. Note that setting this to true will have no noticeable\n
     *     effect in FF or IE7 browsers, but will all but crush the ie6 \n
     *     browser. \n
     *     Default is false.\n
     */\n
    isAlphaImage: false,\n
\n
    /**\n
     * Property: positionBlocks\n
     * {Object} Hash of different position blocks (Object/Hashs). Each block \n
     *     will be keyed by a two-character \'relativePosition\' \n
     *     code string (ie "tl", "tr", "bl", "br"). Block properties are \n
     *     \'offset\', \'padding\' (self-explanatory), and finally the \'blocks\'\n
     *     parameter, which is an array of the block objects. \n
     * \n
     *     Each block object must have \'size\', \'anchor\', and \'position\' \n
     *     properties.\n
     * \n
     *     Note that positionBlocks should never be modified at runtime.\n
     */\n
    positionBlocks: null,\n
\n
    /**\n
     * Property: blocks\n
     * {Array[Object]} Array of objects, each of which is one "block" of the \n
     *     popup. Each block has a \'div\' and an \'image\' property, both of \n
     *     which are DOMElements, and the latter of which is appended to the \n
     *     former. These are reused as the popup goes changing positions for\n
     *     great economy and elegance.\n
     */\n
    blocks: null,\n
\n
    /** \n
     * APIProperty: fixedRelativePosition\n
     * {Boolean} We want the framed popup to work dynamically placed relative\n
     *     to its anchor but also in just one fixed position. A well designed\n
     *     framed popup will have the pixels and logic to display itself in \n
     *     any of the four relative positions, but (understandably), this will\n
     *     not be the case for all of them. By setting this property to \'true\', \n
     *     framed popup will not recalculate for the best placement each time\n
     *     it\'s open, but will always open the same way. \n
     *     Note that if this is set to true, it is generally advisable to also\n
     *     set the \'panIntoView\' property to true so that the popup can be \n
     *     scrolled into view (since it will often be offscreen on open)\n
     *     Default is false.\n
     */\n
    fixedRelativePosition: false,\n
\n
    /** \n
     * Constructor: OpenLayers.Popup.Framed\n
     * \n
     * Parameters:\n
     * id - {String}\n
     * lonlat - {<OpenLayers.LonLat>}\n
     * contentSize - {<OpenLayers.Size>}\n
     * contentHTML - {String}\n
     * anchor - {Object} Object to which we\'ll anchor the popup. Must expose \n
     *     a \'size\' (<OpenLayers.Size>) and \'offset\' (<OpenLayers.Pixel>) \n
     *     (Note that this is generally an <OpenLayers.Icon>).\n
     * closeBox - {Boolean}\n
     * closeBoxCallback - {Function} Function to be called on closeBox click.\n
     */\n
    initialize:function(id, lonlat, contentSize, contentHTML, anchor, closeBox, \n
                        closeBoxCallback) {\n
\n
        OpenLayers.Popup.Anchored.prototype.initialize.apply(this, arguments);\n
\n
        if (this.fixedRelativePosition) {\n
            //based on our decided relativePostion, set the current padding\n
            // this keeps us from getting into trouble \n
            this.updateRelativePosition();\n
            \n
            //make calculateRelativePosition always return the specified\n
            // fixed position.\n
            this.calculateRelativePosition = function(px) {\n
                return this.relativePosition;\n
            };\n
        }\n
\n
        this.contentDiv.style.position = "absolute";\n
        this.contentDiv.style.zIndex = 1;\n
\n
        if (closeBox) {\n
            this.closeDiv.style.zIndex = 1;\n
        }\n
\n
        this.groupDiv.style.position = "absolute";\n
        this.groupDiv.style.top = "0px";\n
        this.groupDiv.style.left = "0px";\n
        this.groupDiv.style.height = "100%";\n
        this.groupDiv.style.width = "100%";\n
    },\n
\n
    /** \n
     * APIMethod: destroy\n
     */\n
    destroy: function() {\n
        this.imageSrc = null;\n
        this.imageSize = null;\n
        this.isAlphaImage = null;\n
\n
        this.fixedRelativePosition = false;\n
        this.positionBlocks = null;\n
\n
        //remove our blocks\n
        for(var i = 0; i < this.blocks.length; i++) {\n
            var block = this.blocks[i];\n
\n
            if (block.image) {\n
                block.div.removeChild(block.image);\n
            }\n
            block.image = null;\n
\n
            if (block.div) {\n
                this.groupDiv.removeChild(block.div);\n
            }\n
            block.div = null;\n
        }\n
        this.blocks = null;\n
\n
        OpenLayers.Popup.Anchored.prototype.destroy.apply(this, arguments);\n
    },\n
\n
    /**\n
     * APIMethod: setBackgroundColor\n
     */\n
    setBackgroundColor:function(color) {\n
        //does nothing since the framed popup\'s entire scheme is based on a \n
        // an image -- changing the background color makes no sense. \n
    },\n
\n
    /**\n
     * APIMethod: setBorder\n
     */\n
    setBorder:function() {\n
        //does nothing since the framed popup\'s entire scheme is based on a \n
        // an image -- changing the popup\'s border makes no sense. \n
    },\n
\n
    /**\n
     * Method: setOpacity\n
     * Sets the opacity of the popup.\n
     * \n
     * Parameters:\n
     * opacity - {float} A value between 0.0 (transparent) and 1.0 (solid).   \n
     */\n
    setOpacity:function(opacity) {\n
        //does nothing since we suppose that we\'ll never apply an opacity\n
        // to a framed popup\n
    },\n
\n
    /**\n
     * APIMethod: setSize\n
     * Overridden here, because we need to update the blocks whenever the size\n
     *     of the popup has changed.\n
     * \n
     * Parameters:\n
     * contentSize - {<OpenLayers.Size>} the new size for the popup\'s \n
     *     contents div (in pixels).\n
     */\n
    setSize:function(contentSize) { \n
        OpenLayers.Popup.Anchored.prototype.setSize.apply(this, arguments);\n
\n
        this.updateBlocks();\n
    },\n
\n
    /**\n
     * Method: updateRelativePosition\n
     * When the relative position changes, we need to set the new padding \n
     *     BBOX on the popup, reposition the close div, and update the blocks.\n
     */\n
    updateRelativePosition: function() {\n
\n
        //update the padding\n
        this.padding = this.positionBlocks[this.relativePosition].padding;\n
\n
        //update the position of our close box to new padding\n
        if (this.closeDiv) {\n
            // use the content div\'s css padding to determine if we should\n
            //  padd the close div\n
            var contentDivPadding = this.getContentDivPadding();\n
\n
            this.closeDiv.style.right = contentDivPadding.right + \n
                                        this.padding.right + "px";\n
            this.closeDiv.style.top = contentDivPadding.top + \n
                                      this.padding.top + "px";\n
        }\n
\n
        this.updateBlocks();\n
    },\n
\n
    /** \n
     * Method: calculateNewPx\n
     * Besides the standard offset as determined by the Anchored class, our \n
     *     Framed popups have a special \'offset\' property for each of their \n
     *     positions, which is used to offset the popup relative to its anchor.\n
     * \n
     * Parameters:\n
     * px - {<OpenLayers.Pixel>}\n
     * \n
     * Returns:\n
     * {<OpenLayers.Pixel>} The the new px position of the popup on the screen\n
     *     relative to the passed-in px.\n
     */\n
    calculateNewPx:function(px) {\n
        var newPx = OpenLayers.Popup.Anchored.prototype.calculateNewPx.apply(\n
            this, arguments\n
        );\n
\n
        newPx = newPx.offset(this.positionBlocks[this.relativePosition].offset);\n
\n
        return newPx;\n
    },\n
\n
    /**\n
     * Method: createBlocks\n
     */\n
    createBlocks: function() {\n
        this.blocks = [];\n
\n
        //since all positions contain the same number of blocks, we can \n
        // just pick the first position and use its blocks array to create\n
        // our blocks array\n
        var firstPosition = null;\n
        for(var key in this.positionBlocks) {\n
            firstPosition = key;\n
            break;\n
        }\n
        \n
        var position = this.positionBlocks[firstPosition];\n
        for (var i = 0; i < position.blocks.length; i++) {\n
\n
            var block = {};\n
            this.blocks.push(block);\n
\n
            var divId = this.id + \'_FrameDecorationDiv_\' + i;\n
            block.div = OpenLayers.Util.createDiv(divId, \n
                null, null, null, "absolute", null, "hidden", null\n
            );\n
\n
            var imgId = this.id + \'_FrameDecorationImg_\' + i;\n
            var imageCreator = \n
                (this.isAlphaImage) ? OpenLayers.Util.createAlphaImageDiv\n
                                    : OpenLayers.Util.createImage;\n
\n
            block.image = imageCreator(imgId, \n
                null, this.imageSize, this.imageSrc, \n
                "absolute", null, null, null\n
            );\n
\n
            block.div.appendChild(block.image);\n
            this.groupDiv.appendChild(block.div);\n
        }\n
    },\n
\n
    /**\n
     * Method: updateBlocks\n
     * Internal method, called on initialize and when the popup\'s relative\n
     *     position has changed. This function takes care of re-positioning\n
     *     the popup\'s blocks in their appropropriate places.\n
     */\n
    updateBlocks: function() {\n
        if (!this.blocks) {\n
            this.createBlocks();\n
        }\n
        \n
        if (this.size && this.relativePosition) {\n
            var position = this.positionBlocks[this.relativePosition];\n
            for (var i = 0; i < position.blocks.length; i++) {\n
    \n
                var positionBlock = position.blocks[i];\n
                var block = this.blocks[i];\n
    \n
                // adjust sizes\n
                var l = positionBlock.anchor.left;\n
                var b = positionBlock.anchor.bottom;\n
                var r = positionBlock.anchor.right;\n
                var t = positionBlock.anchor.top;\n
    \n
                //note that we use the isNaN() test here because if the \n
                // size object is initialized with a "auto" parameter, the \n
                // size constructor calls parseFloat() on the string, \n
                // which will turn it into NaN\n
                //\n
                var w = (isNaN(positionBlock.size.w)) ? this.size.w - (r + l) \n
                                                      : positionBlock.size.w;\n
    \n
                var h = (isNaN(positionBlock.size.h)) ? this.size.h - (b + t) \n
                                                      : positionBlock.size.h;\n
    \n
                block.div.style.width = (w < 0 ? 0 : w) + \'px\';\n
                block.div.style.height = (h < 0 ? 0 : h) + \'px\';\n
    \n
                block.div.style.left = (l != null) ? l + \'px\' : \'\';\n
                block.div.style.bottom = (b != null) ? b + \'px\' : \'\';\n
                block.div.style.right = (r != null) ? r + \'px\' : \'\';            \n
                block.div.style.top = (t != null) ? t + \'px\' : \'\';\n
    \n
                block.image.style.left = positionBlock.position.x + \'px\';\n
                block.image.style.top = positionBlock.position.y + \'px\';\n
            }\n
    \n
            this.contentDiv.style.left = this.padding.left + "px";\n
            this.contentDiv.style.top = this.padding.top + "px";\n
        }\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Popup.Framed"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>11967</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
