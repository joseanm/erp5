<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.76</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Rule.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/BaseTypes/Class.js\n
 * @requires OpenLayers/Util.js\n
 * @requires OpenLayers/Style.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Rule\n
 * This class represents an SLD Rule, as being used for rule-based SLD styling.\n
 */\n
OpenLayers.Rule = OpenLayers.Class({\n
    \n
    /**\n
     * Property: id\n
     * {String} A unique id for this session.\n
     */\n
    id: null,\n
    \n
    /**\n
     * APIProperty: name\n
     * {String} name of this rule\n
     */\n
    name: null,\n
    \n
    /**\n
     * Property: title\n
     * {String} Title of this rule (set if included in SLD)\n
     */\n
    title: null,\n
    \n
    /**\n
     * Property: description\n
     * {String} Description of this rule (set if abstract is included in SLD)\n
     */\n
    description: null,\n
\n
    /**\n
     * Property: context\n
     * {Object} An optional object with properties that the rule should be\n
     * evaluated against. If no context is specified, feature.attributes will\n
     * be used.\n
     */\n
    context: null,\n
    \n
    /**\n
     * Property: filter\n
     * {<OpenLayers.Filter>} Optional filter for the rule.\n
     */\n
    filter: null,\n
\n
    /**\n
     * Property: elseFilter\n
     * {Boolean} Determines whether this rule is only to be applied only if\n
     * no other rules match (ElseFilter according to the SLD specification). \n
     * Default is false.  For instances of OpenLayers.Rule, if elseFilter is\n
     * false, the rule will always apply.  For subclasses, the else property is \n
     * ignored.\n
     */\n
    elseFilter: false,\n
    \n
    /**\n
     * Property: symbolizer\n
     * {Object} Symbolizer or hash of symbolizers for this rule. If hash of\n
     * symbolizers, keys are one or more of ["Point", "Line", "Polygon"]. The\n
     * latter if useful if it is required to style e.g. vertices of a line\n
     * with a point symbolizer. Note, however, that this is not implemented\n
     * yet in OpenLayers, but it is the way how symbolizers are defined in\n
     * SLD.\n
     */\n
    symbolizer: null,\n
    \n
    /**\n
     * Property: symbolizers\n
     * {Array} Collection of symbolizers associated with this rule.  If \n
     *     provided at construction, the symbolizers array has precedence\n
     *     over the deprecated symbolizer property.  Note that multiple \n
     *     symbolizers are not currently supported by the vector renderers.\n
     *     Rules with multiple symbolizers are currently only useful for\n
     *     maintaining elements in an SLD document.\n
     */\n
    symbolizers: null,\n
    \n
    /**\n
     * APIProperty: minScaleDenominator\n
     * {Number} or {String} minimum scale at which to draw the feature.\n
     * In the case of a String, this can be a combination of text and\n
     * propertyNames in the form "literal ${propertyName}"\n
     */\n
    minScaleDenominator: null,\n
\n
    /**\n
     * APIProperty: maxScaleDenominator\n
     * {Number} or {String} maximum scale at which to draw the feature.\n
     * In the case of a String, this can be a combination of text and\n
     * propertyNames in the form "literal ${propertyName}"\n
     */\n
    maxScaleDenominator: null,\n
    \n
    /** \n
     * Constructor: OpenLayers.Rule\n
     * Creates a Rule.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object with properties to set on the\n
     *           rule\n
     * \n
     * Returns:\n
     * {<OpenLayers.Rule>}\n
     */\n
    initialize: function(options) {\n
        this.symbolizer = {};\n
        OpenLayers.Util.extend(this, options);\n
        if (this.symbolizers) {\n
            delete this.symbolizer;\n
        }\n
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");\n
    },\n
\n
    /** \n
     * APIMethod: destroy\n
     * nullify references to prevent circular references and memory leaks\n
     */\n
    destroy: function() {\n
        for (var i in this.symbolizer) {\n
            this.symbolizer[i] = null;\n
        }\n
        this.symbolizer = null;\n
        delete this.symbolizers;\n
    },\n
    \n
    /**\n
     * APIMethod: evaluate\n
     * evaluates this rule for a specific feature\n
     * \n
     * Parameters:\n
     * feature - {<OpenLayers.Feature>} feature to apply the rule to.\n
     * \n
     * Returns:\n
     * {Boolean} true if the rule applies, false if it does not.\n
     * This rule is the default rule and always returns true.\n
     */\n
    evaluate: function(feature) {\n
        var context = this.getContext(feature);\n
        var applies = true;\n
\n
        if (this.minScaleDenominator || this.maxScaleDenominator) {\n
            var scale = feature.layer.map.getScale();\n
        }\n
        \n
        // check if within minScale/maxScale bounds\n
        if (this.minScaleDenominator) {\n
            applies = scale >= OpenLayers.Style.createLiteral(\n
                    this.minScaleDenominator, context);\n
        }\n
        if (applies && this.maxScaleDenominator) {\n
            applies = scale < OpenLayers.Style.createLiteral(\n
                    this.maxScaleDenominator, context);\n
        }\n
        \n
        // check if optional filter applies\n
        if(applies && this.filter) {\n
            // feature id filters get the feature, others get the context\n
            if(this.filter.CLASS_NAME == "OpenLayers.Filter.FeatureId") {\n
                applies = this.filter.evaluate(feature);\n
            } else {\n
                applies = this.filter.evaluate(context);\n
            }\n
        }\n
\n
        return applies;\n
    },\n
    \n
    /**\n
     * Method: getContext\n
     * Gets the context for evaluating this rule\n
     * \n
     * Paramters:\n
     * feature - {<OpenLayers.Feature>} feature to take the context from if\n
     *           none is specified.\n
     */\n
    getContext: function(feature) {\n
        var context = this.context;\n
        if (!context) {\n
            context = feature.attributes || feature.data;\n
        }\n
        if (typeof this.context == "function") {\n
            context = this.context(feature);\n
        }\n
        return context;\n
    },\n
    \n
    /**\n
     * APIMethod: clone\n
     * Clones this rule.\n
     * \n
     * Returns:\n
     * {<OpenLayers.Rule>} Clone of this rule.\n
     */\n
    clone: function() {\n
        var options = OpenLayers.Util.extend({}, this);\n
        if (this.symbolizers) {\n
            // clone symbolizers\n
            var len = this.symbolizers.length;\n
            options.symbolizers = new Array(len);\n
            for (var i=0; i<len; ++i) {\n
                options.symbolizers[i] = this.symbolizers[i].clone();\n
            }\n
        } else {\n
            // clone symbolizer\n
            options.symbolizer = {};\n
            var value, type;\n
            for(var key in this.symbolizer) {\n
                value = this.symbolizer[key];\n
                type = typeof value;\n
                if(type === "object") {\n
                    options.symbolizer[key] = OpenLayers.Util.extend({}, value);\n
                } else if(type === "string") {\n
                    options.symbolizer[key] = value;\n
                }\n
            }\n
        }\n
        // clone filter\n
        options.filter = this.filter && this.filter.clone();\n
        // clone context\n
        options.context = this.context && OpenLayers.Util.extend({}, this.context);\n
        return new OpenLayers.Rule(options);\n
    },\n
        \n
    CLASS_NAME: "OpenLayers.Rule"\n
});

]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>7377</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
