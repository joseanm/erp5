<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.79</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>v3.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/Layer/Google.js\n
 */\n
\n
/**\n
 * Constant: OpenLayers.Layer.Google.v3\n
 * \n
 * Mixin providing functionality specific to the Google Maps API v3.\n
 * \n
 * To use this layer, you must include the GMaps v3 API in your html.\n
 * \n
 * Because OpenLayers needs to control mouse events, it isolates the GMaps mapObject\n
 * (the DOM elements provided by Google) using the EventPane.\n
 * However, because the Terms of Use require some of those elements,\n
 * such as the links to Google\'s terms, to be clickable, these elements have \n
 * to be moved up to OpenLayers\' container div. There is however no easy way\n
 * to identify these, and the logic (see the repositionMapElements function\n
 * in the source) may need to be changed if Google changes them.\n
 * These elements are not part of the published API and can be changed at any time,\n
 * so a given OpenLayers release can only guarantee support for the \'frozen\'\n
 * Google release at the time of the OpenLayers release. See\n
 * https://developers.google.com/maps/documentation/javascript/basics#Versioning\n
 * for Google\'s current release cycle.\n
 * \n
 * For this reason, it\'s recommended that production code specifically loads \n
 * the current frozen version, for example:\n
 *\n
 * (code)\n
 * <script src="http://maps.google.com/maps/api/js?v=3.7&amp;sensor=false"></script>\n
 * (end)\n
 * \n
 * but that development code should use the latest \'nightly\' version, so that any\n
 * problems can be dealt with as soon as they arise, and before they affect the production, \'frozen\', code.\n
 * \n
 * Note, however, that frozen versions are retired as part of Google\'s release\n
 * cycle, and once this happens, you will get the next version, in the example above, 3.8 once 3.7 is retired.\n
 * \n
 * This version supports 3.7.\n
 * \n
 * \n
 * Note that this layer configures the google.maps.map object with the\n
 * "disableDefaultUI" option set to true. Using UI controls that the Google\n
 * Maps API provides is not supported by the OpenLayers API.\n
 */\n
OpenLayers.Layer.Google.v3 = {\n
    \n
    /**\n
     * Constant: DEFAULTS\n
     * {Object} It is not recommended to change the properties set here. Note\n
     * that Google.v3 layers only work when sphericalMercator is set to true.\n
     * \n
     * (code)\n
     * {\n
     *     sphericalMercator: true,\n
     *     projection: "EPSG:900913"\n
     * }\n
     * (end)\n
     */\n
    DEFAULTS: {\n
        sphericalMercator: true,\n
        projection: "EPSG:900913"\n
    },\n
\n
    /**\n
     * APIProperty: animationEnabled\n
     * {Boolean} If set to true, the transition between zoom levels will be\n
     *     animated (if supported by the GMaps API for the device used). Set to\n
     *     false to match the zooming experience of other layer types. Default\n
     *     is true. Note that the GMaps API does not give us control over zoom\n
     *     animation, so if set to false, when zooming, this will make the\n
     *     layer temporarily invisible, wait until GMaps reports the map being\n
     *     idle, and make it visible again. The result will be a blank layer\n
     *     for a few moments while zooming.\n
     */\n
    animationEnabled: true, \n
\n
    /** \n
     * Method: loadMapObject\n
     * Load the GMap and register appropriate event listeners. If we can\'t \n
     *     load GMap2, then display a warning message.\n
     */\n
    loadMapObject:function() {\n
        if (!this.type) {\n
            this.type = google.maps.MapTypeId.ROADMAP;\n
        }\n
        var mapObject;\n
        var cache = OpenLayers.Layer.Google.cache[this.map.id];\n
        if (cache) {\n
            // there are already Google layers added to this map\n
            mapObject = cache.mapObject;\n
            // increment the layer count\n
            ++cache.count;\n
        } else {\n
            // this is the first Google layer for this map\n
\n
            var container = this.map.viewPortDiv;\n
            var div = document.createElement("div");\n
            div.id = this.map.id + "_GMapContainer";\n
            div.style.position = "absolute";\n
            div.style.width = "100%";\n
            div.style.height = "100%";\n
            container.appendChild(div);\n
\n
            // create GMap and shuffle elements\n
            var center = this.map.getCenter();\n
            mapObject = new google.maps.Map(div, {\n
                center: center ?\n
                    new google.maps.LatLng(center.lat, center.lon) :\n
                    new google.maps.LatLng(0, 0),\n
                zoom: this.map.getZoom() || 0,\n
                mapTypeId: this.type,\n
                disableDefaultUI: true,\n
                keyboardShortcuts: false,\n
                draggable: false,\n
                disableDoubleClickZoom: true,\n
                scrollwheel: false,\n
                streetViewControl: false\n
            });\n
            \n
            // cache elements for use by any other google layers added to\n
            // this same map\n
            cache = {\n
                mapObject: mapObject,\n
                count: 1\n
            };\n
            OpenLayers.Layer.Google.cache[this.map.id] = cache;\n
            this.repositionListener = google.maps.event.addListenerOnce(\n
                mapObject, \n
                "center_changed", \n
                OpenLayers.Function.bind(this.repositionMapElements, this)\n
            );\n
        }\n
        this.mapObject = mapObject;\n
        this.setGMapVisibility(this.visibility);\n
    },\n
    \n
    /**\n
     * Method: repositionMapElements\n
     *\n
     * Waits until powered by and terms of use elements are available and then\n
     * moves them so they are clickable.\n
     */\n
    repositionMapElements: function() {\n
\n
        // This is the first time any Google layer in this mapObject has been\n
        // made visible.  The mapObject needs to know the container size.\n
        google.maps.event.trigger(this.mapObject, "resize");\n
        \n
        var div = this.mapObject.getDiv().firstChild;\n
        if (!div || div.childNodes.length < 3) {\n
            this.repositionTimer = window.setTimeout(\n
                OpenLayers.Function.bind(this.repositionMapElements, this),\n
                250\n
            );\n
            return false;\n
        }\n
\n
        var cache = OpenLayers.Layer.Google.cache[this.map.id];\n
        var container = this.map.viewPortDiv;\n
        \n
        // move the ToS and branding stuff up to the container div\n
        // depends on value of zIndex, which is not robust\n
        for (var i=div.children.length-1; i>=0; --i) {\n
            if (div.children[i].style.zIndex == 1000001) {\n
                var termsOfUse = div.children[i];\n
                container.appendChild(termsOfUse);\n
                termsOfUse.style.zIndex = "1100";\n
                termsOfUse.style.bottom = "";\n
                termsOfUse.className = "olLayerGoogleCopyright olLayerGoogleV3";\n
                termsOfUse.style.display = "";\n
                cache.termsOfUse = termsOfUse;\n
            }\n
            if (div.children[i].style.zIndex == 1000000) {\n
                var poweredBy = div.children[i];\n
                container.appendChild(poweredBy);\n
                poweredBy.style.zIndex = "1100";\n
                poweredBy.style.bottom = "";\n
                poweredBy.className = "olLayerGooglePoweredBy olLayerGoogleV3 gmnoprint";\n
                poweredBy.style.display = "";\n
                cache.poweredBy = poweredBy;\n
            }\n
            if (div.children[i].style.zIndex == 10000002) {\n
                container.appendChild(div.children[i]);\n
            }\n
        }\n
\n
        this.setGMapVisibility(this.visibility);\n
\n
    },\n
\n
    /**\n
     * APIMethod: onMapResize\n
     */\n
    onMapResize: function() {\n
        if (this.visibility) {\n
            google.maps.event.trigger(this.mapObject, "resize");\n
        } else {\n
            var cache = OpenLayers.Layer.Google.cache[this.map.id];\n
            if (!cache.resized) {\n
                var layer = this;\n
                google.maps.event.addListenerOnce(this.mapObject, "tilesloaded", function() {\n
                    google.maps.event.trigger(layer.mapObject, "resize");\n
                    layer.moveTo(layer.map.getCenter(), layer.map.getZoom());\n
                    delete cache.resized;\n
                });\n
            }\n
            cache.resized = true;\n
        }\n
    },\n
\n
    /**\n
     * Method: setGMapVisibility\n
     * Display the GMap container and associated elements.\n
     * \n
     * Parameters:\n
     * visible - {Boolean} Display the GMap elements.\n
     */\n
    setGMapVisibility: function(visible) {\n
        var cache = OpenLayers.Layer.Google.cache[this.map.id];\n
        if (cache) {\n
            var type = this.type;\n
            var layers = this.map.layers;\n
            var layer;\n
            for (var i=layers.length-1; i>=0; --i) {\n
                layer = layers[i];\n
                if (layer instanceof OpenLayers.Layer.Google &&\n
                            layer.visibility === true && layer.inRange === true) {\n
                    type = layer.type;\n
                    visible = true;\n
                    break;\n
                }\n
            }\n
            var container = this.mapObject.getDiv();\n
            if (visible === true) {\n
                this.mapObject.setMapTypeId(type);                \n
                container.style.left = "";\n
                if (cache.termsOfUse && cache.termsOfUse.style) {\n
                    cache.termsOfUse.style.left = "";\n
                    cache.termsOfUse.style.display = "";\n
                    cache.poweredBy.style.display = "";            \n
                }\n
                cache.displayed = this.id;\n
            } else {\n
                delete cache.displayed;\n
                container.style.left = "-9999px";\n
                if (cache.termsOfUse && cache.termsOfUse.style) {\n
                    cache.termsOfUse.style.display = "none";\n
                    // move ToU far to the left in addition to setting\n
                    // display to "none", because at the end of the GMap\n
                    // load sequence, display: none will be unset and ToU\n
                    // would be visible after loading a map with a google\n
                    // layer that is initially hidden. \n
                    cache.termsOfUse.style.left = "-9999px";\n
                    cache.poweredBy.style.display = "none";\n
                }\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: getMapContainer\n
     * \n
     * Returns:\n
     * {DOMElement} the GMap container\'s div\n
     */\n
    getMapContainer: function() {\n
        return this.mapObject.getDiv();\n
    },\n
    \n
  //\n
  // TRANSLATION: MapObject Bounds <-> OpenLayers.Bounds\n
  //\n
\n
    /**\n
     * APIMethod: getMapObjectBoundsFromOLBounds\n
     * \n
     * Parameters:\n
     * olBounds - {<OpenLayers.Bounds>}\n
     * \n
     * Returns:\n
     * {Object} A MapObject Bounds, translated from olBounds\n
     *          Returns null if null value is passed in\n
     */\n
    getMapObjectBoundsFromOLBounds: function(olBounds) {\n
        var moBounds = null;\n
        if (olBounds != null) {\n
            var sw = this.sphericalMercator ? \n
              this.inverseMercator(olBounds.bottom, olBounds.left) : \n
              new OpenLayers.LonLat(olBounds.bottom, olBounds.left);\n
            var ne = this.sphericalMercator ? \n
              this.inverseMercator(olBounds.top, olBounds.right) : \n
              new OpenLayers.LonLat(olBounds.top, olBounds.right);\n
            moBounds = new google.maps.LatLngBounds(\n
                new google.maps.LatLng(sw.lat, sw.lon),\n
                new google.maps.LatLng(ne.lat, ne.lon)\n
            );\n
        }\n
        return moBounds;\n
    },\n
\n
\n
    /************************************\n
     *                                  *\n
     *   MapObject Interface Controls   *\n
     *                                  *\n
     ************************************/\n
\n
\n
  // LonLat - Pixel Translation\n
  \n
    /**\n
     * APIMethod: getMapObjectLonLatFromMapObjectPixel\n
     * \n
     * Parameters:\n
     * moPixel - {Object} MapObject Pixel format\n
     * \n
     * Returns:\n
     * {Object} MapObject LonLat translated from MapObject Pixel\n
     */\n
    getMapObjectLonLatFromMapObjectPixel: function(moPixel) {\n
        var size = this.map.getSize();\n
        var lon = this.getLongitudeFromMapObjectLonLat(this.mapObject.center);\n
        var lat = this.getLatitudeFromMapObjectLonLat(this.mapObject.center);\n
        var res = this.map.getResolution();\n
\n
        var delta_x = moPixel.x - (size.w / 2);\n
        var delta_y = moPixel.y - (size.h / 2);\n
    \n
        var lonlat = new OpenLayers.LonLat(\n
            lon + delta_x * res,\n
            lat - delta_y * res\n
        ); \n
\n
        if (this.wrapDateLine) {\n
            lonlat = lonlat.wrapDateLine(this.maxExtent);\n
        }\n
        return this.getMapObjectLonLatFromLonLat(lonlat.lon, lonlat.lat);\n
    },\n
\n
    /**\n
     * APIMethod: getMapObjectPixelFromMapObjectLonLat\n
     * \n
     * Parameters:\n
     * moLonLat - {Object} MapObject LonLat format\n
     * \n
     * Returns:\n
     * {Object} MapObject Pixel transtlated from MapObject LonLat\n
     */\n
    getMapObjectPixelFromMapObjectLonLat: function(moLonLat) {\n
        var lon = this.getLongitudeFromMapObjectLonLat(moLonLat);\n
        var lat = this.getLatitudeFromMapObjectLonLat(moLonLat);\n
        var res = this.map.getResolution();\n
        var extent = this.map.getExtent();\n
        return this.getMapObjectPixelFromXY((1/res * (lon - extent.left)),\n
                                            (1/res * (extent.top - lat)));\n
    },\n
\n
  \n
    /** \n
     * APIMethod: setMapObjectCenter\n
     * Set the mapObject to the specified center and zoom\n
     * \n
     * Parameters:\n
     * center - {Object} MapObject LonLat format\n
     * zoom - {int} MapObject zoom format\n
     */\n
    setMapObjectCenter: function(center, zoom) {\n
        if (this.animationEnabled === false && zoom != this.mapObject.zoom) {\n
            var mapContainer = this.getMapContainer();\n
            google.maps.event.addListenerOnce(\n
                this.mapObject, \n
                "idle", \n
                function() {\n
                    mapContainer.style.visibility = "";\n
                }\n
            );\n
            mapContainer.style.visibility = "hidden";\n
        }\n
        this.mapObject.setOptions({\n
            center: center,\n
            zoom: zoom\n
        });\n
    },\n
   \n
    \n
  // Bounds\n
  \n
    /** \n
     * APIMethod: getMapObjectZoomFromMapObjectBounds\n
     * \n
     * Parameters:\n
     * moBounds - {Object} MapObject Bounds format\n
     * \n
     * Returns:\n
     * {Object} MapObject Zoom for specified MapObject Bounds\n
     */\n
    getMapObjectZoomFromMapObjectBounds: function(moBounds) {\n
        return this.mapObject.getBoundsZoomLevel(moBounds);\n
    },\n
\n
    /************************************\n
     *                                  *\n
     *       MapObject Primitives       *\n
     *                                  *\n
     ************************************/\n
\n
\n
  // LonLat\n
    \n
    /**\n
     * APIMethod: getMapObjectLonLatFromLonLat\n
     * \n
     * Parameters:\n
     * lon - {Float}\n
     * lat - {Float}\n
     * \n
     * Returns:\n
     * {Object} MapObject LonLat built from lon and lat params\n
     */\n
    getMapObjectLonLatFromLonLat: function(lon, lat) {\n
        var gLatLng;\n
        if(this.sphericalMercator) {\n
            var lonlat = this.inverseMercator(lon, lat);\n
            gLatLng = new google.maps.LatLng(lonlat.lat, lonlat.lon);\n
        } else {\n
            gLatLng = new google.maps.LatLng(lat, lon);\n
        }\n
        return gLatLng;\n
    },\n
    \n
  // Pixel\n
    \n
    /**\n
     * APIMethod: getMapObjectPixelFromXY\n
     * \n
     * Parameters:\n
     * x - {Integer}\n
     * y - {Integer}\n
     * \n
     * Returns:\n
     * {Object} MapObject Pixel from x and y parameters\n
     */\n
    getMapObjectPixelFromXY: function(x, y) {\n
        return new google.maps.Point(x, y);\n
    },\n
        \n
    /**\n
     * APIMethod: destroy\n
     * Clean up this layer.\n
     */\n
    destroy: function() {\n
        if (this.repositionListener) {\n
            google.maps.event.removeListener(this.repositionListener);\n
        }\n
        if (this.repositionTimer) {\n
            window.clearTimeout(this.repositionTimer);\n
        }\n
        OpenLayers.Layer.Google.prototype.destroy.apply(this, arguments);\n
    }\n
    \n
};\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>16330</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
