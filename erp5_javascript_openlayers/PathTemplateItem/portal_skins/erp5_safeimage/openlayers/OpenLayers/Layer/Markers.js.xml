<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.79</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Markers.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/Layer.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Layer.Markers\n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Layer> \n
 */\n
OpenLayers.Layer.Markers = OpenLayers.Class(OpenLayers.Layer, {\n
    \n
    /** \n
     * APIProperty: isBaseLayer \n
     * {Boolean} Markers layer is never a base layer.  \n
     */\n
    isBaseLayer: false,\n
    \n
    /** \n
     * APIProperty: markers \n
     * {Array(<OpenLayers.Marker>)} internal marker list \n
     */\n
    markers: null,\n
\n
\n
    /** \n
     * Property: drawn \n
     * {Boolean} internal state of drawing. This is a workaround for the fact\n
     * that the map does not call moveTo with a zoomChanged when the map is\n
     * first starting up. This lets us catch the case where we have *never*\n
     * drawn the layer, and draw it even if the zoom hasn\'t changed.\n
     */\n
    drawn: false,\n
    \n
    /**\n
     * Constructor: OpenLayers.Layer.Markers \n
     * Create a Markers layer.\n
     *\n
     * Parameters:\n
     * name - {String} \n
     * options - {Object} Hashtable of extra options to tag onto the layer\n
     */\n
    initialize: function(name, options) {\n
        OpenLayers.Layer.prototype.initialize.apply(this, arguments);\n
        this.markers = [];\n
    },\n
    \n
    /**\n
     * APIMethod: destroy \n
     */\n
    destroy: function() {\n
        this.clearMarkers();\n
        this.markers = null;\n
        OpenLayers.Layer.prototype.destroy.apply(this, arguments);\n
    },\n
\n
    /**\n
     * APIMethod: setOpacity\n
     * Sets the opacity for all the markers.\n
     * \n
     * Parameters:\n
     * opacity - {Float}\n
     */\n
    setOpacity: function(opacity) {\n
        if (opacity != this.opacity) {\n
            this.opacity = opacity;\n
            for (var i=0, len=this.markers.length; i<len; i++) {\n
                this.markers[i].setOpacity(this.opacity);\n
            }\n
        }\n
    },\n
\n
    /** \n
     * Method: moveTo\n
     *\n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>} \n
     * zoomChanged - {Boolean} \n
     * dragging - {Boolean} \n
     */\n
    moveTo:function(bounds, zoomChanged, dragging) {\n
        OpenLayers.Layer.prototype.moveTo.apply(this, arguments);\n
\n
        if (zoomChanged || !this.drawn) {\n
            for(var i=0, len=this.markers.length; i<len; i++) {\n
                this.drawMarker(this.markers[i]);\n
            }\n
            this.drawn = true;\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: addMarker\n
     *\n
     * Parameters:\n
     * marker - {<OpenLayers.Marker>} \n
     */\n
    addMarker: function(marker) {\n
        this.markers.push(marker);\n
\n
        if (this.opacity < 1) {\n
            marker.setOpacity(this.opacity);\n
        }\n
\n
        if (this.map && this.map.getExtent()) {\n
            marker.map = this.map;\n
            this.drawMarker(marker);\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: removeMarker\n
     *\n
     * Parameters:\n
     * marker - {<OpenLayers.Marker>} \n
     */\n
    removeMarker: function(marker) {\n
        if (this.markers && this.markers.length) {\n
            OpenLayers.Util.removeItem(this.markers, marker);\n
            marker.erase();\n
        }\n
    },\n
\n
    /**\n
     * Method: clearMarkers\n
     * This method removes all markers from a layer. The markers are not\n
     * destroyed by this function, but are removed from the list of markers.\n
     */\n
    clearMarkers: function() {\n
        if (this.markers != null) {\n
            while(this.markers.length > 0) {\n
                this.removeMarker(this.markers[0]);\n
            }\n
        }\n
    },\n
\n
    /** \n
     * Method: drawMarker\n
     * Calculate the pixel location for the marker, create it, and \n
     *    add it to the layer\'s div\n
     *\n
     * Parameters:\n
     * marker - {<OpenLayers.Marker>} \n
     */\n
    drawMarker: function(marker) {\n
        var px = this.map.getLayerPxFromLonLat(marker.lonlat);\n
        if (px == null) {\n
            marker.display(false);\n
        } else {\n
            if (!marker.isDrawn()) {\n
                var markerImg = marker.draw(px);\n
                this.div.appendChild(markerImg);\n
            } else if(marker.icon) {\n
                marker.icon.moveTo(px);\n
            }\n
        }\n
    },\n
    \n
    /** \n
     * APIMethod: getDataExtent\n
     * Calculates the max extent which includes all of the markers.\n
     * \n
     * Returns:\n
     * {<OpenLayers.Bounds>}\n
     */\n
    getDataExtent: function () {\n
        var maxExtent = null;\n
        \n
        if ( this.markers && (this.markers.length > 0)) {\n
            var maxExtent = new OpenLayers.Bounds();\n
            for(var i=0, len=this.markers.length; i<len; i++) {\n
                var marker = this.markers[i];\n
                maxExtent.extend(marker.lonlat);\n
            }\n
        }\n
\n
        return maxExtent;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Layer.Markers"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>4920</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
