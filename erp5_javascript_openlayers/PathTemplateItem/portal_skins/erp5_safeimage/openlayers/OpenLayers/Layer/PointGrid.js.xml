<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.78</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>PointGrid.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Layer/Vector.js\n
 * @requires OpenLayers/Geometry/Polygon.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Layer.PointGrid\n
 * A point grid layer dynamically generates a regularly spaced grid of point\n
 *     features.  This is a specialty layer for cases where an application needs\n
 *     a regular grid of points.  It can be used, for example, in an editing\n
 *     environment to snap to a grid.\n
 *\n
 * Create a new vector layer with the <OpenLayers.Layer.PointGrid> constructor.\n
 * (code)\n
 * // create a grid with points spaced at 10 map units\n
 * var points = new OpenLayers.Layer.PointGrid({dx: 10, dy: 10});\n
 *\n
 * // create a grid with different x/y spacing rotated 15 degrees clockwise.\n
 * var points = new OpenLayers.Layer.PointGrid({dx: 5, dy: 10, rotation: 15});\n
 * (end)\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Layer.Vector>\n
 */\n
OpenLayers.Layer.PointGrid = OpenLayers.Class(OpenLayers.Layer.Vector, {\n
\n
    /**\n
     * APIProperty: dx\n
     * {Number} Point grid spacing in the x-axis direction (map units).  \n
     * Read-only.  Use the <setSpacing> method to modify this value.\n
     */\n
    dx: null,\n
\n
    /**\n
     * APIProperty: dy\n
     * {Number} Point grid spacing in the y-axis direction (map units).  \n
     * Read-only.  Use the <setSpacing> method to modify this value.\n
     */\n
    dy: null,\n
\n
    /**\n
     * APIProperty: ratio\n
     * {Number} Ratio of the desired grid size to the map viewport size.  \n
     * Default is 1.5.  Larger ratios mean the grid is recalculated less often \n
     * while panning.  The <maxFeatures> setting has precedence when determining\n
     * grid size.  Read-only.  Use the <setRatio> method to modify this value.\n
     */\n
    ratio: 1.5,\n
\n
    /**\n
     * APIProperty: maxFeatures\n
     * {Number} The maximum number of points to generate in the grid.  Default\n
     * is 250.  Read-only.  Use the <setMaxFeatures> method to modify this value.\n
     */\n
    maxFeatures: 250,\n
\n
    /**\n
     * APIProperty: rotation\n
     * {Number} Grid rotation (in degrees clockwise from the positive x-axis).\n
     * Default is 0.  Read-only.  Use the <setRotation> method to modify this\n
     * value.\n
     */\n
    rotation: 0,\n
\n
    /**\n
     * APIProperty: origin\n
     * {<OpenLayers.LonLat>} Grid origin.  The grid lattice will be aligned with \n
     * the origin.  If not set at construction, the center of the map\'s maximum \n
     * extent is used.  Read-only.  Use the <setOrigin> method to modify this \n
     * value.\n
     */\n
    origin: null,\n
\n
    /**\n
     * Property: gridBounds\n
     * {<OpenLayers.Bounds>}  Internally cached grid bounds (with optional \n
     * rotation applied).\n
     */\n
    gridBounds: null,\n
\n
    /**\n
     * Constructor: OpenLayers.Layer.PointGrid\n
     * Creates a new point grid layer.\n
     *\n
     * Parameters:\n
     * config - {Object} An object containing all configuration properties for\n
     *     the layer.  The <dx> and <dy> properties are required to be set at \n
     *     construction.  Any other layer properties may be set in this object.\n
     */\n
    initialize: function(config) {\n
        config = config || {};\n
        OpenLayers.Layer.Vector.prototype.initialize.apply(this, [config.name, config]);\n
    },\n
    \n
    /** \n
     * Method: setMap\n
     * The layer has been added to the map. \n
     * \n
     * Parameters:\n
     * map - {<OpenLayers.Map>} \n
     */\n
    setMap: function(map) {        \n
        OpenLayers.Layer.Vector.prototype.setMap.apply(this, arguments);\n
        map.events.register("moveend", this, this.onMoveEnd);\n
    },\n
\n
    /**\n
     * Method: removeMap\n
     * The layer has been removed from the map.\n
     *\n
     * Parameters:\n
     * map - {<OpenLayers.Map>}\n
     */\n
    removeMap: function(map) {\n
        map.events.unregister("moveend", this, this.onMoveEnd);\n
        OpenLayers.Layer.Vector.prototype.removeMap.apply(this, arguments);\n
    },\n
    \n
    /**\n
     * APIMethod: setRatio\n
     * Set the grid <ratio> property and update the grid.  Can only be called\n
     *     after the layer has been added to a map with a center/extent.\n
     *\n
     * Parameters:\n
     * ratio - {Number}\n
     */\n
    setRatio: function(ratio) {\n
        this.ratio = ratio;\n
        this.updateGrid(true);\n
    },\n
    \n
    /**\n
     * APIMethod: setMaxFeatures\n
     * Set the grid <maxFeatures> property and update the grid.  Can only be \n
     *     called after the layer has been added to a map with a center/extent.\n
     *\n
     * Parameters:\n
     * maxFeatures - {Number}\n
     */\n
    setMaxFeatures: function(maxFeatures) {\n
        this.maxFeatures = maxFeatures;\n
        this.updateGrid(true);\n
    },\n
\n
    /**\n
     * APIMethod: setSpacing\n
     * Set the grid <dx> and <dy> properties and update the grid.  If only one\n
     *     argument is provided, it will be set as <dx> and <dy>.  Can only be \n
     *     called after the layer has been added to a map with a center/extent.\n
     *\n
     * Parameters:\n
     * dx - {Number}\n
     * dy - {Number}\n
     */\n
    setSpacing: function(dx, dy) {\n
        this.dx = dx;\n
        this.dy = dy || dx;\n
        this.updateGrid(true);\n
    },\n
    \n
    /**\n
     * APIMethod: setOrigin\n
     * Set the grid <origin> property and update the grid.  Can only be called\n
     *     after the layer has been added to a map with a center/extent.\n
     *\n
     * Parameters:\n
     * origin - {<OpenLayers.LonLat>}\n
     */\n
    setOrigin: function(origin) {\n
        this.origin = origin;\n
        this.updateGrid(true);\n
    },\n
    \n
    /**\n
     * APIMethod: getOrigin\n
     * Get the grid <origin> property.\n
     *\n
     * Returns:\n
     * {<OpenLayers.LonLat>} The grid origin.\n
     */\n
    getOrigin: function() {\n
        if (!this.origin) {\n
            this.origin = this.map.getExtent().getCenterLonLat();\n
        }\n
        return this.origin;\n
    },\n
    \n
    /**\n
     * APIMethod: setRotation\n
     * Set the grid <rotation> property and update the grid.  Rotation values\n
     *     are in degrees clockwise from the positive x-axis (negative values\n
     *     for counter-clockwise rotation).  Can only be called after the layer \n
     *     has been added to a map with a center/extent.\n
     *\n
     * Parameters:\n
     * rotation - {Number} Degrees clockwise from the positive x-axis.\n
     */\n
    setRotation: function(rotation) {\n
        this.rotation = rotation;\n
        this.updateGrid(true);\n
    },\n
    \n
    /**\n
     * Method: onMoveEnd\n
     * Listener for map "moveend" events.\n
     */\n
    onMoveEnd: function() {\n
        this.updateGrid();\n
    },\n
    \n
    /**\n
     * Method: getViewBounds\n
     * Gets the (potentially rotated) view bounds for grid calculations.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Bounds>}\n
     */\n
    getViewBounds: function() {\n
        var bounds = this.map.getExtent();\n
        if (this.rotation) {\n
            var origin = this.getOrigin();\n
            var rotationOrigin = new OpenLayers.Geometry.Point(origin.lon, origin.lat);\n
            var rect = bounds.toGeometry();\n
            rect.rotate(-this.rotation, rotationOrigin);\n
            bounds = rect.getBounds();\n
        }\n
        return bounds;\n
    },\n
    \n
    /**\n
     * Method: updateGrid\n
     * Update the grid.\n
     *\n
     * Parameters:\n
     * force - {Boolean} Update the grid even if the previous bounds are still\n
     *     valid.\n
     */\n
    updateGrid: function(force) {\n
        if (force || this.invalidBounds()) {\n
            var viewBounds = this.getViewBounds();\n
            var origin = this.getOrigin();\n
            var rotationOrigin = new OpenLayers.Geometry.Point(origin.lon, origin.lat);\n
            var viewBoundsWidth = viewBounds.getWidth();\n
            var viewBoundsHeight = viewBounds.getHeight();\n
            var aspectRatio = viewBoundsWidth / viewBoundsHeight;\n
            var maxHeight = Math.sqrt(this.dx * this.dy * this.maxFeatures / aspectRatio);\n
            var maxWidth = maxHeight * aspectRatio; \n
            var gridWidth = Math.min(viewBoundsWidth * this.ratio, maxWidth);\n
            var gridHeight = Math.min(viewBoundsHeight * this.ratio, maxHeight);\n
            var center = viewBounds.getCenterLonLat();\n
            this.gridBounds = new OpenLayers.Bounds(\n
                center.lon - (gridWidth / 2),\n
                center.lat - (gridHeight / 2),\n
                center.lon + (gridWidth / 2),\n
                center.lat + (gridHeight / 2)\n
            );\n
            var rows = Math.floor(gridHeight / this.dy);\n
            var cols = Math.floor(gridWidth / this.dx);\n
            var gridLeft = origin.lon + (this.dx * Math.ceil((this.gridBounds.left - origin.lon) / this.dx));\n
            var gridBottom = origin.lat + (this.dy * Math.ceil((this.gridBounds.bottom - origin.lat) / this.dy));\n
            var features = new Array(rows * cols);\n
            var x, y, point;\n
            for (var i=0; i<cols; ++i) {\n
                x = gridLeft + (i * this.dx);\n
                for (var j=0; j<rows; ++j) {\n
                    y = gridBottom + (j * this.dy);\n
                    point = new OpenLayers.Geometry.Point(x, y);\n
                    if (this.rotation) {\n
                        point.rotate(this.rotation, rotationOrigin);\n
                    }\n
                    features[(i*rows)+j] = new OpenLayers.Feature.Vector(point);\n
                }\n
            }\n
            this.destroyFeatures(this.features, {silent: true});\n
            this.addFeatures(features, {silent: true});\n
        }\n
    },\n
\n
    /**\n
     * Method: invalidBounds\n
     * Determine whether the previously generated point grid is invalid. \n
     *     This occurs when the map bounds extends beyond the previously \n
     *     generated grid bounds.\n
     *\n
     * Returns:\n
     * {Boolean} \n
     */\n
    invalidBounds: function() {\n
        return !this.gridBounds || !this.gridBounds.containsBounds(this.getViewBounds());\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Layer.PointGrid"\n
    \n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>10022</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
