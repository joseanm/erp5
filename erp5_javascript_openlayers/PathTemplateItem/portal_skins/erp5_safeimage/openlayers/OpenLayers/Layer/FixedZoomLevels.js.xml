<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.79</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>FixedZoomLevels.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Layer.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Layer.FixedZoomLevels\n
 *   Some Layers will already have established zoom levels (like google \n
 *    or ve). Instead of trying to determine them and populate a resolutions[]\n
 *    Array with those values, we will hijack the resolution functionality\n
 *    here.\n
 * \n
 *   When you subclass FixedZoomLevels: \n
 * \n
 *   The initResolutions() call gets nullified, meaning no resolutions[] array \n
 *    is set up. Which would be a big problem getResolution() in Layer, since \n
 *    it merely takes map.zoom and indexes into resolutions[]... but....\n
 * \n
 *   The getResolution() call is also overridden. Instead of using the \n
 *    resolutions[] array, we simply calculate the current resolution based\n
 *    on the current extent and the current map size. But how will we be able\n
 *    to calculate the current extent without knowing the resolution...?\n
 *  \n
 *   The getExtent() function is also overridden. Instead of calculating extent\n
 *    based on the center point and the current resolution, we instead \n
 *    calculate the extent by getting the lonlats at the top-left and \n
 *    bottom-right by using the getLonLatFromViewPortPx() translation function,\n
 *    taken from the pixel locations (0,0) and the size of the map. But how \n
 *    will we be able to do lonlat-px translation without resolution....?\n
 * \n
 *   The getZoomForResolution() method is overridden. Instead of indexing into\n
 *    the resolutions[] array, we call OpenLayers.Layer.getExent(), passing in\n
 *    the desired resolution. With this extent, we then call getZoomForExtent() \n
 * \n
 * \n
 *   Whenever you implement a layer using OpenLayers.Layer.FixedZoomLevels, \n
 *    it is your responsibility to provide the following three functions:\n
 * \n
 *   - getLonLatFromViewPortPx\n
 *   - getViewPortPxFromLonLat\n
 *   - getZoomForExtent\n
 * \n
 *  ...those three functions should generally be provided by any reasonable \n
 *  API that you might be working from.\n
 *\n
 */\n
OpenLayers.Layer.FixedZoomLevels = OpenLayers.Class({\n
      \n
  /********************************************************/\n
  /*                                                      */\n
  /*                 Baselayer Functions                  */\n
  /*                                                      */\n
  /*    The following functions must all be implemented   */\n
  /*                  by all base layers                  */\n
  /*                                                      */\n
  /********************************************************/\n
    \n
    /**\n
     * Constructor: OpenLayers.Layer.FixedZoomLevels\n
     * Create a new fixed zoom levels layer.\n
     */\n
    initialize: function() {\n
        //this class is only just to add the following functions... \n
        // nothing to actually do here... but it is probably a good\n
        // idea to have layers that use these functions call this \n
        // inititalize() anyways, in case at some point we decide we \n
        // do want to put some functionality or state in here. \n
    },\n
    \n
    /**\n
     * Method: initResolutions\n
     * Populate the resolutions array\n
     */\n
    initResolutions: function() {\n
\n
        var props = [\'minZoomLevel\', \'maxZoomLevel\', \'numZoomLevels\'];\n
          \n
        for(var i=0, len=props.length; i<len; i++) {\n
            var property = props[i];\n
            this[property] = (this.options[property] != null)  \n
                                     ? this.options[property] \n
                                     : this.map[property];\n
        }\n
\n
        if ( (this.minZoomLevel == null) ||\n
             (this.minZoomLevel < this.MIN_ZOOM_LEVEL) ){\n
            this.minZoomLevel = this.MIN_ZOOM_LEVEL;\n
        }        \n
\n
        //\n
        // At this point, we know what the minimum desired zoom level is, and\n
        //  we must calculate the total number of zoom levels. \n
        //  \n
        //  Because we allow for the setting of either the \'numZoomLevels\'\n
        //   or the \'maxZoomLevel\' properties... on either the layer or the  \n
        //   map, we have to define some rules to see which we take into\n
        //   account first in this calculation. \n
        //\n
        // The following is the precedence list for these properties:\n
        // \n
        // (1) numZoomLevels set on layer\n
        // (2) maxZoomLevel set on layer\n
        // (3) numZoomLevels set on map\n
        // (4) maxZoomLevel set on map*\n
        // (5) none of the above*\n
        //\n
        // *Note that options (4) and (5) are only possible if the user \n
        //  _explicitly_ sets the \'numZoomLevels\' property on the map to \n
        //  null, since it is set by default to 16. \n
        //\n
\n
        //\n
        // Note to future: In 3.0, I think we should remove the default \n
        // value of 16 for map.numZoomLevels. Rather, I think that value \n
        // should be set as a default on the Layer.WMS class. If someone\n
        // creates a 3rd party layer and does not specify any \'minZoomLevel\', \n
        // \'maxZoomLevel\', or \'numZoomLevels\', and has not explicitly \n
        // specified any of those on the map object either.. then I think\n
        // it is fair to say that s/he wants all the zoom levels available.\n
        // \n
        // By making map.numZoomLevels *null* by default, that will be the \n
        // case. As it is, I don\'t feel comfortable changing that right now\n
        // as it would be a glaring API change and actually would probably\n
        // break many peoples\' codes. \n
        //\n
\n
        //the number of zoom levels we\'d like to have.\n
        var desiredZoomLevels;\n
\n
        //this is the maximum number of zoom levels the layer will allow, \n
        // given the specified starting minimum zoom level.\n
        var limitZoomLevels = this.MAX_ZOOM_LEVEL - this.minZoomLevel + 1;\n
\n
        if ( ((this.options.numZoomLevels == null) && \n
              (this.options.maxZoomLevel != null)) // (2)\n
              ||\n
             ((this.numZoomLevels == null) &&\n
              (this.maxZoomLevel != null)) // (4)\n
           ) {\n
            //calculate based on specified maxZoomLevel (on layer or map)\n
            desiredZoomLevels = this.maxZoomLevel - this.minZoomLevel + 1;\n
        } else {\n
            //calculate based on specified numZoomLevels (on layer or map)\n
            // this covers cases (1) and (3)\n
            desiredZoomLevels = this.numZoomLevels;\n
        }\n
\n
        if (desiredZoomLevels != null) {\n
            //Now that we know what we would *like* the number of zoom levels\n
            // to be, based on layer or map options, we have to make sure that\n
            // it does not conflict with the actual limit, as specified by \n
            // the constants on the layer itself (and calculated into the\n
            // \'limitZoomLevels\' variable). \n
            this.numZoomLevels = Math.min(desiredZoomLevels, limitZoomLevels);\n
        } else {\n
            // case (5) -- neither \'numZoomLevels\' not \'maxZoomLevel\' was \n
            // set on either the layer or the map. So we just use the \n
            // maximum limit as calculated by the layer\'s constants.\n
            this.numZoomLevels = limitZoomLevels;\n
        }\n
\n
        //now that the \'numZoomLevels\' is appropriately, safely set, \n
        // we go back and re-calculate the \'maxZoomLevel\'.\n
        this.maxZoomLevel = this.minZoomLevel + this.numZoomLevels - 1;\n
\n
        if (this.RESOLUTIONS != null) {\n
            var resolutionsIndex = 0;\n
            this.resolutions = [];\n
            for(var i= this.minZoomLevel; i <= this.maxZoomLevel; i++) {\n
                this.resolutions[resolutionsIndex++] = this.RESOLUTIONS[i];            \n
            }\n
            this.maxResolution = this.resolutions[0];\n
            this.minResolution = this.resolutions[this.resolutions.length - 1];\n
        }       \n
    },\n
    \n
    /**\n
     * APIMethod: getResolution\n
     * Get the current map resolution\n
     * \n
     * Returns:\n
     * {Float} Map units per Pixel\n
     */\n
    getResolution: function() {\n
\n
        if (this.resolutions != null) {\n
            return OpenLayers.Layer.prototype.getResolution.apply(this, arguments);\n
        } else {\n
            var resolution = null;\n
            \n
            var viewSize = this.map.getSize();\n
            var extent = this.getExtent();\n
            \n
            if ((viewSize != null) && (extent != null)) {\n
                resolution = Math.max( extent.getWidth()  / viewSize.w,\n
                                       extent.getHeight() / viewSize.h );\n
            }\n
            return resolution;\n
        }\n
     },\n
\n
    /**\n
     * APIMethod: getExtent\n
     * Calculates using px-> lonlat translation functions on tl and br \n
     *     corners of viewport\n
     * \n
     * Returns:\n
     * {<OpenLayers.Bounds>} A Bounds object which represents the lon/lat \n
     *                       bounds of the current viewPort.\n
     */\n
    getExtent: function () {\n
        var size = this.map.getSize();\n
        var tl = this.getLonLatFromViewPortPx({\n
            x: 0, y: 0\n
        });\n
        var br = this.getLonLatFromViewPortPx({\n
            x: size.w, y: size.h\n
        });\n
        \n
        if ((tl != null) && (br != null)) {\n
            return new OpenLayers.Bounds(tl.lon, br.lat, br.lon, tl.lat);\n
        } else {\n
            return null;\n
        }\n
    },\n
\n
    /**\n
     * Method: getZoomForResolution\n
     * Get the zoom level for a given resolution\n
     *\n
     * Parameters:\n
     * resolution - {Float}\n
     *\n
     * Returns:\n
     * {Integer} A suitable zoom level for the specified resolution.\n
     *           If no baselayer is set, returns null.\n
     */\n
    getZoomForResolution: function(resolution) {\n
      \n
        if (this.resolutions != null) {\n
            return OpenLayers.Layer.prototype.getZoomForResolution.apply(this, arguments);\n
        } else {\n
            var extent = OpenLayers.Layer.prototype.getExtent.apply(this, []);\n
            return this.getZoomForExtent(extent);\n
        }\n
    },\n
\n
\n
\n
    \n
    /********************************************************/\n
    /*                                                      */\n
    /*             Translation Functions                    */\n
    /*                                                      */\n
    /*    The following functions translate GMaps and OL    */ \n
    /*     formats for Pixel, LonLat, Bounds, and Zoom      */\n
    /*                                                      */\n
    /********************************************************/\n
    \n
    \n
    //\n
    // TRANSLATION: MapObject Zoom <-> OpenLayers Zoom\n
    //\n
  \n
    /**\n
     * Method: getOLZoomFromMapObjectZoom\n
     * Get the OL zoom index from the map object zoom level\n
     *\n
     * Parameters:\n
     * moZoom - {Integer}\n
     * \n
     * Returns:\n
     * {Integer} An OpenLayers Zoom level, translated from the passed in zoom\n
     *           Returns null if null value is passed in\n
     */\n
    getOLZoomFromMapObjectZoom: function(moZoom) {\n
        var zoom = null;\n
        if (moZoom != null) {\n
            zoom = moZoom - this.minZoomLevel;\n
            if (this.map.baseLayer !== this) {\n
                zoom = this.map.baseLayer.getZoomForResolution(\n
                    this.getResolutionForZoom(zoom)\n
                );\n
            }\n
        }\n
        return zoom;\n
    },\n
    \n
    /**\n
     * Method: getMapObjectZoomFromOLZoom\n
     * Get the map object zoom level from the OL zoom level\n
     *\n
     * Parameters:\n
     * olZoom - {Integer}\n
     * \n
     * Returns:\n
     * {Integer} A MapObject level, translated from the passed in olZoom\n
     *           Returns null if null value is passed in\n
     */\n
    getMapObjectZoomFromOLZoom: function(olZoom) {\n
        var zoom = null; \n
        if (olZoom != null) {\n
            zoom = olZoom + this.minZoomLevel;\n
            if (this.map.baseLayer !== this) {\n
                zoom = this.getZoomForResolution(\n
                    this.map.baseLayer.getResolutionForZoom(zoom)\n
                );\n
            }\n
        }\n
        return zoom;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Layer.FixedZoomLevels"\n
});\n
\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>12249</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
