<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.79</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>ArcIMS.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Layer/Grid.js\n
 * @requires OpenLayers/Format/ArcXML.js\n
 * @requires OpenLayers/Request.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Layer.ArcIMS\n
 * Instances of OpenLayers.Layer.ArcIMS are used to display data from ESRI ArcIMS\n
 *     Mapping Services. Create a new ArcIMS layer with the <OpenLayers.Layer.ArcIMS>\n
 *     constructor.\n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Layer.Grid>\n
 */\n
OpenLayers.Layer.ArcIMS = OpenLayers.Class(OpenLayers.Layer.Grid, {\n
\n
    /**\n
     * Constant: DEFAULT_PARAMS\n
     * {Object} Default query string parameters.\n
     */\n
    DEFAULT_PARAMS: { \n
        ClientVersion: "9.2",\n
        ServiceName: \'\'\n
    },\n
    \n
    /**\n
     * APIProperty: featureCoordSys\n
     * {String} Code for feature coordinate system.  Default is "4326".\n
     */\n
    featureCoordSys: "4326",\n
    \n
    /**\n
     * APIProperty: filterCoordSys\n
     * {String} Code for filter coordinate system.  Default is "4326".\n
     */\n
    filterCoordSys: "4326",\n
    \n
    /**\n
     * APIProperty: layers\n
     * {Array} An array of objects with layer properties.\n
     */\n
    layers: null,\n
    \n
    /**\n
     * APIProperty: async\n
     * {Boolean} Request images asynchronously.  Default is true.\n
     */\n
    async: true,\n
    \n
    /**\n
     * APIProperty: name\n
     * {String} Layer name.  Default is "ArcIMS".\n
     */\n
    name: "ArcIMS",\n
\n
    /**\n
     * APIProperty: isBaseLayer\n
     * {Boolean} The layer is a base layer.  Default is true.\n
     */\n
    isBaseLayer: true,\n
\n
    /**\n
     * Constant: DEFAULT_OPTIONS\n
     * {Object} Default layers properties.\n
     */\n
    DEFAULT_OPTIONS: {\n
        tileSize: new OpenLayers.Size(512, 512),\n
        featureCoordSys: "4326",\n
        filterCoordSys: "4326",\n
        layers: null,\n
        isBaseLayer: true,\n
        async: true,\n
        name: "ArcIMS"\n
    }, \n
 \n
    /**\n
     * Constructor: OpenLayers.Layer.ArcIMS\n
     * Create a new ArcIMS layer object.\n
     *\n
     * Example:\n
     * (code)\n
     * var arcims = new OpenLayers.Layer.ArcIMS(\n
     *     "Global Sample",\n
     *     "http://sample.avencia.com/servlet/com.esri.esrimap.Esrimap", \n
     *     {\n
     *         service: "OpenLayers_Sample", \n
     *         layers: [\n
     *             // layers to manipulate\n
     *             {id: "1", visible: true}\n
     *         ]\n
     *     }\n
     * );\n
     * (end)\n
     *\n
     * Parameters:\n
     * name - {String} A name for the layer\n
     * url - {String} Base url for the ArcIMS server\n
     * options - {Object} Optional object with properties to be set on the\n
     *     layer.\n
     */\n
    initialize: function(name, url, options) {\n
        \n
        this.tileSize = new OpenLayers.Size(512, 512);\n
\n
        // parameters\n
        this.params = OpenLayers.Util.applyDefaults(\n
            {ServiceName: options.serviceName},\n
            this.DEFAULT_PARAMS\n
        );\n
        this.options = OpenLayers.Util.applyDefaults(\n
            options, this.DEFAULT_OPTIONS\n
        );\n
          \n
        OpenLayers.Layer.Grid.prototype.initialize.apply(\n
            this, [name, url, this.params, options]\n
        );\n
\n
        //layer is transparent        \n
        if (this.transparent) {\n
            \n
            // unless explicitly set in options, make layer an overlay\n
            if (!this.isBaseLayer) {\n
                this.isBaseLayer = false;\n
            } \n
            \n
            // jpegs can never be transparent, so intelligently switch the \n
            //  format, depending on the browser\'s capabilities\n
            if (this.format == "image/jpeg") {\n
                this.format = OpenLayers.Util.alphaHack() ? "image/gif" : "image/png";\n
            }\n
        }\n
\n
        // create an empty layer list if no layers specified in the options\n
        if (this.options.layers === null) {\n
            this.options.layers = [];\n
        }\n
    },    \n
\n
    /**\n
     * Method: getURL\n
     * Return an image url this layer.\n
     *\n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>} A bounds representing the bbox for the\n
     *     request.\n
     *\n
     * Returns:\n
     * {String} A string with the map image\'s url.\n
     */\n
    getURL: function(bounds) {\n
        var url = "";\n
        bounds = this.adjustBounds(bounds);\n
        \n
        // create an arcxml request to generate the image\n
        var axlReq = new OpenLayers.Format.ArcXML( \n
            OpenLayers.Util.extend(this.options, {\n
                requesttype: "image",\n
                envelope: bounds.toArray(),\n
                tileSize: this.tileSize\n
            })\n
        );\n
        \n
        // create a synchronous ajax request to get an arcims image\n
        var req = new OpenLayers.Request.POST({\n
            url: this.getFullRequestString(),\n
            data: axlReq.write(),\n
            async: false\n
        });\n
        \n
        // if the response exists\n
        if (req != null) {\n
            var doc = req.responseXML;\n
\n
            if (!doc || !doc.documentElement) {            \n
                doc = req.responseText;\n
            }\n
\n
            // create a new arcxml format to read the response\n
            var axlResp = new OpenLayers.Format.ArcXML();\n
            var arcxml = axlResp.read(doc);\n
            url = this.getUrlOrImage(arcxml.image.output);\n
        }\n
        \n
        return url;\n
    },\n
    \n
    \n
    /**\n
     * Method: getURLasync\n
     * Get an image url this layer asynchronously, and execute a callback\n
     *     when the image url is generated.\n
     *\n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>} A bounds representing the bbox for the\n
     *     request.\n
     * callback - {Function} Function to call when image url is retrieved.\n
     * scope - {Object} The scope of the callback method.\n
     */\n
    getURLasync: function(bounds, callback, scope) {\n
        bounds = this.adjustBounds(bounds);\n
        \n
        // create an arcxml request to generate the image\n
        var axlReq = new OpenLayers.Format.ArcXML(  \n
            OpenLayers.Util.extend(this.options, { \n
                requesttype: "image",\n
                envelope: bounds.toArray(),\n
                tileSize: this.tileSize\n
            })\n
        );\n
        \n
        // create an asynchronous ajax request to get an arcims image\n
        OpenLayers.Request.POST({\n
            url: this.getFullRequestString(),\n
            async: true,\n
            data: axlReq.write(),\n
            callback: function(req) {\n
                // process the response from ArcIMS, and call the callback function\n
                // to set the image URL\n
                var doc = req.responseXML;\n
                if (!doc || !doc.documentElement) {            \n
                    doc = req.responseText;\n
                }\n
\n
                // create a new arcxml format to read the response\n
                var axlResp = new OpenLayers.Format.ArcXML();\n
                var arcxml = axlResp.read(doc);\n
                \n
                callback.call(scope, this.getUrlOrImage(arcxml.image.output));\n
            },\n
            scope: this\n
        });\n
    },\n
    \n
    /**\n
     * Method: getUrlOrImage\n
     * Extract a url or image from the ArcXML image output.\n
     *\n
     * Parameters:\n
     * output - {Object} The image.output property of the object returned from\n
     *     the ArcXML format read method.\n
     *\n
     * Returns:\n
     * {String} A URL for an image (potentially with the data protocol).\n
     */\n
    getUrlOrImage: function(output) {\n
        var ret = "";\n
        if(output.url) {\n
            // If the image response output url is a string, then the image\n
            // data is not inline.\n
            ret = output.url;\n
        } else if(output.data) {\n
            // The image data is inline and base64 encoded, create a data\n
            // url for the image.  This will only work for small images,\n
            // due to browser url length limits.\n
            ret = "data:image/" + output.type + \n
                  ";base64," + output.data;\n
        }\n
        return ret;\n
    },\n
    \n
    /**\n
     * Method: setLayerQuery\n
     * Set the query definition on this layer. Query definitions are used to\n
     *     render parts of the spatial data in an image, and can be used to\n
     *     filter features or layers in the ArcIMS service.\n
     *\n
     * Parameters:\n
     * id - {String} The ArcIMS layer ID.\n
     * querydef - {Object} The query definition to apply to this layer.\n
     */\n
    setLayerQuery: function(id, querydef) {\n
        // find the matching layer, if it exists\n
        for (var lyr = 0; lyr < this.options.layers.length; lyr++) {\n
            if (id == this.options.layers[lyr].id) {\n
                // replace this layer definition\n
                this.options.layers[lyr].query = querydef;\n
                return;\n
            }\n
        }\n
      \n
        // no layer found, create a new definition\n
        this.options.layers.push({id: id, visible: true, query: querydef});\n
    },\n
    \n
    /**\n
     * Method: getFeatureInfo\n
     * Get feature information from ArcIMS.  Using the applied geometry, apply\n
     *     the options to the query (buffer, area/envelope intersection), and\n
     *     query the ArcIMS service.\n
     *\n
     * A note about accuracy:\n
     * ArcIMS interprets the accuracy attribute in feature requests to be\n
     *     something like the \'modulus\' operator on feature coordinates,\n
     *     applied to the database geometry of the feature.  It doesn\'t round,\n
     *     so your feature coordinates may be up to (1 x accuracy) offset from\n
     *     the actual feature coordinates.  If the accuracy of the layer is not\n
     *     specified, the accuracy will be computed to be approximately 1\n
     *     feature coordinate per screen  pixel.\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.LonLat>} or {<OpenLayers.Geometry.Polygon>} The\n
     *     geometry to use when making the query. This should be a closed\n
     *     polygon for behavior approximating a free selection.\n
     * layer - {Object} The ArcIMS layer definition. This is an anonymous object\n
     *     that looks like:\n
     * (code)\n
     * {\n
     *     id: "ArcXML layer ID",  // the ArcXML layer ID\n
     *     query: {\n
     *         where: "STATE = \'PA\'",  // the where clause of the query\n
     *         accuracy: 100           // the accuracy of the returned feature\n
     *     }\n
     * }\n
     * (end)\n
     * options - {Object} Object with non-default properties to set on the layer.\n
     *     Supported properties are buffer, callback, scope, and any other\n
     *     properties applicable to the ArcXML format.  Set the \'callback\' and\n
     *     \'scope\' for an object and function to recieve the parsed features\n
     *     from ArcIMS.\n
     */\n
    getFeatureInfo: function(geometry, layer, options) {\n
        // set the buffer to 1 unit (dd/m/ft?) by default\n
        var buffer = options.buffer || 1;\n
        // empty callback by default\n
        var callback = options.callback || function() {};\n
        // default scope is window (global)\n
        var scope = options.scope || window;\n
\n
        // apply these option to the request options\n
        var requestOptions = {};\n
        OpenLayers.Util.extend(requestOptions, this.options);\n
\n
        // this is a feature request\n
        requestOptions.requesttype = "feature";\n
\n
        if (geometry instanceof OpenLayers.LonLat) {\n
            // create an envelope if the geometry is really a lon/lat\n
            requestOptions.polygon = null;\n
            requestOptions.envelope = [ \n
                geometry.lon - buffer, \n
                geometry.lat - buffer,\n
                geometry.lon + buffer,\n
                geometry.lat + buffer\n
            ];\n
        } else if (geometry instanceof OpenLayers.Geometry.Polygon) {\n
            // use the polygon assigned, and empty the envelope\n
            requestOptions.envelope = null;\n
            requestOptions.polygon = geometry;\n
        }\n
      \n
        // create an arcxml request to get feature requests\n
        var arcxml = new OpenLayers.Format.ArcXML(requestOptions);\n
\n
        // apply any get feature options to the arcxml request\n
        OpenLayers.Util.extend(arcxml.request.get_feature, options);\n
\n
        arcxml.request.get_feature.layer = layer.id;\n
        if (typeof layer.query.accuracy == "number") {\n
            // set the accuracy if it was specified\n
            arcxml.request.get_feature.query.accuracy = layer.query.accuracy;\n
        } else {\n
            // guess that the accuracy is 1 per screen pixel\n
            var mapCenter = this.map.getCenter();\n
            var viewPx = this.map.getViewPortPxFromLonLat(mapCenter);\n
            viewPx.x++;\n
            var mapOffCenter = this.map.getLonLatFromPixel(viewPx);\n
            arcxml.request.get_feature.query.accuracy = mapOffCenter.lon - mapCenter.lon;\n
        }\n
        \n
        // set the get_feature query to be the same as the layer passed in\n
        arcxml.request.get_feature.query.where = layer.query.where;\n
        \n
        // use area_intersection\n
        arcxml.request.get_feature.query.spatialfilter.relation = "area_intersection";\n
      \n
        // create a new asynchronous request to get the feature info\n
        OpenLayers.Request.POST({\n
            url: this.getFullRequestString({\'CustomService\': \'Query\'}),\n
            data: arcxml.write(),\n
            callback: function(request) {\n
                // parse the arcxml response\n
                var response = arcxml.parseResponse(request.responseText);\n
                \n
                if (!arcxml.iserror()) {\n
                    // if the arcxml is not an error, call the callback with the features parsed\n
                    callback.call(scope, response.features);\n
                } else {\n
                    // if the arcxml is an error, return null features selected\n
                    callback.call(scope, null);\n
                }\n
            }\n
        });\n
    },\n
\n
    /**\n
     * Method: clone\n
     * Create a clone of this layer\n
     *\n
     * Returns:\n
     * {<OpenLayers.Layer.ArcIMS>} An exact clone of this layer\n
     */\n
    clone: function (obj) {\n
\n
        if (obj == null) {\n
            obj = new OpenLayers.Layer.ArcIMS(this.name,\n
                                           this.url,\n
                                           this.getOptions());\n
        }\n
\n
        //get all additions from superclasses\n
        obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);\n
\n
        // copy/set any non-init, non-simple values here\n
\n
        return obj;\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Layer.ArcIMS"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>14638</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
