<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.78</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>MapGuide.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Request/XMLHttpRequest.js\n
 * @requires OpenLayers/Layer/Grid.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Layer.MapGuide\n
 * Instances of OpenLayers.Layer.MapGuide are used to display\n
 * data from a MapGuide OS instance.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Layer.Grid>\n
 */\n
OpenLayers.Layer.MapGuide = OpenLayers.Class(OpenLayers.Layer.Grid, {\n
\n
    /** \n
     * APIProperty: isBaseLayer\n
     * {Boolean} Treat this layer as a base layer.  Default is true.\n
     **/\n
    isBaseLayer: true,\n
    \n
    /**\n
     * APIProperty: useHttpTile\n
     * {Boolean} use a tile cache exposed directly via a webserver rather than the \n
     *    via mapguide server. This does require extra configuration on the Mapguide Server,\n
     *    and will only work when singleTile is false. The url for the layer must be set to the\n
     *    webserver path rather than the Mapguide mapagent.\n
     *    See http://trac.osgeo.org/mapguide/wiki/CodeSamples/Tiles/ServingTilesViaHttp\n
     **/\n
    useHttpTile: false,\n
    \n
    /** \n
     * APIProperty: singleTile\n
     * {Boolean} use tile server or request single tile image. \n
     **/\n
    singleTile: false,\n
    \n
    /** \n
     * APIProperty: useOverlay\n
     * {Boolean} flag to indicate if the layer should be retrieved using\n
     * GETMAPIMAGE (default) or using GETDYNAMICOVERLAY requests.\n
     **/\n
    useOverlay: false,\n
    \n
    /** \n
     * APIProperty: useAsyncOverlay\n
     * {Boolean} indicates if the MapGuide site supports the asynchronous \n
     * GETDYNAMICOVERLAY requests which is available in MapGuide Enterprise 2010\n
     * and MapGuide Open Source v2.0.3 or higher. The newer versions of MG \n
     * is called asynchronously, allows selections to be drawn separately from \n
     * the map and offers styling options.\n
     * \n
     * With older versions of MapGuide, set useAsyncOverlay=false.  Note that in\n
     * this case a synchronous AJAX call is issued and the mapname and session\n
     * parameters must be used to initialize the layer, not the mapdefinition\n
     * parameter. Also note that this will issue a synchronous AJAX request \n
     * before the image request can be issued so the users browser may lock\n
     * up if the MG Web tier does not respond in a timely fashion.\n
     **/\n
    useAsyncOverlay: true,\n
    \n
    /**\n
     * Constant: TILE_PARAMS\n
     * {Object} Hashtable of default parameter key/value pairs for tiled layer\n
     */\n
    TILE_PARAMS: {\n
         operation: \'GETTILEIMAGE\',\n
         version: \'1.2.0\'\n
    },\n
\n
    /**\n
     * Constant: SINGLE_TILE_PARAMS\n
     * {Object} Hashtable of default parameter key/value pairs for untiled layer\n
     */\n
    SINGLE_TILE_PARAMS: {\n
        operation: \'GETMAPIMAGE\',\n
        format: \'PNG\',\n
        locale: \'en\',\n
        clip: \'1\',\n
        version: \'1.0.0\'\n
    },\n
    \n
    /**\n
     * Constant: OVERLAY_PARAMS\n
     * {Object} Hashtable of default parameter key/value pairs for untiled layer\n
     */\n
    OVERLAY_PARAMS: {\n
        operation: \'GETDYNAMICMAPOVERLAYIMAGE\',\n
        format: \'PNG\',\n
        locale: \'en\',\n
        clip: \'1\',\n
        version: \'2.0.0\'\n
    },\n
    \n
    /** \n
     * Constant: FOLDER_PARAMS\n
     * {Object} Hashtable of parameter key/value pairs which describe \n
     * the folder structure for tiles as configured in the mapguide \n
     * serverconfig.ini section [TileServiceProperties]\n
     */\n
    FOLDER_PARAMS: {\n
        tileColumnsPerFolder: 30,\n
        tileRowsPerFolder: 30,\n
        format: \'png\',\n
        querystring: null\n
    },\t\n
\n
    /** \n
     * Property: defaultSize\n
     * {<OpenLayers.Size>} Tile size as produced by MapGuide server\n
     **/\n
    defaultSize: new OpenLayers.Size(300,300),\n
\n
    /** \n
     * Property: tileOriginCorner\n
     * {String} MapGuide tile server uses top-left as tile origin\n
     **/\n
    tileOriginCorner: "tl",\n
\n
    /**\n
     * Constructor: OpenLayers.Layer.MapGuide\n
     * Create a new Mapguide layer, either tiled or untiled.  \n
     *\n
     * For tiled layers, the \'groupName\' and \'mapDefinition\' values \n
     * must be specified as parameters in the constructor.\n
     *\n
     * For untiled base layers, specify either combination of \'mapName\' and\n
     * \'session\', or \'mapDefinition\' and \'locale\'.  \n
     *\n
     * For older versions of MapGuide and overlay layers, set useAsyncOverlay \n
     * to false and in this case mapName and session are required parameters \n
     * for the constructor.\n
     *\n
     * NOTE: MapGuide OS uses a DPI value and degrees to meters conversion \n
     * factor that are different than the defaults used in OpenLayers, \n
     * so these must be adjusted accordingly in your application.  \n
     * See the MapGuide example for how to set these values for MGOS.\n
     *\n
     * Parameters:\n
     * name - {String} Name of the layer displayed in the interface\n
     * url - {String} Location of the MapGuide mapagent executable\n
     *            (e.g. http://localhost:8008/mapguide/mapagent/mapagent.fcgi)\n
     * params - {Object} hashtable of additional parameters to use. Some\n
     *     parameters may require additional code on the server. The ones that\n
     *     you may want to use are: \n
     *   - mapDefinition - {String} The MapGuide resource definition\n
     *            (e.g. Library://Samples/Gmap/Maps/gmapTiled.MapDefinition)\n
     *   - locale - Locale setting \n
     *            (for untiled overlays layers only)\n
     *   - mapName - {String} Name of the map as stored in the MapGuide session.\n
     *          (for untiled layers with a session parameter only)\n
     *   - session - { String} MapGuide session ID \n
     *            (for untiled overlays layers only)\n
     *   - basemaplayergroupname - {String} GroupName for tiled MapGuide layers only\n
     *   - format - Image format to be returned (for untiled overlay layers only)\n
     *   - showLayers - {String} A comma separated list of GUID\'s for the\n
     *       layers to display eg: \'cvc-xcv34,453-345-345sdf\'.\n
     *   - hideLayers - {String} A comma separated list of GUID\'s for the\n
     *       layers to hide eg: \'cvc-xcv34,453-345-345sdf\'.\n
     *   - showGroups - {String} A comma separated list of GUID\'s for the\n
     *       groups to display eg: \'cvc-xcv34,453-345-345sdf\'.\n
     *   - hideGroups - {String} A comma separated list of GUID\'s for the\n
     *       groups to hide eg: \'cvc-xcv34,453-345-345sdf\'\n
     *   - selectionXml - {String} A selection xml string Some server plumbing\n
     *       is required to read such a value.\n
     * options - {Object} Hashtable of extra options to tag onto the layer; \n
     *          will vary depending if tiled or untiled maps are being requested\n
     */\n
    initialize: function(name, url, params, options) {\n
        \n
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, arguments);\n
        \n
        // unless explicitly set in options, if the layer is transparent, \n
        // it will be an overlay\n
        if (options == null || options.isBaseLayer == null) {\n
            this.isBaseLayer = ((this.transparent != "true") && \n
                                (this.transparent != true));\n
        }\n
\n
        if (options && options.useOverlay!=null) {\n
          this.useOverlay = options.useOverlay;\n
        }\n
        \n
        //initialize for untiled layers\n
        if (this.singleTile) {\n
          if (this.useOverlay) {\n
            OpenLayers.Util.applyDefaults(\n
                           this.params,\n
                           this.OVERLAY_PARAMS\n
                           );\n
            if (!this.useAsyncOverlay) {\n
              this.params.version = "1.0.0";\n
            }\n
          } else {\n
            OpenLayers.Util.applyDefaults(\n
                           this.params,\n
                           this.SINGLE_TILE_PARAMS\n
                           );\n
          }         \n
        } else {\n
            //initialize for tiled layers\n
            if (this.useHttpTile) {\n
                OpenLayers.Util.applyDefaults(\n
                               this.params,\n
                               this.FOLDER_PARAMS\n
                               );\n
            } else {\n
                OpenLayers.Util.applyDefaults(\n
                               this.params,\n
                               this.TILE_PARAMS\n
                               );\n
            }\n
            this.setTileSize(this.defaultSize); \n
        }\n
    },\n
\n
    /**\n
     * Method: clone\n
     * Create a clone of this layer\n
     *\n
     * Returns:\n
     * {<OpenLayers.Layer.MapGuide>} An exact clone of this layer\n
     */\n
    clone: function (obj) {\n
      if (obj == null) {\n
            obj = new OpenLayers.Layer.MapGuide(this.name,\n
                                           this.url,\n
                                           this.params,\n
                                           this.getOptions());\n
      }\n
      //get all additions from superclasses\n
      obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);\n
\n
      return obj;\n
    },\n
\n
    /**\n
     * Method: getURL\n
     * Return a query string for this layer\n
     *\n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>} A bounds representing the bbox \n
     *                                for the request\n
     *\n
     * Returns:\n
     * {String} A string with the layer\'s url and parameters and also \n
     *          the passed-in bounds and appropriate tile size specified \n
     *          as parameters.\n
     */\n
    getURL: function (bounds) {\n
        var url;\n
        var center = bounds.getCenterLonLat();\n
        var mapSize = this.map.getSize();\n
\n
        if (this.singleTile) {\n
          //set up the call for GETMAPIMAGE or GETDYNAMICMAPOVERLAY with\n
          //dynamic map parameters\n
          var params = {\n
            setdisplaydpi: OpenLayers.DOTS_PER_INCH,\n
            setdisplayheight: mapSize.h*this.ratio,\n
            setdisplaywidth: mapSize.w*this.ratio,\n
            setviewcenterx: center.lon,\n
            setviewcentery: center.lat,\n
            setviewscale: this.map.getScale()\n
          };\n
          \n
          if (this.useOverlay && !this.useAsyncOverlay) {\n
            //first we need to call GETVISIBLEMAPEXTENT to set the extent\n
            var getVisParams = {};\n
            getVisParams = OpenLayers.Util.extend(getVisParams, params);\n
            getVisParams.operation = "GETVISIBLEMAPEXTENT";\n
            getVisParams.version = "1.0.0";\n
            getVisParams.session = this.params.session;\n
            getVisParams.mapName = this.params.mapName;\n
            getVisParams.format = \'text/xml\';\n
            url = this.getFullRequestString( getVisParams );\n
            \n
            OpenLayers.Request.GET({url: url, async: false});\n
          }\n
          //construct the full URL\n
          url = this.getFullRequestString( params );\n
        } else {\n
\n
          //tiled version\n
          var currentRes = this.map.getResolution();\n
          var colidx = Math.floor((bounds.left-this.maxExtent.left)/currentRes);\n
          colidx = Math.round(colidx/this.tileSize.w);\n
          var rowidx = Math.floor((this.maxExtent.top-bounds.top)/currentRes);\n
          rowidx = Math.round(rowidx/this.tileSize.h);\n
\n
          if (this.useHttpTile){\n
\t          url = this.getImageFilePath(\n
                   {\n
                       tilecol: colidx,\n
                       tilerow: rowidx,\n
                       scaleindex: this.resolutions.length - this.map.zoom - 1\n
                    });\n
\t\t  \n
          } else {\n
            url = this.getFullRequestString(\n
                   {\n
                       tilecol: colidx,\n
                       tilerow: rowidx,\n
                       scaleindex: this.resolutions.length - this.map.zoom - 1\n
                    });\n
          }\n
       }\n
       return url;\n
    },\n
\n
    /**\n
     * Method: getFullRequestString\n
     * getFullRequestString on MapGuide layers is special, because we \n
     * do a regular expression replace on \',\' in parameters to \'+\'.\n
     * This is why it is subclassed here.\n
     *\n
     * Parameters:\n
     * altUrl - {String} Alternative base URL to use.\n
     *\n
     * Returns:\n
     * {String} A string with the layer\'s url appropriately encoded for MapGuide\n
     */\n
    getFullRequestString:function(newParams, altUrl) {\n
        // use layer\'s url unless altUrl passed in\n
        var url = (altUrl == null) ? this.url : altUrl;\n
        \n
        // if url is not a string, it should be an array of strings, \n
        //  in which case we will randomly select one of them in order\n
        //  to evenly distribute requests to different urls.\n
        if (typeof url == "object") {\n
            url = url[Math.floor(Math.random()*url.length)];\n
        }   \n
        // requestString always starts with url\n
        var requestString = url;        \n
\n
        // create a new params hashtable with all the layer params and the \n
        // new params together. then convert to string\n
        var allParams = OpenLayers.Util.extend({}, this.params);\n
        allParams = OpenLayers.Util.extend(allParams, newParams);\n
        // ignore parameters that are already in the url search string\n
        var urlParams = OpenLayers.Util.upperCaseObject(\n
                            OpenLayers.Util.getParameters(url));\n
        for(var key in allParams) {\n
            if(key.toUpperCase() in urlParams) {\n
                delete allParams[key];\n
            }\n
        }\n
        var paramsString = OpenLayers.Util.getParameterString(allParams);\n
        \n
        /* MapGuide needs \'+\' seperating things like bounds/height/width.\n
           Since typically this is URL encoded, we use a slight hack: we\n
           depend on the list-like functionality of getParameterString to\n
           leave \',\' only in the case of list items (since otherwise it is\n
           encoded) then do a regular expression replace on the , characters\n
           to \'+\' */\n
        paramsString = paramsString.replace(/,/g, "+");\n
        \n
        if (paramsString != "") {\n
            var lastServerChar = url.charAt(url.length - 1);\n
            if ((lastServerChar == "&") || (lastServerChar == "?")) {\n
                requestString += paramsString;\n
            } else {\n
                if (url.indexOf(\'?\') == -1) {\n
                    //serverPath has no ? -- add one\n
                    requestString += \'?\' + paramsString;\n
                } else {\n
                    //serverPath contains ?, so must already have paramsString at the end\n
                    requestString += \'&\' + paramsString;\n
                }\n
            }\n
        }\n
        return requestString;\n
    },\n
\n
     /** \n
     * Method: getImageFilePath\n
     * special handler to request mapguide tiles from an http exposed tilecache \n
     *\n
     * Parameters:\n
     * altUrl - {String} Alternative base URL to use.\n
     *\n
     * Returns:\n
     * {String} A string with the url for the tile image\n
     */\n
    getImageFilePath:function(newParams, altUrl) {\n
        // use layer\'s url unless altUrl passed in\n
        var url = (altUrl == null) ? this.url : altUrl;\n
        \n
        // if url is not a string, it should be an array of strings, \n
        //  in which case we will randomly select one of them in order\n
        //  to evenly distribute requests to different urls.\n
        if (typeof url == "object") {\n
            url = url[Math.floor(Math.random()*url.length)];\n
        }   \n
        // requestString always starts with url\n
        var requestString = url;        \n
\n
        var tileRowGroup = "";\n
        var tileColGroup = "";\n
        \n
        if (newParams.tilerow < 0) {\n
          tileRowGroup =  \'-\';\n
        }\n
          \n
        if (newParams.tilerow == 0 ) {\n
          tileRowGroup += \'0\';\n
        } else {\n
          tileRowGroup += Math.floor(Math.abs(newParams.tilerow/this.params.tileRowsPerFolder)) * this.params.tileRowsPerFolder;\n
        }\n
          \n
        if (newParams.tilecol < 0) {\n
          tileColGroup =  \'-\';\n
        }\n
        \n
        if (newParams.tilecol == 0) {\n
          tileColGroup += \'0\';\n
        } else {\n
          tileColGroup += Math.floor(Math.abs(newParams.tilecol/this.params.tileColumnsPerFolder)) * this.params.tileColumnsPerFolder;\n
        }\t\t\t\t\t\n
        \n
        var tilePath = \'/S\' + Math.floor(newParams.scaleindex)\n
                + \'/\' + this.params.basemaplayergroupname\n
                + \'/R\' + tileRowGroup\n
                + \'/C\' + tileColGroup\n
                + \'/\' + (newParams.tilerow % this.params.tileRowsPerFolder) \n
                + \'_\' + (newParams.tilecol % this.params.tileColumnsPerFolder) \n
                + \'.\' + this.params.format;\n
    \n
        if (this.params.querystring) {\n
               tilePath += "?" + this.params.querystring;\n
        }\n
        \n
        requestString += tilePath;\n
        return requestString;\n
    },\n
    \n
    /** \n
     * Method: calculateGridLayout\n
     * Generate parameters for the grid layout. This  \n
     *\n
     * Parameters:\n
     * bounds - {<OpenLayers.Bound>}\n
     * origin - {<OpenLayers.LonLat>}\n
     * resolution - {Number}\n
     *\n
     * Returns:\n
     * {Object} Object containing properties tilelon, tilelat, tileoffsetlat,\n
     * tileoffsetlat, tileoffsetx, tileoffsety\n
     */\n
    calculateGridLayout: function(bounds, origin, resolution) {\n
        var tilelon = resolution * this.tileSize.w;\n
        var tilelat = resolution * this.tileSize.h;\n
        \n
        var offsetlon = bounds.left - origin.lon;\n
        var tilecol = Math.floor(offsetlon/tilelon) - this.buffer;\n
        var tilecolremain = offsetlon/tilelon - tilecol;\n
        var tileoffsetx = -tilecolremain * this.tileSize.w;\n
        var tileoffsetlon = origin.lon + tilecol * tilelon;\n
        \n
        var offsetlat = origin.lat - bounds.top + tilelat; \n
        var tilerow = Math.floor(offsetlat/tilelat) - this.buffer;\n
        var tilerowremain = tilerow - offsetlat/tilelat;\n
        var tileoffsety = tilerowremain * this.tileSize.h;\n
        var tileoffsetlat = origin.lat - tilelat*tilerow;\n
        \n
        return { \n
          tilelon: tilelon, tilelat: tilelat,\n
          tileoffsetlon: tileoffsetlon, tileoffsetlat: tileoffsetlat,\n
          tileoffsetx: tileoffsetx, tileoffsety: tileoffsety\n
        };\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Layer.MapGuide"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>18252</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
