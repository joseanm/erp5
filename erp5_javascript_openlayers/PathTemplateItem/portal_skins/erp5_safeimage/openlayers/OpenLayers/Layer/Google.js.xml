<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.78</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Google.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/Layer/SphericalMercator.js\n
 * @requires OpenLayers/Layer/EventPane.js\n
 * @requires OpenLayers/Layer/FixedZoomLevels.js\n
 * @requires OpenLayers/Lang.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Layer.Google\n
 * \n
 * Provides a wrapper for Google\'s Maps API\n
 * Normally the Terms of Use for this API do not allow wrapping, but Google\n
 * have provided written consent to OpenLayers for this - see email in \n
 * http://osgeo-org.1560.n6.nabble.com/Google-Maps-API-Terms-of-Use-changes-tp4910013p4911981.html\n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Layer.SphericalMercator>\n
 *  - <OpenLayers.Layer.EventPane>\n
 *  - <OpenLayers.Layer.FixedZoomLevels>\n
 */\n
OpenLayers.Layer.Google = OpenLayers.Class(\n
    OpenLayers.Layer.EventPane, \n
    OpenLayers.Layer.FixedZoomLevels, {\n
    \n
    /** \n
     * Constant: MIN_ZOOM_LEVEL\n
     * {Integer} 0 \n
     */\n
    MIN_ZOOM_LEVEL: 0,\n
    \n
    /** \n
     * Constant: MAX_ZOOM_LEVEL\n
     * {Integer} 21\n
     */\n
    MAX_ZOOM_LEVEL: 21,\n
\n
    /** \n
     * Constant: RESOLUTIONS\n
     * {Array(Float)} Hardcode these resolutions so that they are more closely\n
     *                tied with the standard wms projection\n
     */\n
    RESOLUTIONS: [\n
        1.40625, \n
        0.703125, \n
        0.3515625, \n
        0.17578125, \n
        0.087890625, \n
        0.0439453125,\n
        0.02197265625, \n
        0.010986328125, \n
        0.0054931640625, \n
        0.00274658203125,\n
        0.001373291015625, \n
        0.0006866455078125, \n
        0.00034332275390625,\n
        0.000171661376953125, \n
        0.0000858306884765625, \n
        0.00004291534423828125,\n
        0.00002145767211914062, \n
        0.00001072883605957031,\n
        0.00000536441802978515, \n
        0.00000268220901489257,\n
        0.0000013411045074462891,\n
        0.00000067055225372314453\n
    ],\n
\n
    /**\n
     * APIProperty: type\n
     * {GMapType}\n
     */\n
    type: null,\n
\n
    /**\n
     * APIProperty: wrapDateLine\n
     * {Boolean} Allow user to pan forever east/west.  Default is true.  \n
     *     Setting this to false only restricts panning if \n
     *     <sphericalMercator> is true. \n
     */\n
    wrapDateLine: true,\n
\n
    /**\n
     * APIProperty: sphericalMercator\n
     * {Boolean} Should the map act as a mercator-projected map? This will\n
     *     cause all interactions with the map to be in the actual map \n
     *     projection, which allows support for vector drawing, overlaying \n
     *     other maps, etc. \n
     */\n
    sphericalMercator: false, \n
    \n
    /**\n
     * Property: version\n
     * {Number} The version of the Google Maps API\n
     */\n
    version: null,\n
\n
    /** \n
     * Constructor: OpenLayers.Layer.Google\n
     * \n
     * Parameters:\n
     * name - {String} A name for the layer.\n
     * options - {Object} An optional object whose properties will be set\n
     *     on the layer.\n
     */\n
    initialize: function(name, options) {\n
        options = options || {};\n
        if(!options.version) {\n
            options.version = typeof GMap2 === "function" ? "2" : "3";\n
        }\n
        var mixin = OpenLayers.Layer.Google["v" +\n
            options.version.replace(/\\./g, "_")];\n
        if (mixin) {\n
            OpenLayers.Util.applyDefaults(options, mixin);\n
        } else {\n
            throw "Unsupported Google Maps API version: " + options.version;\n
        }\n
\n
        OpenLayers.Util.applyDefaults(options, mixin.DEFAULTS);\n
        if (options.maxExtent) {\n
            options.maxExtent = options.maxExtent.clone();\n
        }\n
\n
        OpenLayers.Layer.EventPane.prototype.initialize.apply(this,\n
            [name, options]);\n
        OpenLayers.Layer.FixedZoomLevels.prototype.initialize.apply(this, \n
            [name, options]);\n
\n
        if (this.sphericalMercator) {\n
            OpenLayers.Util.extend(this, OpenLayers.Layer.SphericalMercator);\n
            this.initMercatorParameters();\n
        }    \n
    },\n
\n
    /**\n
     * Method: clone\n
     * Create a clone of this layer\n
     *\n
     * Returns:\n
     * {<OpenLayers.Layer.Google>} An exact clone of this layer\n
     */\n
    clone: function() {\n
        /**\n
         * This method isn\'t intended to be called by a subclass and it\n
         * doesn\'t call the same method on the superclass.  We don\'t call\n
         * the super\'s clone because we don\'t want properties that are set\n
         * on this layer after initialize (i.e. this.mapObject etc.).\n
         */\n
        return new OpenLayers.Layer.Google(\n
            this.name, this.getOptions()\n
        );\n
    },\n
\n
    /**\n
     * APIMethod: setVisibility\n
     * Set the visibility flag for the layer and hide/show & redraw \n
     *     accordingly. Fire event unless otherwise specified\n
     * \n
     * Note that visibility is no longer simply whether or not the layer\'s\n
     *     style.display is set to "block". Now we store a \'visibility\' state \n
     *     property on the layer class, this allows us to remember whether or \n
     *     not we *desire* for a layer to be visible. In the case where the \n
     *     map\'s resolution is out of the layer\'s range, this desire may be \n
     *     subverted.\n
     * \n
     * Parameters:\n
     * visible - {Boolean} Display the layer (if in range)\n
     */\n
    setVisibility: function(visible) {\n
        // sharing a map container, opacity has to be set per layer\n
        var opacity = this.opacity == null ? 1 : this.opacity;\n
        OpenLayers.Layer.EventPane.prototype.setVisibility.apply(this, arguments);\n
        this.setOpacity(opacity);\n
    },\n
    \n
    /** \n
     * APIMethod: display\n
     * Hide or show the Layer\n
     * \n
     * Parameters:\n
     * visible - {Boolean}\n
     */\n
    display: function(visible) {\n
        if (!this._dragging) {\n
            this.setGMapVisibility(visible);\n
        }\n
        OpenLayers.Layer.EventPane.prototype.display.apply(this, arguments);\n
    },\n
    \n
    /**\n
     * Method: moveTo\n
     * \n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>}\n
     * zoomChanged - {Boolean} Tells when zoom has changed, as layers have to\n
     *     do some init work in that case.\n
     * dragging - {Boolean}\n
     */\n
    moveTo: function(bounds, zoomChanged, dragging) {\n
        this._dragging = dragging;\n
        OpenLayers.Layer.EventPane.prototype.moveTo.apply(this, arguments);\n
        delete this._dragging;\n
    },\n
    \n
    /**\n
     * APIMethod: setOpacity\n
     * Sets the opacity for the entire layer (all images)\n
     * \n
     * Parameters:\n
     * opacity - {Float}\n
     */\n
    setOpacity: function(opacity) {\n
        if (opacity !== this.opacity) {\n
            if (this.map != null) {\n
                this.map.events.triggerEvent("changelayer", {\n
                    layer: this,\n
                    property: "opacity"\n
                });\n
            }\n
            this.opacity = opacity;\n
        }\n
        // Though this layer\'s opacity may not change, we\'re sharing a container\n
        // and need to update the opacity for the entire container.\n
        if (this.getVisibility()) {\n
            var container = this.getMapContainer();\n
            OpenLayers.Util.modifyDOMElement(\n
                container, null, null, null, null, null, null, opacity\n
            );\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: destroy\n
     * Clean up this layer.\n
     */\n
    destroy: function() {\n
        /**\n
         * We have to override this method because the event pane destroy\n
         * deletes the mapObject reference before removing this layer from\n
         * the map.\n
         */\n
        if (this.map) {\n
            this.setGMapVisibility(false);\n
            var cache = OpenLayers.Layer.Google.cache[this.map.id];\n
            if (cache && cache.count <= 1) {\n
                this.removeGMapElements();\n
            }            \n
        }\n
        OpenLayers.Layer.EventPane.prototype.destroy.apply(this, arguments);\n
    },\n
    \n
    /**\n
     * Method: removeGMapElements\n
     * Remove all elements added to the dom.  This should only be called if\n
     * this is the last of the Google layers for the given map.\n
     */\n
    removeGMapElements: function() {\n
        var cache = OpenLayers.Layer.Google.cache[this.map.id];\n
        if (cache) {\n
            // remove shared elements from dom\n
            var container = this.mapObject && this.getMapContainer();                \n
            if (container && container.parentNode) {\n
                container.parentNode.removeChild(container);\n
            }\n
            var termsOfUse = cache.termsOfUse;\n
            if (termsOfUse && termsOfUse.parentNode) {\n
                termsOfUse.parentNode.removeChild(termsOfUse);\n
            }\n
            var poweredBy = cache.poweredBy;\n
            if (poweredBy && poweredBy.parentNode) {\n
                poweredBy.parentNode.removeChild(poweredBy);\n
            }\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: removeMap\n
     * On being removed from the map, also remove termsOfUse and poweredBy divs\n
     * \n
     * Parameters:\n
     * map - {<OpenLayers.Map>}\n
     */\n
    removeMap: function(map) {\n
        // hide layer before removing\n
        if (this.visibility && this.mapObject) {\n
            this.setGMapVisibility(false);\n
        }\n
        // check to see if last Google layer in this map\n
        var cache = OpenLayers.Layer.Google.cache[map.id];\n
        if (cache) {\n
            if (cache.count <= 1) {\n
                this.removeGMapElements();\n
                delete OpenLayers.Layer.Google.cache[map.id];\n
            } else {\n
                // decrement the layer count\n
                --cache.count;\n
            }\n
        }\n
        // remove references to gmap elements\n
        delete this.termsOfUse;\n
        delete this.poweredBy;\n
        delete this.mapObject;\n
        delete this.dragObject;\n
        OpenLayers.Layer.EventPane.prototype.removeMap.apply(this, arguments);\n
    },\n
    \n
  //\n
  // TRANSLATION: MapObject Bounds <-> OpenLayers.Bounds\n
  //\n
\n
    /**\n
     * APIMethod: getOLBoundsFromMapObjectBounds\n
     * \n
     * Parameters:\n
     * moBounds - {Object}\n
     * \n
     * Returns:\n
     * {<OpenLayers.Bounds>} An <OpenLayers.Bounds>, translated from the \n
     *                       passed-in MapObject Bounds.\n
     *                       Returns null if null value is passed in.\n
     */\n
    getOLBoundsFromMapObjectBounds: function(moBounds) {\n
        var olBounds = null;\n
        if (moBounds != null) {\n
            var sw = moBounds.getSouthWest();\n
            var ne = moBounds.getNorthEast();\n
            if (this.sphericalMercator) {\n
                sw = this.forwardMercator(sw.lng(), sw.lat());\n
                ne = this.forwardMercator(ne.lng(), ne.lat());\n
            } else {\n
                sw = new OpenLayers.LonLat(sw.lng(), sw.lat()); \n
                ne = new OpenLayers.LonLat(ne.lng(), ne.lat()); \n
            }    \n
            olBounds = new OpenLayers.Bounds(sw.lon, \n
                                             sw.lat, \n
                                             ne.lon, \n
                                             ne.lat );\n
        }\n
        return olBounds;\n
    },\n
\n
    /** \n
     * APIMethod: getWarningHTML\n
     * \n
     * Returns: \n
     * {String} String with information on why layer is broken, how to get\n
     *          it working.\n
     */\n
    getWarningHTML:function() {\n
        return OpenLayers.i18n("googleWarning");\n
    },\n
\n
\n
    /************************************\n
     *                                  *\n
     *   MapObject Interface Controls   *\n
     *                                  *\n
     ************************************/\n
\n
\n
  // Get&Set Center, Zoom\n
\n
    /**\n
     * APIMethod: getMapObjectCenter\n
     * \n
     * Returns: \n
     * {Object} The mapObject\'s current center in Map Object format\n
     */\n
    getMapObjectCenter: function() {\n
        return this.mapObject.getCenter();\n
    },\n
\n
    /** \n
     * APIMethod: getMapObjectZoom\n
     * \n
     * Returns:\n
     * {Integer} The mapObject\'s current zoom, in Map Object format\n
     */\n
    getMapObjectZoom: function() {\n
        return this.mapObject.getZoom();\n
    },\n
\n
  \n
    /************************************\n
     *                                  *\n
     *       MapObject Primitives       *\n
     *                                  *\n
     ************************************/\n
\n
\n
  // LonLat\n
    \n
    /**\n
     * APIMethod: getLongitudeFromMapObjectLonLat\n
     * \n
     * Parameters:\n
     * moLonLat - {Object} MapObject LonLat format\n
     * \n
     * Returns:\n
     * {Float} Longitude of the given MapObject LonLat\n
     */\n
    getLongitudeFromMapObjectLonLat: function(moLonLat) {\n
        return this.sphericalMercator ? \n
          this.forwardMercator(moLonLat.lng(), moLonLat.lat()).lon :\n
          moLonLat.lng();  \n
    },\n
\n
    /**\n
     * APIMethod: getLatitudeFromMapObjectLonLat\n
     * \n
     * Parameters:\n
     * moLonLat - {Object} MapObject LonLat format\n
     * \n
     * Returns:\n
     * {Float} Latitude of the given MapObject LonLat\n
     */\n
    getLatitudeFromMapObjectLonLat: function(moLonLat) {\n
        var lat = this.sphericalMercator ? \n
          this.forwardMercator(moLonLat.lng(), moLonLat.lat()).lat :\n
          moLonLat.lat(); \n
        return lat;  \n
    },\n
    \n
  // Pixel\n
    \n
    /**\n
     * APIMethod: getXFromMapObjectPixel\n
     * \n
     * Parameters:\n
     * moPixel - {Object} MapObject Pixel format\n
     * \n
     * Returns:\n
     * {Integer} X value of the MapObject Pixel\n
     */\n
    getXFromMapObjectPixel: function(moPixel) {\n
        return moPixel.x;\n
    },\n
\n
    /**\n
     * APIMethod: getYFromMapObjectPixel\n
     * \n
     * Parameters:\n
     * moPixel - {Object} MapObject Pixel format\n
     * \n
     * Returns:\n
     * {Integer} Y value of the MapObject Pixel\n
     */\n
    getYFromMapObjectPixel: function(moPixel) {\n
        return moPixel.y;\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Layer.Google"\n
});\n
\n
/**\n
 * Property: OpenLayers.Layer.Google.cache\n
 * {Object} Cache for elements that should only be created once per map.\n
 */\n
OpenLayers.Layer.Google.cache = {};\n
\n
\n
/**\n
 * Constant: OpenLayers.Layer.Google.v2\n
 * \n
 * Mixin providing functionality specific to the Google Maps API v2.\n
 * \n
 * This API has been deprecated by Google.\n
 * Developers are encouraged to migrate to v3 of the API; support for this\n
 * is provided by <OpenLayers.Layer.Google.v3>\n
 */\n
OpenLayers.Layer.Google.v2 = {\n
    \n
    /**\n
     * Property: termsOfUse\n
     * {DOMElement} Div for Google\'s copyright and terms of use link\n
     */\n
    termsOfUse: null, \n
\n
    /**\n
     * Property: poweredBy\n
     * {DOMElement} Div for Google\'s powered by logo and link\n
     */\n
    poweredBy: null, \n
\n
    /**\n
     * Property: dragObject\n
     * {GDraggableObject} Since 2.93, Google has exposed the ability to get\n
     *     the maps GDraggableObject. We can now use this for smooth panning\n
     */\n
    dragObject: null, \n
    \n
    /** \n
     * Method: loadMapObject\n
     * Load the GMap and register appropriate event listeners. If we can\'t \n
     *     load GMap2, then display a warning message.\n
     */\n
    loadMapObject:function() {\n
        if (!this.type) {\n
            this.type = G_NORMAL_MAP;\n
        }\n
        var mapObject, termsOfUse, poweredBy;\n
        var cache = OpenLayers.Layer.Google.cache[this.map.id];\n
        if (cache) {\n
            // there are already Google layers added to this map\n
            mapObject = cache.mapObject;\n
            termsOfUse = cache.termsOfUse;\n
            poweredBy = cache.poweredBy;\n
            // increment the layer count\n
            ++cache.count;\n
        } else {\n
            // this is the first Google layer for this map\n
\n
            var container = this.map.viewPortDiv;\n
            var div = document.createElement("div");\n
            div.id = this.map.id + "_GMap2Container";\n
            div.style.position = "absolute";\n
            div.style.width = "100%";\n
            div.style.height = "100%";\n
            container.appendChild(div);\n
\n
            // create GMap and shuffle elements\n
            try {\n
                mapObject = new GMap2(div);\n
                \n
                // move the ToS and branding stuff up to the container div\n
                termsOfUse = div.lastChild;\n
                container.appendChild(termsOfUse);\n
                termsOfUse.style.zIndex = "1100";\n
                termsOfUse.style.right = "";\n
                termsOfUse.style.bottom = "";\n
                termsOfUse.className = "olLayerGoogleCopyright";\n
\n
                poweredBy = div.lastChild;\n
                container.appendChild(poweredBy);\n
                poweredBy.style.zIndex = "1100";\n
                poweredBy.style.right = "";\n
                poweredBy.style.bottom = "";\n
                poweredBy.className = "olLayerGooglePoweredBy gmnoprint";\n
                \n
            } catch (e) {\n
                throw(e);\n
            }\n
            // cache elements for use by any other google layers added to\n
            // this same map\n
            OpenLayers.Layer.Google.cache[this.map.id] = {\n
                mapObject: mapObject,\n
                termsOfUse: termsOfUse,\n
                poweredBy: poweredBy,\n
                count: 1\n
            };\n
        }\n
\n
        this.mapObject = mapObject;\n
        this.termsOfUse = termsOfUse;\n
        this.poweredBy = poweredBy;\n
        \n
        // ensure this layer type is one of the mapObject types\n
        if (OpenLayers.Util.indexOf(this.mapObject.getMapTypes(),\n
                                    this.type) === -1) {\n
            this.mapObject.addMapType(this.type);\n
        }\n
\n
        //since v 2.93 getDragObject is now available.\n
        if(typeof mapObject.getDragObject == "function") {\n
            this.dragObject = mapObject.getDragObject();\n
        } else {\n
            this.dragPanMapObject = null;\n
        }\n
        \n
        if(this.isBaseLayer === false) {\n
            this.setGMapVisibility(this.div.style.display !== "none");\n
        }\n
\n
    },\n
\n
    /**\n
     * APIMethod: onMapResize\n
     */\n
    onMapResize: function() {\n
        // workaround for resizing of invisible or not yet fully loaded layers\n
        // where GMap2.checkResize() does not work. We need to load the GMap\n
        // for the old div size, then checkResize(), and then call\n
        // layer.moveTo() to trigger GMap.setCenter() (which will finish\n
        // the GMap initialization).\n
        if(this.visibility && this.mapObject.isLoaded()) {\n
            this.mapObject.checkResize();\n
        } else {\n
            if(!this._resized) {\n
                var layer = this;\n
                var handle = GEvent.addListener(this.mapObject, "load", function() {\n
                    GEvent.removeListener(handle);\n
                    delete layer._resized;\n
                    layer.mapObject.checkResize();\n
                    layer.moveTo(layer.map.getCenter(), layer.map.getZoom());\n
                });\n
            }\n
            this._resized = true;\n
        }\n
    },\n
\n
    /**\n
     * Method: setGMapVisibility\n
     * Display the GMap container and associated elements.\n
     * \n
     * Parameters:\n
     * visible - {Boolean} Display the GMap elements.\n
     */\n
    setGMapVisibility: function(visible) {\n
        var cache = OpenLayers.Layer.Google.cache[this.map.id];\n
        if (cache) {\n
            var container = this.mapObject.getContainer();\n
            if (visible === true) {\n
                this.mapObject.setMapType(this.type);\n
                container.style.display = "";\n
                this.termsOfUse.style.left = "";\n
                this.termsOfUse.style.display = "";\n
                this.poweredBy.style.display = "";            \n
                cache.displayed = this.id;\n
            } else {\n
                if (cache.displayed === this.id) {\n
                    delete cache.displayed;\n
                }\n
                if (!cache.displayed) {\n
                    container.style.display = "none";\n
                    this.termsOfUse.style.display = "none";\n
                    // move ToU far to the left in addition to setting display\n
                    // to "none", because at the end of the GMap2 load\n
                    // sequence, display: none will be unset and ToU would be\n
                    // visible after loading a map with a google layer that is\n
                    // initially hidden. \n
                    this.termsOfUse.style.left = "-9999px";\n
                    this.poweredBy.style.display = "none";\n
                }\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: getMapContainer\n
     * \n
     * Returns:\n
     * {DOMElement} the GMap container\'s div\n
     */\n
    getMapContainer: function() {\n
        return this.mapObject.getContainer();\n
    },\n
\n
  //\n
  // TRANSLATION: MapObject Bounds <-> OpenLayers.Bounds\n
  //\n
\n
    /**\n
     * APIMethod: getMapObjectBoundsFromOLBounds\n
     * \n
     * Parameters:\n
     * olBounds - {<OpenLayers.Bounds>}\n
     * \n
     * Returns:\n
     * {Object} A MapObject Bounds, translated from olBounds\n
     *          Returns null if null value is passed in\n
     */\n
    getMapObjectBoundsFromOLBounds: function(olBounds) {\n
        var moBounds = null;\n
        if (olBounds != null) {\n
            var sw = this.sphericalMercator ? \n
              this.inverseMercator(olBounds.bottom, olBounds.left) : \n
              new OpenLayers.LonLat(olBounds.bottom, olBounds.left);\n
            var ne = this.sphericalMercator ? \n
              this.inverseMercator(olBounds.top, olBounds.right) : \n
              new OpenLayers.LonLat(olBounds.top, olBounds.right);\n
            moBounds = new GLatLngBounds(new GLatLng(sw.lat, sw.lon),\n
                                         new GLatLng(ne.lat, ne.lon));\n
        }\n
        return moBounds;\n
    },\n
\n
\n
    /************************************\n
     *                                  *\n
     *   MapObject Interface Controls   *\n
     *                                  *\n
     ************************************/\n
\n
\n
  // Get&Set Center, Zoom\n
\n
    /** \n
     * APIMethod: setMapObjectCenter\n
     * Set the mapObject to the specified center and zoom\n
     * \n
     * Parameters:\n
     * center - {Object} MapObject LonLat format\n
     * zoom - {int} MapObject zoom format\n
     */\n
    setMapObjectCenter: function(center, zoom) {\n
        this.mapObject.setCenter(center, zoom); \n
    },\n
   \n
    /**\n
     * APIMethod: dragPanMapObject\n
     * \n
     * Parameters:\n
     * dX - {Integer}\n
     * dY - {Integer}\n
     */\n
    dragPanMapObject: function(dX, dY) {\n
        this.dragObject.moveBy(new GSize(-dX, dY));\n
    },\n
\n
\n
  // LonLat - Pixel Translation\n
  \n
    /**\n
     * APIMethod: getMapObjectLonLatFromMapObjectPixel\n
     * \n
     * Parameters:\n
     * moPixel - {Object} MapObject Pixel format\n
     * \n
     * Returns:\n
     * {Object} MapObject LonLat translated from MapObject Pixel\n
     */\n
    getMapObjectLonLatFromMapObjectPixel: function(moPixel) {\n
        return this.mapObject.fromContainerPixelToLatLng(moPixel);\n
    },\n
\n
    /**\n
     * APIMethod: getMapObjectPixelFromMapObjectLonLat\n
     * \n
     * Parameters:\n
     * moLonLat - {Object} MapObject LonLat format\n
     * \n
     * Returns:\n
     * {Object} MapObject Pixel transtlated from MapObject LonLat\n
     */\n
    getMapObjectPixelFromMapObjectLonLat: function(moLonLat) {\n
        return this.mapObject.fromLatLngToContainerPixel(moLonLat);\n
    },\n
\n
  \n
  // Bounds\n
  \n
    /** \n
     * APIMethod: getMapObjectZoomFromMapObjectBounds\n
     * \n
     * Parameters:\n
     * moBounds - {Object} MapObject Bounds format\n
     * \n
     * Returns:\n
     * {Object} MapObject Zoom for specified MapObject Bounds\n
     */\n
    getMapObjectZoomFromMapObjectBounds: function(moBounds) {\n
        return this.mapObject.getBoundsZoomLevel(moBounds);\n
    },\n
\n
    /************************************\n
     *                                  *\n
     *       MapObject Primitives       *\n
     *                                  *\n
     ************************************/\n
\n
\n
  // LonLat\n
    \n
    /**\n
     * APIMethod: getMapObjectLonLatFromLonLat\n
     * \n
     * Parameters:\n
     * lon - {Float}\n
     * lat - {Float}\n
     * \n
     * Returns:\n
     * {Object} MapObject LonLat built from lon and lat params\n
     */\n
    getMapObjectLonLatFromLonLat: function(lon, lat) {\n
        var gLatLng;\n
        if(this.sphericalMercator) {\n
            var lonlat = this.inverseMercator(lon, lat);\n
            gLatLng = new GLatLng(lonlat.lat, lonlat.lon);\n
        } else {\n
            gLatLng = new GLatLng(lat, lon);\n
        }\n
        return gLatLng;\n
    },\n
\n
  // Pixel\n
    \n
    /**\n
     * APIMethod: getMapObjectPixelFromXY\n
     * \n
     * Parameters:\n
     * x - {Integer}\n
     * y - {Integer}\n
     * \n
     * Returns:\n
     * {Object} MapObject Pixel from x and y parameters\n
     */\n
    getMapObjectPixelFromXY: function(x, y) {\n
        return new GPoint(x, y);\n
    }\n
    \n
};\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>24682</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
