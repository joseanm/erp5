<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.79</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>WMTS.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Layer/Grid.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Layer.WMTS\n
 * Instances of the WMTS class allow viewing of tiles from a service that \n
 *     implements the OGC WMTS specification version 1.0.0.\n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Layer.Grid>\n
 */\n
OpenLayers.Layer.WMTS = OpenLayers.Class(OpenLayers.Layer.Grid, {\n
    \n
    /**\n
     * APIProperty: isBaseLayer\n
     * {Boolean} The layer will be considered a base layer.  Default is true.\n
     */\n
    isBaseLayer: true,\n
\n
    /**\n
     * Property: version\n
     * {String} WMTS version.  Default is "1.0.0".\n
     */\n
    version: "1.0.0",\n
    \n
    /**\n
     * APIProperty: requestEncoding\n
     * {String} Request encoding.  Can be "REST" or "KVP".  Default is "KVP".\n
     */\n
    requestEncoding: "KVP",\n
    \n
    /**\n
     * APIProperty: url\n
     * {String|Array(String)} The base URL or request URL template for the WMTS\n
     * service. Must be provided. Array is only supported for base URLs, not\n
     * for request URL templates. URL templates are only supported for\n
     * REST <requestEncoding>.\n
     */\n
    url: null,\n
\n
    /**\n
     * APIProperty: layer\n
     * {String} The layer identifier advertised by the WMTS service.  Must be \n
     *     provided.\n
     */\n
    layer: null,\n
    \n
    /** \n
     * APIProperty: matrixSet\n
     * {String} One of the advertised matrix set identifiers.  Must be provided.\n
     */\n
    matrixSet: null,\n
\n
    /** \n
     * APIProperty: style\n
     * {String} One of the advertised layer styles.  Must be provided.\n
     */\n
    style: null,\n
    \n
    /** \n
     * APIProperty: format\n
     * {String} The image MIME type.  Default is "image/jpeg".\n
     */\n
    format: "image/jpeg",\n
    \n
    /**\n
     * APIProperty: tileOrigin\n
     * {<OpenLayers.LonLat>} The top-left corner of the tile matrix in map \n
     *     units.  If the tile origin for each matrix in a set is different,\n
     *     the <matrixIds> should include a topLeftCorner property.  If\n
     *     not provided, the tile origin will default to the top left corner\n
     *     of the layer <maxExtent>.\n
     */\n
    tileOrigin: null,\n
    \n
    /**\n
     * APIProperty: tileFullExtent\n
     * {<OpenLayers.Bounds>}  The full extent of the tile set.  If not supplied,\n
     *     the layer\'s <maxExtent> property will be used.\n
     */\n
    tileFullExtent: null,\n
\n
    /**\n
     * APIProperty: formatSuffix\n
     * {String} For REST request encoding, an image format suffix must be \n
     *     included in the request.  If not provided, the suffix will be derived\n
     *     from the <format> property.\n
     */\n
    formatSuffix: null,    \n
\n
    /**\n
     * APIProperty: matrixIds\n
     * {Array} A list of tile matrix identifiers.  If not provided, the matrix\n
     *     identifiers will be assumed to be integers corresponding to the \n
     *     map zoom level.  If a list of strings is provided, each item should\n
     *     be the matrix identifier that corresponds to the map zoom level.\n
     *     Additionally, a list of objects can be provided.  Each object should\n
     *     describe the matrix as presented in the WMTS capabilities.  These\n
     *     objects should have the propertes shown below.\n
     * \n
     * Matrix properties:\n
     * identifier - {String} The matrix identifier (required).\n
     * topLeftCorner - {<OpenLayers.LonLat>} The top left corner of the \n
     *     matrix.  Must be provided if different than the layer <tileOrigin>.\n
     * tileWidth - {Number} The tile width for the matrix.  Must be provided \n
     *     if different than the width given in the layer <tileSize>.\n
     * tileHeight - {Number} The tile height for the matrix.  Must be provided \n
     *     if different than the height given in the layer <tileSize>.\n
     */\n
    matrixIds: null,\n
    \n
    /**\n
     * APIProperty: dimensions\n
     * {Array} For RESTful request encoding, extra dimensions may be specified.\n
     *     Items in this list should be property names in the <params> object.\n
     *     Values of extra dimensions will be determined from the corresponding\n
     *     values in the <params> object.\n
     */\n
    dimensions: null,\n
    \n
    /**\n
     * APIProperty: params\n
     * {Object} Extra parameters to include in tile requests.  For KVP \n
     *     <requestEncoding>, these properties will be encoded in the request \n
     *     query string.  For REST <requestEncoding>, these properties will\n
     *     become part of the request path, with order determined by the \n
     *     <dimensions> list.\n
     */\n
    params: null,\n
    \n
    /**\n
     * APIProperty: zoomOffset\n
     * {Number} If your cache has more levels than you want to provide\n
     *     access to with this layer, supply a zoomOffset.  This zoom offset\n
     *     is added to the current map zoom level to determine the level\n
     *     for a requested tile.  For example, if you supply a zoomOffset\n
     *     of 3, when the map is at the zoom 0, tiles will be requested from\n
     *     level 3 of your cache.  Default is 0 (assumes cache level and map\n
     *     zoom are equivalent).  Additionally, if this layer is to be used\n
     *     as an overlay and the cache has fewer zoom levels than the base\n
     *     layer, you can supply a negative zoomOffset.  For example, if a\n
     *     map zoom level of 1 corresponds to your cache level zero, you would\n
     *     supply a -1 zoomOffset (and set the maxResolution of the layer\n
     *     appropriately).  The zoomOffset value has no effect if complete\n
     *     matrix definitions (including scaleDenominator) are supplied in\n
     *     the <matrixIds> property.  Defaults to 0 (no zoom offset).\n
     */\n
    zoomOffset: 0,\n
\n
    /**\n
     * APIProperty: serverResolutions\n
     * {Array} A list of all resolutions available on the server.  Only set this\n
     *     property if the map resolutions differ from the server. This\n
     *     property serves two purposes. (a) <serverResolutions> can include\n
     *     resolutions that the server supports and that you don\'t want to\n
     *     provide with this layer; you can also look at <zoomOffset>, which is\n
     *     an alternative to <serverResolutions> for that specific purpose.\n
     *     (b) The map can work with resolutions that aren\'t supported by\n
     *     the server, i.e. that aren\'t in <serverResolutions>. When the\n
     *     map is displayed in such a resolution data for the closest\n
     *     server-supported resolution is loaded and the layer div is\n
     *     stretched as necessary.\n
     */\n
    serverResolutions: null,\n
\n
    /**\n
     * Property: formatSuffixMap\n
     * {Object} a map between WMTS \'format\' request parameter and tile image file suffix\n
     */\n
    formatSuffixMap: {\n
        "image/png": "png",\n
        "image/png8": "png",\n
        "image/png24": "png",\n
        "image/png32": "png",\n
        "png": "png",\n
        "image/jpeg": "jpg",\n
        "image/jpg": "jpg",\n
        "jpeg": "jpg",\n
        "jpg": "jpg"\n
    },\n
    \n
    /**\n
     * Property: matrix\n
     * {Object} Matrix definition for the current map resolution.  Updated by\n
     *     the <updateMatrixProperties> method.\n
     */\n
    matrix: null,\n
    \n
    /**\n
     * Constructor: OpenLayers.Layer.WMTS\n
     * Create a new WMTS layer.\n
     *\n
     * Example:\n
     * (code)\n
     * var wmts = new OpenLayers.Layer.WMTS({\n
     *     name: "My WMTS Layer",\n
     *     url: "http://example.com/wmts", \n
     *     layer: "layer_id",\n
     *     style: "default",\n
     *     matrixSet: "matrix_id"\n
     * });\n
     * (end)\n
     *\n
     * Parameters:\n
     * config - {Object} Configuration properties for the layer.\n
     *\n
     * Required configuration properties:\n
     * url - {String} The base url for the service.  See the <url> property.\n
     * layer - {String} The layer identifier.  See the <layer> property.\n
     * style - {String} The layer style identifier.  See the <style> property.\n
     * matrixSet - {String} The tile matrix set identifier.  See the <matrixSet>\n
     *     property.\n
     *\n
     * Any other documented layer properties can be provided in the config object.\n
     */\n
    initialize: function(config) {\n
\n
        // confirm required properties are supplied\n
        var required = {\n
            url: true,\n
            layer: true,\n
            style: true,\n
            matrixSet: true\n
        };\n
        for (var prop in required) {\n
            if (!(prop in config)) {\n
                throw new Error("Missing property \'" + prop + "\' in layer configuration.");\n
            }\n
        }\n
\n
        config.params = OpenLayers.Util.upperCaseObject(config.params);\n
        var args = [config.name, config.url, config.params, config];\n
        OpenLayers.Layer.Grid.prototype.initialize.apply(this, args);\n
        \n
\n
        // determine format suffix (for REST)\n
        if (!this.formatSuffix) {\n
            this.formatSuffix = this.formatSuffixMap[this.format] || this.format.split("/").pop();            \n
        }\n
\n
        // expand matrixIds (may be array of string or array of object)\n
        if (this.matrixIds) {\n
            var len = this.matrixIds.length;\n
            if (len && typeof this.matrixIds[0] === "string") {\n
                var ids = this.matrixIds;\n
                this.matrixIds = new Array(len);\n
                for (var i=0; i<len; ++i) {\n
                    this.matrixIds[i] = {identifier: ids[i]};\n
                }\n
            }\n
        }\n
\n
    },\n
    \n
    /**\n
     * Method: setMap\n
     */\n
    setMap: function() {\n
        OpenLayers.Layer.Grid.prototype.setMap.apply(this, arguments);\n
        this.updateMatrixProperties();\n
    },\n
    \n
    /**\n
     * Method: updateMatrixProperties\n
     * Called when map resolution changes to update matrix related properties.\n
     */\n
    updateMatrixProperties: function() {\n
        this.matrix = this.getMatrix();\n
        if (this.matrix) {\n
            if (this.matrix.topLeftCorner) {\n
                this.tileOrigin = this.matrix.topLeftCorner;\n
            }\n
            if (this.matrix.tileWidth && this.matrix.tileHeight) {\n
                this.tileSize = new OpenLayers.Size(\n
                    this.matrix.tileWidth, this.matrix.tileHeight\n
                );\n
            }\n
            if (!this.tileOrigin) { \n
                this.tileOrigin = new OpenLayers.LonLat(\n
                    this.maxExtent.left, this.maxExtent.top\n
                );\n
            }   \n
            if (!this.tileFullExtent) { \n
                this.tileFullExtent = this.maxExtent;\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: moveTo\n
     * \n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>}\n
     * zoomChanged - {Boolean} Tells when zoom has changed, as layers have to\n
     *     do some init work in that case.\n
     * dragging - {Boolean}\n
     */\n
    moveTo:function(bounds, zoomChanged, dragging) {\n
        if (zoomChanged || !this.matrix) {\n
            this.updateMatrixProperties();\n
        }\n
        return OpenLayers.Layer.Grid.prototype.moveTo.apply(this, arguments);\n
    },\n
\n
    /**\n
     * APIMethod: clone\n
     * \n
     * Parameters:\n
     * obj - {Object}\n
     * \n
     * Returns:\n
     * {<OpenLayers.Layer.WMTS>} An exact clone of this <OpenLayers.Layer.WMTS>\n
     */\n
    clone: function(obj) {\n
        if (obj == null) {\n
            obj = new OpenLayers.Layer.WMTS(this.options);\n
        }\n
        //get all additions from superclasses\n
        obj = OpenLayers.Layer.Grid.prototype.clone.apply(this, [obj]);\n
        // copy/set any non-init, non-simple values here\n
        return obj;\n
    },\n
\n
    /**\n
     * Method: getIdentifier\n
     * Get the current index in the matrixIds array.\n
     */\n
    getIdentifier: function() {\n
        return this.getServerZoom();\n
    },\n
    \n
    /**\n
     * Method: getMatrix\n
     * Get the appropriate matrix definition for the current map resolution.\n
     */\n
    getMatrix: function() {\n
        var matrix;\n
        if (!this.matrixIds || this.matrixIds.length === 0) {\n
            matrix = {identifier: this.getIdentifier()};\n
        } else {\n
            // get appropriate matrix given the map scale if possible\n
            if ("scaleDenominator" in this.matrixIds[0]) {\n
                // scale denominator calculation based on WMTS spec\n
                var denom = \n
                    OpenLayers.METERS_PER_INCH * \n
                    OpenLayers.INCHES_PER_UNIT[this.units] * \n
                    this.getServerResolution() / 0.28E-3;\n
                var diff = Number.POSITIVE_INFINITY;\n
                var delta;\n
                for (var i=0, ii=this.matrixIds.length; i<ii; ++i) {\n
                    delta = Math.abs(1 - (this.matrixIds[i].scaleDenominator / denom));\n
                    if (delta < diff) {\n
                        diff = delta;\n
                        matrix = this.matrixIds[i];\n
                    }\n
                }\n
            } else {\n
                // fall back on zoom as index\n
                matrix = this.matrixIds[this.getIdentifier()];\n
            }\n
        }\n
        return matrix;\n
    },\n
    \n
    /** \n
     * Method: getTileInfo\n
     * Get tile information for a given location at the current map resolution.\n
     *\n
     * Parameters:\n
     * loc - {<OpenLayers.LonLat} A location in map coordinates.\n
     *\n
     * Returns:\n
     * {Object} An object with "col", "row", "i", and "j" properties.  The col\n
     *     and row values are zero based tile indexes from the top left.  The\n
     *     i and j values are the number of pixels to the left and top \n
     *     (respectively) of the given location within the target tile.\n
     */\n
    getTileInfo: function(loc) {\n
        var res = this.getServerResolution();\n
        \n
        var fx = (loc.lon - this.tileOrigin.lon) / (res * this.tileSize.w);\n
        var fy = (this.tileOrigin.lat - loc.lat) / (res * this.tileSize.h);\n
\n
        var col = Math.floor(fx);\n
        var row = Math.floor(fy);\n
        \n
        return {\n
            col: col, \n
            row: row,\n
            i: Math.floor((fx - col) * this.tileSize.w),\n
            j: Math.floor((fy - row) * this.tileSize.h)\n
        };\n
    },\n
    \n
    /**\n
     * Method: getURL\n
     * \n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>}\n
     * \n
     * Returns:\n
     * {String} A URL for the tile corresponding to the given bounds.\n
     */\n
    getURL: function(bounds) {\n
        bounds = this.adjustBounds(bounds);\n
        var url = "";\n
        if (!this.tileFullExtent || this.tileFullExtent.intersectsBounds(bounds)) {            \n
\n
            var center = bounds.getCenterLonLat();            \n
            var info = this.getTileInfo(center);\n
            var matrixId = this.matrix.identifier;\n
            var dimensions = this.dimensions, params;\n
\n
            if (this.requestEncoding.toUpperCase() === "REST") {\n
                params = this.params;\n
                if (typeof this.url === "string" && this.url.indexOf("{") !== -1) {\n
                    var template = this.url.replace(/\\{/g, "${");\n
                    var context = {\n
                        // spec does not make clear if capital S or not\n
                        style: this.style, Style: this.style,\n
                        TileMatrixSet: this.matrixSet,\n
                        TileMatrix: this.matrix.identifier,\n
                        TileRow: info.row,\n
                        TileCol: info.col\n
                    };\n
                    if (dimensions) {\n
                        var dimension, i;\n
                        for (i=dimensions.length-1; i>=0; --i) {\n
                            dimension = dimensions[i];\n
                            context[dimension] = params[dimension.toUpperCase()];\n
                        }\n
                    }\n
                    url = OpenLayers.String.format(template, context);\n
                } else {\n
                    // include \'version\', \'layer\' and \'style\' in tile resource url\n
                    var path = this.version + "/" + this.layer + "/" + this.style + "/";\n
\n
                    // append optional dimension path elements\n
                    if (dimensions) {\n
                        for (var i=0; i<dimensions.length; i++) {\n
                            if (params[dimensions[i]]) {\n
                                path = path + params[dimensions[i]] + "/";\n
                            }\n
                        }\n
                    }\n
\n
                    // append other required path elements\n
                    path = path + this.matrixSet + "/" + this.matrix.identifier + \n
                        "/" + info.row + "/" + info.col + "." + this.formatSuffix;\n
\n
                    if (OpenLayers.Util.isArray(this.url)) {\n
                        url = this.selectUrl(path, this.url);\n
                    } else {\n
                        url = this.url;\n
                    }\n
                    if (!url.match(/\\/$/)) {\n
                        url = url + "/";\n
                    }\n
                    url = url + path;\n
                }\n
            } else if (this.requestEncoding.toUpperCase() === "KVP") {\n
\n
                // assemble all required parameters\n
                params = {\n
                    SERVICE: "WMTS",\n
                    REQUEST: "GetTile",\n
                    VERSION: this.version,\n
                    LAYER: this.layer,\n
                    STYLE: this.style,\n
                    TILEMATRIXSET: this.matrixSet,\n
                    TILEMATRIX: this.matrix.identifier,\n
                    TILEROW: info.row,\n
                    TILECOL: info.col,\n
                    FORMAT: this.format\n
                };\n
                url = OpenLayers.Layer.Grid.prototype.getFullRequestString.apply(this, [params]);\n
\n
            }\n
        }\n
        return url;    \n
    },\n
    \n
    /**\n
     * APIMethod: mergeNewParams\n
     * Extend the existing layer <params> with new properties.  Tiles will be\n
     *     reloaded with updated params in the request.\n
     * \n
     * Parameters:\n
     * newParams - {Object} Properties to extend to existing <params>.\n
     */\n
    mergeNewParams: function(newParams) {\n
        if (this.requestEncoding.toUpperCase() === "KVP") {\n
            return OpenLayers.Layer.Grid.prototype.mergeNewParams.apply(\n
                this, [OpenLayers.Util.upperCaseObject(newParams)]\n
            );\n
        }\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Layer.WMTS"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>18357</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
