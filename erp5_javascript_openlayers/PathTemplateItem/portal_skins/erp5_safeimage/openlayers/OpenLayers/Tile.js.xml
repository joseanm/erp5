<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.77</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Tile.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/BaseTypes/Class.js\n
 * @requires OpenLayers/Util.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Tile \n
 * This is a class designed to designate a single tile, however\n
 *     it is explicitly designed to do relatively little. Tiles store \n
 *     information about themselves -- such as the URL that they are related\n
 *     to, and their size - but do not add themselves to the layer div \n
 *     automatically, for example. Create a new tile with the \n
 *     <OpenLayers.Tile> constructor, or a subclass. \n
 * \n
 * TBD 3.0 - remove reference to url in above paragraph\n
 * \n
 */\n
OpenLayers.Tile = OpenLayers.Class({\n
    \n
    /**\n
     * APIProperty: events\n
     * {<OpenLayers.Events>} An events object that handles all \n
     *     events on the tile.\n
     *\n
     * Register a listener for a particular event with the following syntax:\n
     * (code)\n
     * tile.events.register(type, obj, listener);\n
     * (end)\n
     *\n
     * Supported event types:\n
     * beforedraw - Triggered before the tile is drawn. Used to defer\n
     *     drawing to an animation queue. To defer drawing, listeners need\n
     *     to return false, which will abort drawing. The queue handler needs\n
     *     to call <draw>(true) to actually draw the tile.\n
     * loadstart - Triggered when tile loading starts.\n
     * loadend - Triggered when tile loading ends.\n
     * loaderror - Triggered before the loadend event (i.e. when the tile is\n
     *     still hidden) if the tile could not be loaded.\n
     * reload - Triggered when an already loading tile is reloaded.\n
     * unload - Triggered before a tile is unloaded.\n
     */\n
    events: null,\n
\n
    /**\n
     * APIProperty: eventListeners\n
     * {Object} If set as an option at construction, the eventListeners\n
     *     object will be registered with <OpenLayers.Events.on>.  Object\n
     *     structure must be a listeners object as shown in the example for\n
     *     the events.on method.\n
     *\n
     * This options can be set in the ``tileOptions`` option from\n
     * <OpenLayers.Layer.Grid>. For example, to be notified of the\n
     * ``loadend`` event of each tiles:\n
     * (code)\n
     * new OpenLayers.Layer.OSM(\'osm\', \'http://tile.openstreetmap.org/${z}/${x}/${y}.png\', {\n
     *     tileOptions: {\n
     *         eventListeners: {\n
     *             \'loadend\': function(evt) {\n
     *                 // do something on loadend\n
     *             }\n
     *         }\n
     *     }\n
     * });\n
     * (end)\n
     */\n
    eventListeners: null,\n
\n
    /**\n
     * Property: id \n
     * {String} null\n
     */\n
    id: null,\n
    \n
    /** \n
     * Property: layer \n
     * {<OpenLayers.Layer>} layer the tile is attached to \n
     */\n
    layer: null,\n
    \n
    /**\n
     * Property: url\n
     * {String} url of the request.\n
     *\n
     * TBD 3.0 \n
     * Deprecated. The base tile class does not need an url. This should be \n
     * handled in subclasses. Does not belong here.\n
     */\n
    url: null,\n
\n
    /** \n
     * APIProperty: bounds \n
     * {<OpenLayers.Bounds>} null\n
     */\n
    bounds: null,\n
    \n
    /** \n
     * Property: size \n
     * {<OpenLayers.Size>} null\n
     */\n
    size: null,\n
    \n
    /** \n
     * Property: position \n
     * {<OpenLayers.Pixel>} Top Left pixel of the tile\n
     */    \n
    position: null,\n
    \n
    /**\n
     * Property: isLoading\n
     * {Boolean} Is the tile loading?\n
     */\n
    isLoading: false,\n
    \n
    /** TBD 3.0 -- remove \'url\' from the list of parameters to the constructor.\n
     *             there is no need for the base tile class to have a url.\n
     */\n
\n
    /** \n
     * Constructor: OpenLayers.Tile\n
     * Constructor for a new <OpenLayers.Tile> instance.\n
     * \n
     * Parameters:\n
     * layer - {<OpenLayers.Layer>} layer that the tile will go in.\n
     * position - {<OpenLayers.Pixel>}\n
     * bounds - {<OpenLayers.Bounds>}\n
     * url - {<String>}\n
     * size - {<OpenLayers.Size>}\n
     * options - {Object}\n
     */   \n
    initialize: function(layer, position, bounds, url, size, options) {\n
        this.layer = layer;\n
        this.position = position.clone();\n
        this.setBounds(bounds);\n
        this.url = url;\n
        if (size) {\n
            this.size = size.clone();\n
        }\n
\n
        //give the tile a unique id based on its BBOX.\n
        this.id = OpenLayers.Util.createUniqueID("Tile_");\n
\n
        OpenLayers.Util.extend(this, options);\n
\n
        this.events = new OpenLayers.Events(this);\n
        if (this.eventListeners instanceof Object) {\n
            this.events.on(this.eventListeners);\n
        }\n
    },\n
\n
    /**\n
     * Method: unload\n
     * Call immediately before destroying if you are listening to tile\n
     * events, so that counters are properly handled if tile is still\n
     * loading at destroy-time. Will only fire an event if the tile is\n
     * still loading.\n
     */\n
    unload: function() {\n
       if (this.isLoading) { \n
           this.isLoading = false; \n
           this.events.triggerEvent("unload"); \n
       }\n
    },\n
    \n
    /** \n
     * APIMethod: destroy\n
     * Nullify references to prevent circular references and memory leaks.\n
     */\n
    destroy:function() {\n
        this.layer  = null;\n
        this.bounds = null;\n
        this.size = null;\n
        this.position = null;\n
        \n
        if (this.eventListeners) {\n
            this.events.un(this.eventListeners);\n
        }\n
        this.events.destroy();\n
        this.eventListeners = null;\n
        this.events = null;\n
    },\n
    \n
    /**\n
     * Method: draw\n
     * Clear whatever is currently in the tile, then return whether or not \n
     *     it should actually be re-drawn. This is an example implementation\n
     *     that can be overridden by subclasses. The minimum thing to do here\n
     *     is to call <clear> and return the result from <shouldDraw>.\n
     *\n
     * Parameters:\n
     * deferred - {Boolean} When drawing was aborted by returning false from a\n
     *     *beforedraw* listener, the queue manager needs to pass true, so the\n
     *     tile will not be cleared and immediately be drawn. Otherwise, the\n
     *     tile will be cleared and a *beforedraw* event will be fired.\n
     * \n
     * Returns:\n
     * {Boolean} Whether or not the tile should actually be drawn.\n
     */\n
    draw: function(deferred) {\n
        if (!deferred) {\n
            //clear tile\'s contents and mark as not drawn\n
            this.clear();\n
        }\n
        var draw = this.shouldDraw();\n
        if (draw && !deferred) {\n
            draw = this.events.triggerEvent("beforedraw") !== false;\n
        }\n
        return draw;\n
    },\n
    \n
    /**\n
     * Method: shouldDraw\n
     * Return whether or not the tile should actually be (re-)drawn. The only\n
     * case where we *wouldn\'t* want to draw the tile is if the tile is outside\n
     * its layer\'s maxExtent\n
     * \n
     * Returns:\n
     * {Boolean} Whether or not the tile should actually be drawn.\n
     */\n
    shouldDraw: function() {        \n
        var withinMaxExtent = false,\n
            maxExtent = this.layer.maxExtent;\n
        if (maxExtent) {\n
            var map = this.layer.map;\n
            var worldBounds = map.baseLayer.wrapDateLine && map.getMaxExtent();\n
            if (this.bounds.intersectsBounds(maxExtent, {inclusive: false, worldBounds: worldBounds})) {\n
                withinMaxExtent = true;\n
            }\n
        }\n
        \n
        return withinMaxExtent || this.layer.displayOutsideMaxExtent;\n
    },\n
    \n
    /**\n
     * Method: setBounds\n
     * Sets the bounds on this instance\n
     *\n
     * Parameters:\n
     * bounds {<OpenLayers.Bounds>}\n
     */\n
    setBounds: function(bounds) {\n
        bounds = bounds.clone();\n
        if (this.layer.map.baseLayer.wrapDateLine) {\n
            var worldExtent = this.layer.map.getMaxExtent(),\n
                tolerance = this.layer.map.getResolution();\n
            bounds = bounds.wrapDateLine(worldExtent, {\n
                leftTolerance: tolerance,\n
                rightTolerance: tolerance\n
            });\n
        }\n
        this.bounds = bounds;\n
    },\n
    \n
    /** \n
     * Method: moveTo\n
     * Reposition the tile.\n
     *\n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>}\n
     * position - {<OpenLayers.Pixel>}\n
     * redraw - {Boolean} Call draw method on tile after moving.\n
     *     Default is true\n
     */\n
    moveTo: function (bounds, position, redraw) {\n
        if (redraw == null) {\n
            redraw = true;\n
        }\n
\n
        this.setBounds(bounds);\n
        this.position = position.clone();\n
        if (redraw) {\n
            this.draw();\n
        }\n
    },\n
\n
    /** \n
     * Method: clear\n
     * Clear the tile of any bounds/position-related data so that it can \n
     *     be reused in a new location.\n
     */\n
    clear: function(draw) {\n
        // to be extended by subclasses\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Tile"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>8951</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
