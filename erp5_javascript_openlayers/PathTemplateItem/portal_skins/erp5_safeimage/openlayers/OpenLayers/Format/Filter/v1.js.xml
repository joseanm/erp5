<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.99</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>v1.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
/**\n
 * @requires OpenLayers/Format/Filter.js\n
 * @requires OpenLayers/Format/XML.js\n
 * @requires OpenLayers/Filter/Function.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Format.Filter.v1\n
 * Superclass for Filter version 1 parsers.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Format.XML>\n
 */\n
OpenLayers.Format.Filter.v1 = OpenLayers.Class(OpenLayers.Format.XML, {\n
    \n
    /**\n
     * Property: namespaces\n
     * {Object} Mapping of namespace aliases to namespace URIs.\n
     */\n
    namespaces: {\n
        ogc: "http://www.opengis.net/ogc",\n
        gml: "http://www.opengis.net/gml",\n
        xlink: "http://www.w3.org/1999/xlink",\n
        xsi: "http://www.w3.org/2001/XMLSchema-instance"\n
    },\n
    \n
    /**\n
     * Property: defaultPrefix\n
     */\n
    defaultPrefix: "ogc",\n
\n
    /**\n
     * Property: schemaLocation\n
     * {String} Schema location for a particular minor version.\n
     */\n
    schemaLocation: null,\n
    \n
    /**\n
     * Constructor: OpenLayers.Format.Filter.v1\n
     * Instances of this class are not created directly.  Use the\n
     *     <OpenLayers.Format.Filter> constructor instead.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     */\n
    initialize: function(options) {\n
        OpenLayers.Format.XML.prototype.initialize.apply(this, [options]);\n
    },\n
    \n
    /**\n
     * Method: read\n
     *\n
     * Parameters:\n
     * data - {DOMElement} A Filter document element.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Filter>} A filter object.\n
     */\n
    read: function(data) {\n
        var obj = {};\n
        this.readers.ogc["Filter"].apply(this, [data, obj]);\n
        return obj.filter;\n
    },\n
    \n
    /**\n
     * Property: readers\n
     * Contains public functions, grouped by namespace prefix, that will\n
     *     be applied when a namespaced node is found matching the function\n
     *     name.  The function will be applied in the scope of this parser\n
     *     with two arguments: the node being read and a context object passed\n
     *     from the parent.\n
     */\n
    readers: {\n
        "ogc": {\n
            "_expression": function(node) {\n
                // only the simplest of ogc:expression handled\n
                // "some text and an <PropertyName>attribute</PropertyName>"}\n
                var obj, value = "";\n
                for(var child=node.firstChild; child; child=child.nextSibling) {\n
                    switch(child.nodeType) {\n
                        case 1:\n
                            obj = this.readNode(child);\n
                            if (obj.property) {\n
                                value += "${" + obj.property + "}";\n
                            } else if (obj.value !== undefined) {\n
                                value += obj.value;\n
                            }\n
                            break;\n
                        case 3: // text node\n
                        case 4: // cdata section\n
                            value += child.nodeValue;\n
                    }\n
                }\n
                return value;\n
            },\n
            "Filter": function(node, parent) {\n
                // Filters correspond to subclasses of OpenLayers.Filter.\n
                // Since they contain information we don\'t persist, we\n
                // create a temporary object and then pass on the filter\n
                // (ogc:Filter) to the parent obj.\n
                var obj = {\n
                    fids: [],\n
                    filters: []\n
                };\n
                this.readChildNodes(node, obj);\n
                if(obj.fids.length > 0) {\n
                    parent.filter = new OpenLayers.Filter.FeatureId({\n
                        fids: obj.fids\n
                    });\n
                } else if(obj.filters.length > 0) {\n
                    parent.filter = obj.filters[0];\n
                }\n
            },\n
            "FeatureId": function(node, obj) {\n
                var fid = node.getAttribute("fid");\n
                if(fid) {\n
                    obj.fids.push(fid);\n
                }\n
            },\n
            "And": function(node, obj) {\n
                var filter = new OpenLayers.Filter.Logical({\n
                    type: OpenLayers.Filter.Logical.AND\n
                });\n
                this.readChildNodes(node, filter);\n
                obj.filters.push(filter);\n
            },\n
            "Or": function(node, obj) {\n
                var filter = new OpenLayers.Filter.Logical({\n
                    type: OpenLayers.Filter.Logical.OR\n
                });\n
                this.readChildNodes(node, filter);\n
                obj.filters.push(filter);\n
            },\n
            "Not": function(node, obj) {\n
                var filter = new OpenLayers.Filter.Logical({\n
                    type: OpenLayers.Filter.Logical.NOT\n
                });\n
                this.readChildNodes(node, filter);\n
                obj.filters.push(filter);\n
            },\n
            "PropertyIsLessThan": function(node, obj) {\n
                var filter = new OpenLayers.Filter.Comparison({\n
                    type: OpenLayers.Filter.Comparison.LESS_THAN\n
                });\n
                this.readChildNodes(node, filter);\n
                obj.filters.push(filter);\n
            },\n
            "PropertyIsGreaterThan": function(node, obj) {\n
                var filter = new OpenLayers.Filter.Comparison({\n
                    type: OpenLayers.Filter.Comparison.GREATER_THAN\n
                });\n
                this.readChildNodes(node, filter);\n
                obj.filters.push(filter);\n
            },\n
            "PropertyIsLessThanOrEqualTo": function(node, obj) {\n
                var filter = new OpenLayers.Filter.Comparison({\n
                    type: OpenLayers.Filter.Comparison.LESS_THAN_OR_EQUAL_TO\n
                });\n
                this.readChildNodes(node, filter);\n
                obj.filters.push(filter);\n
            },\n
            "PropertyIsGreaterThanOrEqualTo": function(node, obj) {\n
                var filter = new OpenLayers.Filter.Comparison({\n
                    type: OpenLayers.Filter.Comparison.GREATER_THAN_OR_EQUAL_TO\n
                });\n
                this.readChildNodes(node, filter);\n
                obj.filters.push(filter);\n
            },\n
            "PropertyIsBetween": function(node, obj) {\n
                var filter = new OpenLayers.Filter.Comparison({\n
                    type: OpenLayers.Filter.Comparison.BETWEEN\n
                });\n
                this.readChildNodes(node, filter);\n
                obj.filters.push(filter);\n
            },\n
            "Literal": function(node, obj) {\n
                obj.value = OpenLayers.String.numericIf(\n
                    this.getChildValue(node));\n
            },\n
            "PropertyName": function(node, filter) {\n
                filter.property = this.getChildValue(node);\n
            },\n
            "LowerBoundary": function(node, filter) {\n
                filter.lowerBoundary = OpenLayers.String.numericIf(\n
                    this.readers.ogc._expression.call(this, node));\n
            },\n
            "UpperBoundary": function(node, filter) {\n
                filter.upperBoundary = OpenLayers.String.numericIf(\n
                    this.readers.ogc._expression.call(this, node));\n
            },\n
            "Intersects": function(node, obj) {\n
                this.readSpatial(node, obj, OpenLayers.Filter.Spatial.INTERSECTS);\n
            },\n
            "Within": function(node, obj) {\n
                this.readSpatial(node, obj, OpenLayers.Filter.Spatial.WITHIN);\n
            },\n
            "Contains": function(node, obj) {\n
                this.readSpatial(node, obj, OpenLayers.Filter.Spatial.CONTAINS);\n
            },\n
            "DWithin": function(node, obj) {\n
                this.readSpatial(node, obj, OpenLayers.Filter.Spatial.DWITHIN);\n
            },\n
            "Distance": function(node, obj) {\n
                obj.distance = parseInt(this.getChildValue(node));\n
                obj.distanceUnits = node.getAttribute("units");\n
            },\n
            "Function": function(node, obj) {\n
                //TODO write decoder for it\n
                return;\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: readSpatial\n
     *\n
     * Read a {<OpenLayers.Filter.Spatial>} filter.\n
     * \n
     * Parameters:\n
     * node - {DOMElement} A DOM element that contains an ogc:expression.\n
     * obj - {Object} The target object.\n
     * type - {String} One of the OpenLayers.Filter.Spatial.* constants.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Filter.Spatial>} The created filter.\n
     */\n
    readSpatial: function(node, obj, type) {\n
        var filter = new OpenLayers.Filter.Spatial({\n
            type: type\n
        });\n
        this.readChildNodes(node, filter);\n
        filter.value = filter.components[0];\n
        delete filter.components;\n
        obj.filters.push(filter);\n
    },\n
\n
    /**\n
     * Method: writeOgcExpression\n
     * Limited support for writing OGC expressions. Currently it supports\n
     * (<OpenLayers.Filter.Function> || String || Number)\n
     *\n
     * Parameters:\n
     * value - (<OpenLayers.Filter.Function> || String || Number)\n
     * node - {DOMElement} A parent DOM element \n
     *\n
     * Returns:\n
     * {DOMElement} Updated node element.\n
     */\n
    writeOgcExpression: function(value, node) {\n
        if(value instanceof OpenLayers.Filter.Function){\n
            var child = this.writeNode("Function", value, node);\n
            node.appendChild(child);\n
        } else {\n
            this.writeNode("Literal", value, node);\n
        }\n
        return node;\n
    },    \n
    \n
    /**\n
     * Method: write\n
     *\n
     * Parameters:\n
     * filter - {<OpenLayers.Filter>} A filter object.\n
     *\n
     * Returns:\n
     * {DOMElement} An ogc:Filter element.\n
     */\n
    write: function(filter) {\n
        return this.writers.ogc["Filter"].apply(this, [filter]);\n
    },\n
    \n
    /**\n
     * Method: writeFeatureIdNodes\n
     * \n
     * Parameters:\n
     * filter - {<OpenLayers.Filter.FeatureId}\n
     * node - {DOMElement}\n
     */\n
    writeFeatureIdNodes: function(filter, node) {\n
        for (var i=0, ii=filter.fids.length; i<ii; ++i) {\n
            this.writeNode("FeatureId", filter.fids[i], node);\n
        }\n
    },\n
    \n
    /**\n
     * Property: writers\n
     * As a compliment to the readers property, this structure contains public\n
     *     writing functions grouped by namespace alias and named like the\n
     *     node names they produce.\n
     */\n
    writers: {\n
        "ogc": {\n
            "Filter": function(filter) {\n
                var node = this.createElementNSPlus("ogc:Filter");\n
                if (filter.type === "FID") {\n
                    OpenLayers.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, filter, node);\n
                } else {\n
                    this.writeNode(this.getFilterType(filter), filter, node);\n
                }\n
                return node;\n
            },\n
            "FeatureId": function(fid) {\n
                return this.createElementNSPlus("ogc:FeatureId", {\n
                    attributes: {fid: fid}\n
                });\n
            },\n
            "And": function(filter) {\n
                var node = this.createElementNSPlus("ogc:And");\n
                var childFilter;\n
                for (var i=0, ii=filter.filters.length; i<ii; ++i) {\n
                    childFilter = filter.filters[i];\n
                    if (childFilter.type === "FID") {\n
                        OpenLayers.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, childFilter, node);\n
                    } else {\n
                    this.writeNode(\n
                        this.getFilterType(childFilter), childFilter, node\n
                    );\n
                }\n
                }\n
                return node;\n
            },\n
            "Or": function(filter) {\n
                var node = this.createElementNSPlus("ogc:Or");\n
                var childFilter;\n
                for (var i=0, ii=filter.filters.length; i<ii; ++i) {\n
                    childFilter = filter.filters[i];\n
                    if (childFilter.type === "FID") {\n
                        OpenLayers.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, childFilter, node);\n
                    } else {\n
                    this.writeNode(\n
                        this.getFilterType(childFilter), childFilter, node\n
                    );\n
                }\n
                }\n
                return node;\n
            },\n
            "Not": function(filter) {\n
                var node = this.createElementNSPlus("ogc:Not");\n
                var childFilter = filter.filters[0];\n
                if (childFilter.type === "FID") {\n
                    OpenLayers.Format.Filter.v1.prototype.writeFeatureIdNodes.call(this, childFilter, node);\n
                } else {\n
                this.writeNode(\n
                    this.getFilterType(childFilter), childFilter, node\n
                );\n
                }\n
                return node;\n
            },\n
            "PropertyIsLessThan": function(filter) {\n
                var node = this.createElementNSPlus("ogc:PropertyIsLessThan");\n
                // no ogc:expression handling for PropertyName for now\n
                this.writeNode("PropertyName", filter, node);\n
                // handle Literals or Functions for now\n
                this.writeOgcExpression(filter.value, node);\n
                return node;\n
            },\n
            "PropertyIsGreaterThan": function(filter) {\n
                var node = this.createElementNSPlus("ogc:PropertyIsGreaterThan");\n
                // no ogc:expression handling for PropertyName for now\n
                this.writeNode("PropertyName", filter, node);\n
                // handle Literals or Functions for now\n
                this.writeOgcExpression(filter.value, node);\n
                return node;\n
            },\n
            "PropertyIsLessThanOrEqualTo": function(filter) {\n
                var node = this.createElementNSPlus("ogc:PropertyIsLessThanOrEqualTo");\n
                // no ogc:expression handling for PropertyName for now\n
                this.writeNode("PropertyName", filter, node);\n
                // handle Literals or Functions for now\n
                this.writeOgcExpression(filter.value, node);\n
                return node;\n
            },\n
            "PropertyIsGreaterThanOrEqualTo": function(filter) {\n
                var node = this.createElementNSPlus("ogc:PropertyIsGreaterThanOrEqualTo");\n
                // no ogc:expression handling for PropertyName for now\n
                this.writeNode("PropertyName", filter, node);\n
                // handle Literals or Functions for now\n
                this.writeOgcExpression(filter.value, node);\n
                return node;\n
            },\n
            "PropertyIsBetween": function(filter) {\n
                var node = this.createElementNSPlus("ogc:PropertyIsBetween");\n
                // no ogc:expression handling for PropertyName for now\n
                this.writeNode("PropertyName", filter, node);\n
                this.writeNode("LowerBoundary", filter, node);\n
                this.writeNode("UpperBoundary", filter, node);\n
                return node;\n
            },\n
            "PropertyName": function(filter) {\n
                // no ogc:expression handling for now\n
                return this.createElementNSPlus("ogc:PropertyName", {\n
                    value: filter.property\n
                });\n
            },\n
            "Literal": function(value) {\n
                // no ogc:expression handling for now\n
                return this.createElementNSPlus("ogc:Literal", {\n
                    value: value\n
                });\n
            },\n
            "LowerBoundary": function(filter) {\n
                // handle Literals or Functions for now\n
                var node = this.createElementNSPlus("ogc:LowerBoundary");\n
                this.writeOgcExpression(filter.lowerBoundary, node);\n
                return node;\n
            },\n
            "UpperBoundary": function(filter) {\n
                // handle Literals or Functions for now\n
                var node = this.createElementNSPlus("ogc:UpperBoundary");\n
                this.writeNode("Literal", filter.upperBoundary, node);\n
                return node;\n
            },\n
            "INTERSECTS": function(filter) {\n
                return this.writeSpatial(filter, "Intersects");\n
            },\n
            "WITHIN": function(filter) {\n
                return this.writeSpatial(filter, "Within");\n
            },\n
            "CONTAINS": function(filter) {\n
                return this.writeSpatial(filter, "Contains");\n
            },\n
            "DWITHIN": function(filter) {\n
                var node = this.writeSpatial(filter, "DWithin");\n
                this.writeNode("Distance", filter, node);\n
                return node;\n
            },\n
            "Distance": function(filter) {\n
                return this.createElementNSPlus("ogc:Distance", {\n
                    attributes: {\n
                        units: filter.distanceUnits\n
                    },\n
                    value: filter.distance\n
                });\n
            },\n
            "Function": function(filter) {\n
                var node = this.createElementNSPlus("ogc:Function", {\n
                    attributes: {\n
                        name: filter.name\n
                    }\n
                });\n
                var params = filter.params;\n
                for(var i=0, len=params.length; i<len; i++){\n
                    this.writeOgcExpression(params[i], node);\n
                }\n
                return node;\n
            }\n
        }\n
    },\n
\n
    /**\n
     * Method: getFilterType\n
     */\n
    getFilterType: function(filter) {\n
        var filterType = this.filterMap[filter.type];\n
        if(!filterType) {\n
            throw "Filter writing not supported for rule type: " + filter.type;\n
        }\n
        return filterType;\n
    },\n
    \n
    /**\n
     * Property: filterMap\n
     * {Object} Contains a member for each filter type.  Values are node names\n
     *     for corresponding OGC Filter child elements.\n
     */\n
    filterMap: {\n
        "&&": "And",\n
        "||": "Or",\n
        "!": "Not",\n
        "==": "PropertyIsEqualTo",\n
        "!=": "PropertyIsNotEqualTo",\n
        "<": "PropertyIsLessThan",\n
        ">": "PropertyIsGreaterThan",\n
        "<=": "PropertyIsLessThanOrEqualTo",\n
        ">=": "PropertyIsGreaterThanOrEqualTo",\n
        "..": "PropertyIsBetween",\n
        "~": "PropertyIsLike",\n
        "BBOX": "BBOX",\n
        "DWITHIN": "DWITHIN",\n
        "WITHIN": "WITHIN",\n
        "CONTAINS": "CONTAINS",\n
        "INTERSECTS": "INTERSECTS",\n
        "FID": "FeatureId"\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Format.Filter.v1" \n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>18804</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
