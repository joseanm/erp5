<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.92</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>GeoJSON.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Format/JSON.js\n
 * @requires OpenLayers/Feature/Vector.js\n
 * @requires OpenLayers/Geometry/Point.js\n
 * @requires OpenLayers/Geometry/MultiPoint.js\n
 * @requires OpenLayers/Geometry/LineString.js\n
 * @requires OpenLayers/Geometry/MultiLineString.js\n
 * @requires OpenLayers/Geometry/Polygon.js\n
 * @requires OpenLayers/Geometry/MultiPolygon.js\n
 * @requires OpenLayers/Console.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Format.GeoJSON\n
 * Read and write GeoJSON. Create a new parser with the\n
 *     <OpenLayers.Format.GeoJSON> constructor.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Format.JSON>\n
 */\n
OpenLayers.Format.GeoJSON = OpenLayers.Class(OpenLayers.Format.JSON, {\n
\n
    /**\n
     * APIProperty: ignoreExtraDims\n
     * {Boolean} Ignore dimensions higher than 2 when reading geometry\n
     * coordinates.\n
     */ \n
    ignoreExtraDims: false,\n
    \n
    /**\n
     * Constructor: OpenLayers.Format.GeoJSON\n
     * Create a new parser for GeoJSON.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     */\n
\n
    /**\n
     * APIMethod: read\n
     * Deserialize a GeoJSON string.\n
     *\n
     * Parameters:\n
     * json - {String} A GeoJSON string\n
     * type - {String} Optional string that determines the structure of\n
     *     the output.  Supported values are "Geometry", "Feature", and\n
     *     "FeatureCollection".  If absent or null, a default of\n
     *     "FeatureCollection" is assumed.\n
     * filter - {Function} A function which will be called for every key and\n
     *     value at every level of the final result. Each value will be\n
     *     replaced by the result of the filter function. This can be used to\n
     *     reform generic objects into instances of classes, or to transform\n
     *     date strings into Date objects.\n
     *\n
     * Returns: \n
     * {Object} The return depends on the value of the type argument. If type\n
     *     is "FeatureCollection" (the default), the return will be an array\n
     *     of <OpenLayers.Feature.Vector>. If type is "Geometry", the input json\n
     *     must represent a single geometry, and the return will be an\n
     *     <OpenLayers.Geometry>.  If type is "Feature", the input json must\n
     *     represent a single feature, and the return will be an\n
     *     <OpenLayers.Feature.Vector>.\n
     */\n
    read: function(json, type, filter) {\n
        type = (type) ? type : "FeatureCollection";\n
        var results = null;\n
        var obj = null;\n
        if (typeof json == "string") {\n
            obj = OpenLayers.Format.JSON.prototype.read.apply(this,\n
                                                              [json, filter]);\n
        } else { \n
            obj = json;\n
        }    \n
        if(!obj) {\n
            OpenLayers.Console.error("Bad JSON: " + json);\n
        } else if(typeof(obj.type) != "string") {\n
            OpenLayers.Console.error("Bad GeoJSON - no type: " + json);\n
        } else if(this.isValidType(obj, type)) {\n
            switch(type) {\n
                case "Geometry":\n
                    try {\n
                        results = this.parseGeometry(obj);\n
                    } catch(err) {\n
                        OpenLayers.Console.error(err);\n
                    }\n
                    break;\n
                case "Feature":\n
                    try {\n
                        results = this.parseFeature(obj);\n
                        results.type = "Feature";\n
                    } catch(err) {\n
                        OpenLayers.Console.error(err);\n
                    }\n
                    break;\n
                case "FeatureCollection":\n
                    // for type FeatureCollection, we allow input to be any type\n
                    results = [];\n
                    switch(obj.type) {\n
                        case "Feature":\n
                            try {\n
                                results.push(this.parseFeature(obj));\n
                            } catch(err) {\n
                                results = null;\n
                                OpenLayers.Console.error(err);\n
                            }\n
                            break;\n
                        case "FeatureCollection":\n
                            for(var i=0, len=obj.features.length; i<len; ++i) {\n
                                try {\n
                                    results.push(this.parseFeature(obj.features[i]));\n
                                } catch(err) {\n
                                    results = null;\n
                                    OpenLayers.Console.error(err);\n
                                }\n
                            }\n
                            break;\n
                        default:\n
                            try {\n
                                var geom = this.parseGeometry(obj);\n
                                results.push(new OpenLayers.Feature.Vector(geom));\n
                            } catch(err) {\n
                                results = null;\n
                                OpenLayers.Console.error(err);\n
                            }\n
                    }\n
                break;\n
            }\n
        }\n
        return results;\n
    },\n
    \n
    /**\n
     * Method: isValidType\n
     * Check if a GeoJSON object is a valid representative of the given type.\n
     *\n
     * Returns:\n
     * {Boolean} The object is valid GeoJSON object of the given type.\n
     */\n
    isValidType: function(obj, type) {\n
        var valid = false;\n
        switch(type) {\n
            case "Geometry":\n
                if(OpenLayers.Util.indexOf(\n
                    ["Point", "MultiPoint", "LineString", "MultiLineString",\n
                     "Polygon", "MultiPolygon", "Box", "GeometryCollection"],\n
                    obj.type) == -1) {\n
                    // unsupported geometry type\n
                    OpenLayers.Console.error("Unsupported geometry type: " +\n
                                              obj.type);\n
                } else {\n
                    valid = true;\n
                }\n
                break;\n
            case "FeatureCollection":\n
                // allow for any type to be converted to a feature collection\n
                valid = true;\n
                break;\n
            default:\n
                // for Feature types must match\n
                if(obj.type == type) {\n
                    valid = true;\n
                } else {\n
                    OpenLayers.Console.error("Cannot convert types from " +\n
                                              obj.type + " to " + type);\n
                }\n
        }\n
        return valid;\n
    },\n
    \n
    /**\n
     * Method: parseFeature\n
     * Convert a feature object from GeoJSON into an\n
     *     <OpenLayers.Feature.Vector>.\n
     *\n
     * Parameters:\n
     * obj - {Object} An object created from a GeoJSON object\n
     *\n
     * Returns:\n
     * {<OpenLayers.Feature.Vector>} A feature.\n
     */\n
    parseFeature: function(obj) {\n
        var feature, geometry, attributes, bbox;\n
        attributes = (obj.properties) ? obj.properties : {};\n
        bbox = (obj.geometry && obj.geometry.bbox) || obj.bbox;\n
        try {\n
            geometry = this.parseGeometry(obj.geometry);\n
        } catch(err) {\n
            // deal with bad geometries\n
            throw err;\n
        }\n
        feature = new OpenLayers.Feature.Vector(geometry, attributes);\n
        if(bbox) {\n
            feature.bounds = OpenLayers.Bounds.fromArray(bbox);\n
        }\n
        if(obj.id) {\n
            feature.fid = obj.id;\n
        }\n
        return feature;\n
    },\n
    \n
    /**\n
     * Method: parseGeometry\n
     * Convert a geometry object from GeoJSON into an <OpenLayers.Geometry>.\n
     *\n
     * Parameters:\n
     * obj - {Object} An object created from a GeoJSON object\n
     *\n
     * Returns: \n
     * {<OpenLayers.Geometry>} A geometry.\n
     */\n
    parseGeometry: function(obj) {\n
        if (obj == null) {\n
            return null;\n
        }\n
        var geometry, collection = false;\n
        if(obj.type == "GeometryCollection") {\n
            if(!(OpenLayers.Util.isArray(obj.geometries))) {\n
                throw "GeometryCollection must have geometries array: " + obj;\n
            }\n
            var numGeom = obj.geometries.length;\n
            var components = new Array(numGeom);\n
            for(var i=0; i<numGeom; ++i) {\n
                components[i] = this.parseGeometry.apply(\n
                    this, [obj.geometries[i]]\n
                );\n
            }\n
            geometry = new OpenLayers.Geometry.Collection(components);\n
            collection = true;\n
        } else {\n
            if(!(OpenLayers.Util.isArray(obj.coordinates))) {\n
                throw "Geometry must have coordinates array: " + obj;\n
            }\n
            if(!this.parseCoords[obj.type.toLowerCase()]) {\n
                throw "Unsupported geometry type: " + obj.type;\n
            }\n
            try {\n
                geometry = this.parseCoords[obj.type.toLowerCase()].apply(\n
                    this, [obj.coordinates]\n
                );\n
            } catch(err) {\n
                // deal with bad coordinates\n
                throw err;\n
            }\n
        }\n
        // We don\'t reproject collections because the children are reprojected\n
        // for us when they are created.\n
        if (this.internalProjection && this.externalProjection && !collection) {\n
            geometry.transform(this.externalProjection, \n
                               this.internalProjection); \n
        }                       \n
        return geometry;\n
    },\n
    \n
    /**\n
     * Property: parseCoords\n
     * Object with properties corresponding to the GeoJSON geometry types.\n
     *     Property values are functions that do the actual parsing.\n
     */\n
    parseCoords: {\n
        /**\n
         * Method: parseCoords.point\n
         * Convert a coordinate array from GeoJSON into an\n
         *     <OpenLayers.Geometry>.\n
         *\n
         * Parameters:\n
         * array - {Object} The coordinates array from the GeoJSON fragment.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry>} A geometry.\n
         */\n
        "point": function(array) {\n
            if (this.ignoreExtraDims == false && \n
                  array.length != 2) {\n
                    throw "Only 2D points are supported: " + array;\n
            }\n
            return new OpenLayers.Geometry.Point(array[0], array[1]);\n
        },\n
        \n
        /**\n
         * Method: parseCoords.multipoint\n
         * Convert a coordinate array from GeoJSON into an\n
         *     <OpenLayers.Geometry>.\n
         *\n
         * Parameters:\n
         * array - {Object} The coordinates array from the GeoJSON fragment.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry>} A geometry.\n
         */\n
        "multipoint": function(array) {\n
            var points = [];\n
            var p = null;\n
            for(var i=0, len=array.length; i<len; ++i) {\n
                try {\n
                    p = this.parseCoords["point"].apply(this, [array[i]]);\n
                } catch(err) {\n
                    throw err;\n
                }\n
                points.push(p);\n
            }\n
            return new OpenLayers.Geometry.MultiPoint(points);\n
        },\n
\n
        /**\n
         * Method: parseCoords.linestring\n
         * Convert a coordinate array from GeoJSON into an\n
         *     <OpenLayers.Geometry>.\n
         *\n
         * Parameters:\n
         * array - {Object} The coordinates array from the GeoJSON fragment.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry>} A geometry.\n
         */\n
        "linestring": function(array) {\n
            var points = [];\n
            var p = null;\n
            for(var i=0, len=array.length; i<len; ++i) {\n
                try {\n
                    p = this.parseCoords["point"].apply(this, [array[i]]);\n
                } catch(err) {\n
                    throw err;\n
                }\n
                points.push(p);\n
            }\n
            return new OpenLayers.Geometry.LineString(points);\n
        },\n
        \n
        /**\n
         * Method: parseCoords.multilinestring\n
         * Convert a coordinate array from GeoJSON into an\n
         *     <OpenLayers.Geometry>.\n
         *\n
         * Parameters:\n
         * array - {Object} The coordinates array from the GeoJSON fragment.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry>} A geometry.\n
         */\n
        "multilinestring": function(array) {\n
            var lines = [];\n
            var l = null;\n
            for(var i=0, len=array.length; i<len; ++i) {\n
                try {\n
                    l = this.parseCoords["linestring"].apply(this, [array[i]]);\n
                } catch(err) {\n
                    throw err;\n
                }\n
                lines.push(l);\n
            }\n
            return new OpenLayers.Geometry.MultiLineString(lines);\n
        },\n
        \n
        /**\n
         * Method: parseCoords.polygon\n
         * Convert a coordinate array from GeoJSON into an\n
         *     <OpenLayers.Geometry>.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry>} A geometry.\n
         */\n
        "polygon": function(array) {\n
            var rings = [];\n
            var r, l;\n
            for(var i=0, len=array.length; i<len; ++i) {\n
                try {\n
                    l = this.parseCoords["linestring"].apply(this, [array[i]]);\n
                } catch(err) {\n
                    throw err;\n
                }\n
                r = new OpenLayers.Geometry.LinearRing(l.components);\n
                rings.push(r);\n
            }\n
            return new OpenLayers.Geometry.Polygon(rings);\n
        },\n
\n
        /**\n
         * Method: parseCoords.multipolygon\n
         * Convert a coordinate array from GeoJSON into an\n
         *     <OpenLayers.Geometry>.\n
         *\n
         * Parameters:\n
         * array - {Object} The coordinates array from the GeoJSON fragment.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry>} A geometry.\n
         */\n
        "multipolygon": function(array) {\n
            var polys = [];\n
            var p = null;\n
            for(var i=0, len=array.length; i<len; ++i) {\n
                try {\n
                    p = this.parseCoords["polygon"].apply(this, [array[i]]);\n
                } catch(err) {\n
                    throw err;\n
                }\n
                polys.push(p);\n
            }\n
            return new OpenLayers.Geometry.MultiPolygon(polys);\n
        },\n
\n
        /**\n
         * Method: parseCoords.box\n
         * Convert a coordinate array from GeoJSON into an\n
         *     <OpenLayers.Geometry>.\n
         *\n
         * Parameters:\n
         * array - {Object} The coordinates array from the GeoJSON fragment.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry>} A geometry.\n
         */\n
        "box": function(array) {\n
            if(array.length != 2) {\n
                throw "GeoJSON box coordinates must have 2 elements";\n
            }\n
            return new OpenLayers.Geometry.Polygon([\n
                new OpenLayers.Geometry.LinearRing([\n
                    new OpenLayers.Geometry.Point(array[0][0], array[0][1]),\n
                    new OpenLayers.Geometry.Point(array[1][0], array[0][1]),\n
                    new OpenLayers.Geometry.Point(array[1][0], array[1][1]),\n
                    new OpenLayers.Geometry.Point(array[0][0], array[1][1]),\n
                    new OpenLayers.Geometry.Point(array[0][0], array[0][1])\n
                ])\n
            ]);\n
        }\n
\n
    },\n
\n
    /**\n
     * APIMethod: write\n
     * Serialize a feature, geometry, array of features into a GeoJSON string.\n
     *\n
     * Parameters:\n
     * obj - {Object} An <OpenLayers.Feature.Vector>, <OpenLayers.Geometry>,\n
     *     or an array of features.\n
     * pretty - {Boolean} Structure the output with newlines and indentation.\n
     *     Default is false.\n
     *\n
     * Returns:\n
     * {String} The GeoJSON string representation of the input geometry,\n
     *     features, or array of features.\n
     */\n
    write: function(obj, pretty) {\n
        var geojson = {\n
            "type": null\n
        };\n
        if(OpenLayers.Util.isArray(obj)) {\n
            geojson.type = "FeatureCollection";\n
            var numFeatures = obj.length;\n
            geojson.features = new Array(numFeatures);\n
            for(var i=0; i<numFeatures; ++i) {\n
                var element = obj[i];\n
                if(!element instanceof OpenLayers.Feature.Vector) {\n
                    var msg = "FeatureCollection only supports collections " +\n
                              "of features: " + element;\n
                    throw msg;\n
                }\n
                geojson.features[i] = this.extract.feature.apply(\n
                    this, [element]\n
                );\n
            }\n
        } else if (obj.CLASS_NAME.indexOf("OpenLayers.Geometry") == 0) {\n
            geojson = this.extract.geometry.apply(this, [obj]);\n
        } else if (obj instanceof OpenLayers.Feature.Vector) {\n
            geojson = this.extract.feature.apply(this, [obj]);\n
            if(obj.layer && obj.layer.projection) {\n
                geojson.crs = this.createCRSObject(obj);\n
            }\n
        }\n
        return OpenLayers.Format.JSON.prototype.write.apply(this,\n
                                                            [geojson, pretty]);\n
    },\n
\n
    /**\n
     * Method: createCRSObject\n
     * Create the CRS object for an object.\n
     *\n
     * Parameters:\n
     * object - {<OpenLayers.Feature.Vector>} \n
     *\n
     * Returns:\n
     * {Object} An object which can be assigned to the crs property\n
     * of a GeoJSON object.\n
     */\n
    createCRSObject: function(object) {\n
       var proj = object.layer.projection.toString();\n
       var crs = {};\n
       if (proj.match(/epsg:/i)) {\n
           var code = parseInt(proj.substring(proj.indexOf(":") + 1));\n
           if (code == 4326) {\n
               crs = {\n
                   "type": "name",\n
                   "properties": {\n
                       "name": "urn:ogc:def:crs:OGC:1.3:CRS84"\n
                   }\n
               };\n
           } else {    \n
               crs = {\n
                   "type": "name",\n
                   "properties": {\n
                       "name": "EPSG:" + code\n
                   }\n
               };\n
           }    \n
       }\n
       return crs;\n
    },\n
    \n
    /**\n
     * Property: extract\n
     * Object with properties corresponding to the GeoJSON types.\n
     *     Property values are functions that do the actual value extraction.\n
     */\n
    extract: {\n
        /**\n
         * Method: extract.feature\n
         * Return a partial GeoJSON object representing a single feature.\n
         *\n
         * Parameters:\n
         * feature - {<OpenLayers.Feature.Vector>}\n
         *\n
         * Returns:\n
         * {Object} An object representing the point.\n
         */\n
        \'feature\': function(feature) {\n
            var geom = this.extract.geometry.apply(this, [feature.geometry]);\n
            var json = {\n
                "type": "Feature",\n
                "properties": feature.attributes,\n
                "geometry": geom\n
            };\n
            if (feature.fid != null) {\n
                json.id = feature.fid;\n
            }\n
            return json;\n
        },\n
        \n
        /**\n
         * Method: extract.geometry\n
         * Return a GeoJSON object representing a single geometry.\n
         *\n
         * Parameters:\n
         * geometry - {<OpenLayers.Geometry>}\n
         *\n
         * Returns:\n
         * {Object} An object representing the geometry.\n
         */\n
        \'geometry\': function(geometry) {\n
            if (geometry == null) {\n
                return null;\n
            }\n
            if (this.internalProjection && this.externalProjection) {\n
                geometry = geometry.clone();\n
                geometry.transform(this.internalProjection, \n
                                   this.externalProjection);\n
            }                       \n
            var geometryType = geometry.CLASS_NAME.split(\'.\')[2];\n
            var data = this.extract[geometryType.toLowerCase()].apply(this, [geometry]);\n
            var json;\n
            if(geometryType == "Collection") {\n
                json = {\n
                    "type": "GeometryCollection",\n
                    "geometries": data\n
                };\n
            } else {\n
                json = {\n
                    "type": geometryType,\n
                    "coordinates": data\n
                };\n
            }\n
            \n
            return json;\n
        },\n
\n
        /**\n
         * Method: extract.point\n
         * Return an array of coordinates from a point.\n
         *\n
         * Parameters:\n
         * point - {<OpenLayers.Geometry.Point>}\n
         *\n
         * Returns: \n
         * {Array} An array of coordinates representing the point.\n
         */\n
        \'point\': function(point) {\n
            return [point.x, point.y];\n
        },\n
\n
        /**\n
         * Method: extract.multipoint\n
         * Return an array of point coordinates from a multipoint.\n
         *\n
         * Parameters:\n
         * multipoint - {<OpenLayers.Geometry.MultiPoint>}\n
         *\n
         * Returns:\n
         * {Array} An array of point coordinate arrays representing\n
         *     the multipoint.\n
         */\n
        \'multipoint\': function(multipoint) {\n
            var array = [];\n
            for(var i=0, len=multipoint.components.length; i<len; ++i) {\n
                array.push(this.extract.point.apply(this, [multipoint.components[i]]));\n
            }\n
            return array;\n
        },\n
        \n
        /**\n
         * Method: extract.linestring\n
         * Return an array of coordinate arrays from a linestring.\n
         *\n
         * Parameters:\n
         * linestring - {<OpenLayers.Geometry.LineString>}\n
         *\n
         * Returns:\n
         * {Array} An array of coordinate arrays representing\n
         *     the linestring.\n
         */\n
        \'linestring\': function(linestring) {\n
            var array = [];\n
            for(var i=0, len=linestring.components.length; i<len; ++i) {\n
                array.push(this.extract.point.apply(this, [linestring.components[i]]));\n
            }\n
            return array;\n
        },\n
\n
        /**\n
         * Method: extract.multilinestring\n
         * Return an array of linestring arrays from a linestring.\n
         * \n
         * Parameters:\n
         * multilinestring - {<OpenLayers.Geometry.MultiLineString>}\n
         * \n
         * Returns:\n
         * {Array} An array of linestring arrays representing\n
         *     the multilinestring.\n
         */\n
        \'multilinestring\': function(multilinestring) {\n
            var array = [];\n
            for(var i=0, len=multilinestring.components.length; i<len; ++i) {\n
                array.push(this.extract.linestring.apply(this, [multilinestring.components[i]]));\n
            }\n
            return array;\n
        },\n
        \n
        /**\n
         * Method: extract.polygon\n
         * Return an array of linear ring arrays from a polygon.\n
         *\n
         * Parameters:\n
         * polygon - {<OpenLayers.Geometry.Polygon>}\n
         * \n
         * Returns:\n
         * {Array} An array of linear ring arrays representing the polygon.\n
         */\n
        \'polygon\': function(polygon) {\n
            var array = [];\n
            for(var i=0, len=polygon.components.length; i<len; ++i) {\n
                array.push(this.extract.linestring.apply(this, [polygon.components[i]]));\n
            }\n
            return array;\n
        },\n
\n
        /**\n
         * Method: extract.multipolygon\n
         * Return an array of polygon arrays from a multipolygon.\n
         * \n
         * Parameters:\n
         * multipolygon - {<OpenLayers.Geometry.MultiPolygon>}\n
         * \n
         * Returns:\n
         * {Array} An array of polygon arrays representing\n
         *     the multipolygon\n
         */\n
        \'multipolygon\': function(multipolygon) {\n
            var array = [];\n
            for(var i=0, len=multipolygon.components.length; i<len; ++i) {\n
                array.push(this.extract.polygon.apply(this, [multipolygon.components[i]]));\n
            }\n
            return array;\n
        },\n
        \n
        /**\n
         * Method: extract.collection\n
         * Return an array of geometries from a geometry collection.\n
         * \n
         * Parameters:\n
         * collection - {<OpenLayers.Geometry.Collection>}\n
         * \n
         * Returns:\n
         * {Array} An array of geometry objects representing the geometry\n
         *     collection.\n
         */\n
        \'collection\': function(collection) {\n
            var len = collection.components.length;\n
            var array = new Array(len);\n
            for(var i=0; i<len; ++i) {\n
                array[i] = this.extract.geometry.apply(\n
                    this, [collection.components[i]]\n
                );\n
            }\n
            return array;\n
        }\n
        \n
\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Format.GeoJSON" \n
\n
});     \n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>24949</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
