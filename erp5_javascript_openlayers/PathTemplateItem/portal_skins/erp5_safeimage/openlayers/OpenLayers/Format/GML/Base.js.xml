<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.97</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Base.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Format/XML.js\n
 * @requires OpenLayers/Format/GML.js\n
 */\n
\n
/**\n
 * Though required in the full build, if the GML format is excluded, we set\n
 * the namespace here.\n
 */\n
if(!OpenLayers.Format.GML) {\n
    OpenLayers.Format.GML = {};\n
}\n
\n
/**\n
 * Class: OpenLayers.Format.GML.Base\n
 * Superclass for GML parsers.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Format.XML>\n
 */\n
OpenLayers.Format.GML.Base = OpenLayers.Class(OpenLayers.Format.XML, {\n
    \n
    /**\n
     * Property: namespaces\n
     * {Object} Mapping of namespace aliases to namespace URIs.\n
     */\n
    namespaces: {\n
        gml: "http://www.opengis.net/gml",\n
        xlink: "http://www.w3.org/1999/xlink",\n
        xsi: "http://www.w3.org/2001/XMLSchema-instance",\n
        wfs: "http://www.opengis.net/wfs" // this is a convenience for reading wfs:FeatureCollection\n
    },\n
    \n
    /**\n
     * Property: defaultPrefix\n
     */\n
    defaultPrefix: "gml",\n
\n
    /**\n
     * Property: schemaLocation\n
     * {String} Schema location for a particular minor version.\n
     */\n
    schemaLocation: null,\n
    \n
    /**\n
     * APIProperty: featureType\n
     * {Array(String) or String} The local (without prefix) feature typeName(s).\n
     */\n
    featureType: null,\n
    \n
    /**\n
     * APIProperty: featureNS\n
     * {String} The feature namespace.  Must be set in the options at\n
     *     construction.\n
     */\n
    featureNS: null,\n
\n
    /**\n
     * APIProperty: geometry\n
     * {String} Name of geometry element.  Defaults to "geometry". If null, it\n
     * will be set on <read> when the first geometry is parsed.\n
     */\n
    geometryName: "geometry",\n
\n
    /**\n
     * APIProperty: extractAttributes\n
     * {Boolean} Extract attributes from GML.  Default is true.\n
     */\n
    extractAttributes: true,\n
    \n
    /**\n
     * APIProperty: srsName\n
     * {String} URI for spatial reference system.  This is optional for\n
     *     single part geometries and mandatory for collections and multis.\n
     *     If set, the srsName attribute will be written for all geometries.\n
     *     Default is null.\n
     */\n
    srsName: null,\n
\n
    /**\n
     * APIProperty: xy\n
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)\n
     * Changing is not recommended, a new Format should be instantiated.\n
     */ \n
    xy: true,\n
\n
    /**\n
     * Property: geometryTypes\n
     * {Object} Maps OpenLayers geometry class names to GML element names.\n
     *     Use <setGeometryTypes> before accessing this property.\n
     */\n
    geometryTypes: null,\n
\n
    /**\n
     * Property: singleFeatureType\n
     * {Boolean} True if there is only 1 featureType, and not an array\n
     *     of featuretypes.\n
     */\n
    singleFeatureType: null,\n
    \n
    /**\n
     * Property: autoConfig\n
     * {Boolean} Indicates if the format was configured without a <featureNS>,\n
     * but auto-configured <featureNS> and <featureType> during read.\n
     * Subclasses making use of <featureType> auto-configuration should make\n
     * the first call to the <readNode> method (usually in the read method)\n
     * with true as 3rd argument, so the auto-configured featureType can be\n
     * reset and the format can be reused for subsequent reads with data from\n
     * different featureTypes. Set to false after read if you want to keep the\n
     * auto-configured values.\n
     */\n
\n
    /**\n
     * Property: regExes\n
     * Compiled regular expressions for manipulating strings.\n
     */\n
    regExes: {\n
        trimSpace: (/^\\s*|\\s*$/g),\n
        removeSpace: (/\\s*/g),\n
        splitSpace: (/\\s+/),\n
        trimComma: (/\\s*,\\s*/g),\n
        featureMember: (/^(.*:)?featureMembers?$/)\n
    },\n
\n
    /**\n
     * Constructor: OpenLayers.Format.GML.Base\n
     * Instances of this class are not created directly.  Use the\n
     *     <OpenLayers.Format.GML.v2> or <OpenLayers.Format.GML.v3> constructor\n
     *     instead.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     *\n
     * Valid options properties:\n
     * featureType - {Array(String) or String} Local (without prefix) feature \n
     *     typeName(s) (required for write).\n
     * featureNS - {String} Feature namespace (required for write).\n
     * geometryName - {String} Geometry element name (required for write).\n
     */\n
    initialize: function(options) {\n
        OpenLayers.Format.XML.prototype.initialize.apply(this, [options]);\n
        this.setGeometryTypes();\n
        if(options && options.featureNS) {\n
            this.setNamespace("feature", options.featureNS);\n
        }\n
        this.singleFeatureType = !options || (typeof options.featureType === "string");\n
    },\n
    \n
    /**\n
     * Method: read\n
     *\n
     * Parameters:\n
     * data - {DOMElement} A gml:featureMember element, a gml:featureMembers\n
     *     element, or an element containing either of the above at any level.\n
     *\n
     * Returns:\n
     * {Array(<OpenLayers.Feature.Vector>)} An array of features.\n
     */\n
    read: function(data) {\n
        if(typeof data == "string") { \n
            data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);\n
        }\n
        if(data && data.nodeType == 9) {\n
            data = data.documentElement;\n
        }\n
        var features = [];\n
        this.readNode(data, {features: features}, true);\n
        if(features.length == 0) {\n
            // look for gml:featureMember elements\n
            var elements = this.getElementsByTagNameNS(\n
                data, this.namespaces.gml, "featureMember"\n
            );\n
            if(elements.length) {\n
                for(var i=0, len=elements.length; i<len; ++i) {\n
                    this.readNode(elements[i], {features: features}, true);\n
                }\n
            } else {\n
                // look for gml:featureMembers elements (this is v3, but does no harm here)\n
                var elements = this.getElementsByTagNameNS(\n
                    data, this.namespaces.gml, "featureMembers"\n
                );\n
                if(elements.length) {\n
                    // there can be only one\n
                    this.readNode(elements[0], {features: features}, true);\n
                }\n
            }\n
        }\n
        return features;\n
    },\n
    \n
    /**\n
     * Method: readNode\n
     * Shorthand for applying one of the named readers given the node\n
     *     namespace and local name.  Readers take two args (node, obj) and\n
     *     generally extend or modify the second.\n
     *\n
     * Parameters:\n
     * node - {DOMElement} The node to be read (required).\n
     * obj - {Object} The object to be modified (optional).\n
     * first - {Boolean} Should be set to true for the first node read. This\n
     *     is usually the readNode call in the read method. Without this being\n
     *     set, auto-configured properties will stick on subsequent reads.\n
     *\n
     * Returns:\n
     * {Object} The input object, modified (or a new one if none was provided).\n
     */\n
    readNode: function(node, obj, first) {\n
        // on subsequent calls of format.read(), we want to reset auto-\n
        // configured properties and auto-configure again.\n
        if (first === true && this.autoConfig === true) {\n
            this.featureType = null;\n
            delete this.namespaceAlias[this.featureNS];\n
            delete this.namespaces["feature"];\n
            this.featureNS = null;\n
        }\n
        // featureType auto-configuration\n
        if (!this.featureNS && (!(node.prefix in this.namespaces) &&\n
                node.parentNode.namespaceURI == this.namespaces["gml"] &&\n
                this.regExes.featureMember.test(node.parentNode.nodeName))) {\n
            this.featureType = node.nodeName.split(":").pop();\n
            this.setNamespace("feature", node.namespaceURI);\n
            this.featureNS = node.namespaceURI;\n
            this.autoConfig = true;\n
        }\n
        return OpenLayers.Format.XML.prototype.readNode.apply(this, [node, obj]);\n
    },\n
\n
    /**\n
     * Property: readers\n
     * Contains public functions, grouped by namespace prefix, that will\n
     *     be applied when a namespaced node is found matching the function\n
     *     name.  The function will be applied in the scope of this parser\n
     *     with two arguments: the node being read and a context object passed\n
     *     from the parent.\n
     */\n
    readers: {\n
        "gml": {\n
            "featureMember": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            },\n
            "featureMembers": function(node, obj) {\n
                this.readChildNodes(node, obj);                \n
            },\n
            "name": function(node, obj) {\n
                obj.name = this.getChildValue(node);\n
            },\n
            "boundedBy": function(node, obj) {\n
                var container = {};\n
                this.readChildNodes(node, container);\n
                if(container.components && container.components.length > 0) {\n
                    obj.bounds = container.components[0];\n
                }\n
            },\n
            "Point": function(node, container) {\n
                var obj = {points: []};\n
                this.readChildNodes(node, obj);\n
                if(!container.components) {\n
                    container.components = [];\n
                }\n
                container.components.push(obj.points[0]);\n
            },\n
            "coordinates": function(node, obj) {\n
                var str = this.getChildValue(node).replace(\n
                    this.regExes.trimSpace, ""\n
                );\n
                str = str.replace(this.regExes.trimComma, ",");\n
                var pointList = str.split(this.regExes.splitSpace);\n
                var coords;\n
                var numPoints = pointList.length;\n
                var points = new Array(numPoints);\n
                for(var i=0; i<numPoints; ++i) {\n
                    coords = pointList[i].split(",");\n
                    if (this.xy) {\n
                        points[i] = new OpenLayers.Geometry.Point(\n
                            coords[0], coords[1], coords[2]\n
                        );\n
                    } else {\n
                        points[i] = new OpenLayers.Geometry.Point(\n
                            coords[1], coords[0], coords[2]\n
                        );\n
                    }\n
                }\n
                obj.points = points;\n
            },\n
            "coord": function(node, obj) {\n
                var coord = {};\n
                this.readChildNodes(node, coord);\n
                if(!obj.points) {\n
                    obj.points = [];\n
                }\n
                obj.points.push(new OpenLayers.Geometry.Point(\n
                    coord.x, coord.y, coord.z\n
                ));\n
            },\n
            "X": function(node, coord) {\n
                coord.x = this.getChildValue(node);\n
            },\n
            "Y": function(node, coord) {\n
                coord.y = this.getChildValue(node);\n
            },\n
            "Z": function(node, coord) {\n
                coord.z = this.getChildValue(node);\n
            },\n
            "MultiPoint": function(node, container) {\n
                var obj = {components: []};\n
                this.readChildNodes(node, obj);\n
                container.components = [\n
                    new OpenLayers.Geometry.MultiPoint(obj.components)\n
                ];\n
            },\n
            "pointMember": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            },\n
            "LineString": function(node, container) {\n
                var obj = {};\n
                this.readChildNodes(node, obj);\n
                if(!container.components) {\n
                    container.components = [];\n
                }\n
                container.components.push(\n
                    new OpenLayers.Geometry.LineString(obj.points)\n
                );\n
            },\n
            "MultiLineString": function(node, container) {\n
                var obj = {components: []};\n
                this.readChildNodes(node, obj);\n
                container.components = [\n
                    new OpenLayers.Geometry.MultiLineString(obj.components)\n
                ];\n
            },\n
            "lineStringMember": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            },\n
            "Polygon": function(node, container) {\n
                var obj = {outer: null, inner: []};\n
                this.readChildNodes(node, obj);\n
                obj.inner.unshift(obj.outer);\n
                if(!container.components) {\n
                    container.components = [];\n
                }\n
                container.components.push(\n
                    new OpenLayers.Geometry.Polygon(obj.inner)\n
                );\n
            },\n
            "LinearRing": function(node, obj) {\n
                var container = {};\n
                this.readChildNodes(node, container);\n
                obj.components = [new OpenLayers.Geometry.LinearRing(\n
                    container.points\n
                )];\n
            },\n
            "MultiPolygon": function(node, container) {\n
                var obj = {components: []};\n
                this.readChildNodes(node, obj);\n
                container.components = [\n
                    new OpenLayers.Geometry.MultiPolygon(obj.components)\n
                ];\n
            },\n
            "polygonMember": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            },\n
            "GeometryCollection": function(node, container) {\n
                var obj = {components: []};\n
                this.readChildNodes(node, obj);\n
                container.components = [\n
                    new OpenLayers.Geometry.Collection(obj.components)\n
                ];\n
            },\n
            "geometryMember": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            }\n
        },\n
        "feature": {\n
            "*": function(node, obj) {\n
                // The node can either be named like the featureType, or it\n
                // can be a child of the feature:featureType.  Children can be\n
                // geometry or attributes.\n
                var name;\n
                var local = node.localName || node.nodeName.split(":").pop();\n
                // Since an attribute can have the same name as the feature type\n
                // we only want to read the node as a feature if the parent\n
                // node can have feature nodes as children.  In this case, the\n
                // obj.features property is set.\n
                if (obj.features) {\n
                    if (!this.singleFeatureType &&\n
                        (OpenLayers.Util.indexOf(this.featureType, local) !== -1)) {\n
                        name = "_typeName";\n
                    } else if(local === this.featureType) {\n
                        name = "_typeName";\n
                    }\n
                } else {\n
                    // Assume attribute elements have one child node and that the child\n
                    // is a text node.  Otherwise assume it is a geometry node.\n
                    if(node.childNodes.length == 0 ||\n
                       (node.childNodes.length == 1 && node.firstChild.nodeType == 3)) {\n
                        if(this.extractAttributes) {\n
                            name = "_attribute";\n
                        }\n
                    } else {\n
                        name = "_geometry";\n
                    }\n
                }\n
                if(name) {\n
                    this.readers.feature[name].apply(this, [node, obj]);\n
                }\n
            },\n
            "_typeName": function(node, obj) {\n
                var container = {components: [], attributes: {}};\n
                this.readChildNodes(node, container);\n
                // look for common gml namespaced elements\n
                if(container.name) {\n
                    container.attributes.name = container.name;\n
                }\n
                var feature = new OpenLayers.Feature.Vector(\n
                    container.components[0], container.attributes\n
                );\n
                if (!this.singleFeatureType) {\n
                    feature.type = node.nodeName.split(":").pop();\n
                    feature.namespace = node.namespaceURI;\n
                }\n
                var fid = node.getAttribute("fid") ||\n
                    this.getAttributeNS(node, this.namespaces["gml"], "id");\n
                if(fid) {\n
                    feature.fid = fid;\n
                }\n
                if(this.internalProjection && this.externalProjection &&\n
                   feature.geometry) {\n
                    feature.geometry.transform(\n
                        this.externalProjection, this.internalProjection\n
                    );\n
                }\n
                if(container.bounds) {\n
                    feature.bounds = container.bounds;\n
                }\n
                obj.features.push(feature);\n
            },\n
            "_geometry": function(node, obj) {\n
                if (!this.geometryName) {\n
                    this.geometryName = node.nodeName.split(":").pop();\n
                }\n
                this.readChildNodes(node, obj);\n
            },\n
            "_attribute": function(node, obj) {\n
                var local = node.localName || node.nodeName.split(":").pop();\n
                var value = this.getChildValue(node);\n
                obj.attributes[local] = value;\n
            }\n
        },\n
        "wfs": {\n
            "FeatureCollection": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: write\n
     *\n
     * Parameters:\n
     * features - {Array(<OpenLayers.Feature.Vector>) | OpenLayers.Feature.Vector}\n
     *     An array of features or a single feature.\n
     *\n
     * Returns:\n
     * {String} Given an array of features, a doc with a gml:featureMembers\n
     *     element will be returned.  Given a single feature, a doc with a\n
     *     gml:featureMember element will be returned.\n
     */\n
    write: function(features) {\n
        var name;\n
        if(OpenLayers.Util.isArray(features)) {\n
            name = "featureMembers";\n
        } else {\n
            name = "featureMember";\n
        }\n
        var root = this.writeNode("gml:" + name, features);\n
        this.setAttributeNS(\n
            root, this.namespaces["xsi"],\n
            "xsi:schemaLocation", this.schemaLocation\n
        );\n
\n
        return OpenLayers.Format.XML.prototype.write.apply(this, [root]);\n
    },\n
    \n
    /**\n
     * Property: writers\n
     * As a compliment to the readers property, this structure contains public\n
     *     writing functions grouped by namespace alias and named like the\n
     *     node names they produce.\n
     */\n
    writers: {\n
        "gml": {\n
            "featureMember": function(feature) {\n
                var node = this.createElementNSPlus("gml:featureMember");\n
                this.writeNode("feature:_typeName", feature, node);\n
                return node;\n
            },\n
            "MultiPoint": function(geometry) {\n
                var node = this.createElementNSPlus("gml:MultiPoint");\n
                var components = geometry.components || [geometry];\n
                for(var i=0, ii=components.length; i<ii; ++i) {\n
                    this.writeNode("pointMember", components[i], node);\n
                }\n
                return node;\n
            },\n
            "pointMember": function(geometry) {\n
                var node = this.createElementNSPlus("gml:pointMember");\n
                this.writeNode("Point", geometry, node);\n
                return node;\n
            },\n
            "MultiLineString": function(geometry) {\n
                var node = this.createElementNSPlus("gml:MultiLineString");\n
                var components = geometry.components || [geometry];\n
                for(var i=0, ii=components.length; i<ii; ++i) {\n
                    this.writeNode("lineStringMember", components[i], node);\n
                }\n
                return node;\n
            },\n
            "lineStringMember": function(geometry) {\n
                var node = this.createElementNSPlus("gml:lineStringMember");\n
                this.writeNode("LineString", geometry, node);\n
                return node;\n
            },\n
            "MultiPolygon": function(geometry) {\n
                var node = this.createElementNSPlus("gml:MultiPolygon");\n
                var components = geometry.components || [geometry];\n
                for(var i=0, ii=components.length; i<ii; ++i) {\n
                    this.writeNode(\n
                        "polygonMember", components[i], node\n
                    );\n
                }\n
                return node;\n
            },\n
            "polygonMember": function(geometry) {\n
                var node = this.createElementNSPlus("gml:polygonMember");\n
                this.writeNode("Polygon", geometry, node);\n
                return node;\n
            },\n
            "GeometryCollection": function(geometry) {\n
                var node = this.createElementNSPlus("gml:GeometryCollection");\n
                for(var i=0, len=geometry.components.length; i<len; ++i) {\n
                    this.writeNode("geometryMember", geometry.components[i], node);\n
                }\n
                return node;\n
            },\n
            "geometryMember": function(geometry) {\n
                var node = this.createElementNSPlus("gml:geometryMember");\n
                var child = this.writeNode("feature:_geometry", geometry);\n
                node.appendChild(child.firstChild);\n
                return node;\n
            }\n
        },\n
        "feature": {\n
            "_typeName": function(feature) {\n
                var node = this.createElementNSPlus("feature:" + this.featureType, {\n
                    attributes: {fid: feature.fid}\n
                });\n
                if(feature.geometry) {\n
                    this.writeNode("feature:_geometry", feature.geometry, node);\n
                }\n
                for(var name in feature.attributes) {\n
                    var value = feature.attributes[name];\n
                    if(value != null) {\n
                        this.writeNode(\n
                            "feature:_attribute",\n
                            {name: name, value: value}, node\n
                        );\n
                    }\n
                }\n
                return node;\n
            },\n
            "_geometry": function(geometry) {\n
                if(this.externalProjection && this.internalProjection) {\n
                    geometry = geometry.clone().transform(\n
                        this.internalProjection, this.externalProjection\n
                    );\n
                }    \n
                var node = this.createElementNSPlus(\n
                    "feature:" + this.geometryName\n
                );\n
                var type = this.geometryTypes[geometry.CLASS_NAME];\n
                var child = this.writeNode("gml:" + type, geometry, node);\n
                if(this.srsName) {\n
                    child.setAttribute("srsName", this.srsName);\n
                }\n
                return node;\n
            },\n
            "_attribute": function(obj) {\n
                return this.createElementNSPlus("feature:" + obj.name, {\n
                    value: obj.value\n
                });\n
            }\n
        },\n
        "wfs": {\n
            "FeatureCollection": function(features) {\n
                /**\n
                 * This is only here because GML2 only describes abstract\n
                 * feature collections.  Typically, you would not be using\n
                 * the GML format to write wfs elements.  This just provides\n
                 * some way to write out lists of features.  GML3 defines the\n
                 * featureMembers element, so that is used by default instead.\n
                 */\n
                var node = this.createElementNSPlus("wfs:FeatureCollection");\n
                for(var i=0, len=features.length; i<len; ++i) {\n
                    this.writeNode("gml:featureMember", features[i], node);\n
                }\n
                return node;\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: setGeometryTypes\n
     * Sets the <geometryTypes> mapping.\n
     */\n
    setGeometryTypes: function() {\n
        this.geometryTypes = {\n
            "OpenLayers.Geometry.Point": "Point",\n
            "OpenLayers.Geometry.MultiPoint": "MultiPoint",\n
            "OpenLayers.Geometry.LineString": "LineString",\n
            "OpenLayers.Geometry.MultiLineString": "MultiLineString",\n
            "OpenLayers.Geometry.Polygon": "Polygon",\n
            "OpenLayers.Geometry.MultiPolygon": "MultiPolygon",\n
            "OpenLayers.Geometry.Collection": "GeometryCollection"\n
        };\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Format.GML.Base" \n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>24742</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
