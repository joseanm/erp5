<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.9</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>GeoRSS.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Format/XML.js\n
 * @requires OpenLayers/Feature/Vector.js\n
 * @requires OpenLayers/Geometry/Point.js\n
 * @requires OpenLayers/Geometry/LineString.js\n
 * @requires OpenLayers/Geometry/Polygon.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Format.GeoRSS\n
 * Read/write GeoRSS parser. Create a new instance with the \n
 *     <OpenLayers.Format.GeoRSS> constructor.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Format.XML>\n
 */\n
OpenLayers.Format.GeoRSS = OpenLayers.Class(OpenLayers.Format.XML, {\n
    \n
    /**\n
     * APIProperty: rssns\n
     * {String} RSS namespace to use. Defaults to\n
     *   "http://backend.userland.com/rss2"\n
     */\n
    rssns: "http://backend.userland.com/rss2",\n
    \n
    /**\n
     * APIProperty: featurens\n
     * {String} Feature Attributes namespace.  Defaults to\n
     *    "http://mapserver.gis.umn.edu/mapserver"\n
     */\n
    featureNS: "http://mapserver.gis.umn.edu/mapserver",\n
    \n
    /**\n
     * APIProperty: georssns\n
     * {String} GeoRSS namespace to use.  Defaults to\n
     *     "http://www.georss.org/georss"\n
     */\n
    georssns: "http://www.georss.org/georss",\n
\n
    /**\n
     * APIProperty: geons\n
     * {String} W3C Geo namespace to use.  Defaults to\n
     *     "http://www.w3.org/2003/01/geo/wgs84_pos#"\n
     */\n
    geons: "http://www.w3.org/2003/01/geo/wgs84_pos#",\n
    \n
    /**\n
     * APIProperty: featureTitle\n
     * {String} Default title for features.  Defaults to "Untitled"\n
     */\n
    featureTitle: "Untitled",\n
    \n
    /**\n
     * APIProperty: featureDescription\n
     * {String} Default description for features.  Defaults to "No Description"\n
     */\n
    featureDescription: "No Description",\n
    \n
    /**\n
     * Property: gmlParse\n
     * {Object} GML Format object for parsing features\n
     * Non-API and only created if necessary\n
     */\n
    gmlParser: null,\n
\n
    /**\n
     * APIProperty: xy\n
     * {Boolean} Order of the GML coordinate: true:(x,y) or false:(y,x)\n
     * For GeoRSS the default is (y,x), therefore: false\n
     */ \n
    xy: false,\n
    \n
    /**\n
     * Constructor: OpenLayers.Format.GeoRSS\n
     * Create a new parser for GeoRSS.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     */\n
    \n
    /**\n
     * Method: createGeometryFromItem\n
     * Return a geometry from a GeoRSS Item.\n
     *\n
     * Parameters:\n
     * item - {DOMElement} A GeoRSS item node.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Geometry>} A geometry representing the node.\n
     */\n
    createGeometryFromItem: function(item) {\n
        var point = this.getElementsByTagNameNS(item, this.georssns, "point");\n
        var lat = this.getElementsByTagNameNS(item, this.geons, \'lat\');\n
        var lon = this.getElementsByTagNameNS(item, this.geons, \'long\');\n
        \n
        var line = this.getElementsByTagNameNS(item,\n
                                                this.georssns,\n
                                                "line");\n
        var polygon = this.getElementsByTagNameNS(item,\n
                                                this.georssns,\n
                                                "polygon");\n
        var where = this.getElementsByTagNameNS(item, \n
                                                this.georssns, \n
                                                "where");\n
        var box = this.getElementsByTagNameNS(item, \n
                                              this.georssns, \n
                                              "box");\n
\n
        if (point.length > 0 || (lat.length > 0 && lon.length > 0)) {\n
            var location;\n
            if (point.length > 0) {\n
                location = OpenLayers.String.trim(\n
                                point[0].firstChild.nodeValue).split(/\\s+/);\n
                if (location.length !=2) {\n
                    location = OpenLayers.String.trim(\n
                                point[0].firstChild.nodeValue).split(/\\s*,\\s*/);\n
                }\n
            } else {\n
                location = [parseFloat(lat[0].firstChild.nodeValue),\n
                                parseFloat(lon[0].firstChild.nodeValue)];\n
            }    \n
\n
            var geometry = new OpenLayers.Geometry.Point(location[1], location[0]);\n
              \n
        } else if (line.length > 0) {\n
            var coords = OpenLayers.String.trim(this.getChildValue(line[0])).split(/\\s+/);\n
            var components = []; \n
            var point;\n
            for (var i=0, len=coords.length; i<len; i+=2) {\n
                point = new OpenLayers.Geometry.Point(coords[i+1], coords[i]);\n
                components.push(point);\n
            }\n
            geometry = new OpenLayers.Geometry.LineString(components);\n
        } else if (polygon.length > 0) { \n
            var coords = OpenLayers.String.trim(this.getChildValue(polygon[0])).split(/\\s+/);\n
            var components = []; \n
            var point;\n
            for (var i=0, len=coords.length; i<len; i+=2) {\n
                point = new OpenLayers.Geometry.Point(coords[i+1], coords[i]);\n
                components.push(point);\n
            }\n
            geometry = new OpenLayers.Geometry.Polygon([new OpenLayers.Geometry.LinearRing(components)]);\n
        } else if (where.length > 0) { \n
            if (!this.gmlParser) {\n
              this.gmlParser = new OpenLayers.Format.GML({\'xy\': this.xy});\n
            }\n
            var feature = this.gmlParser.parseFeature(where[0]);\n
            geometry = feature.geometry;\n
        } else if (box.length  > 0) {\n
            var coords = OpenLayers.String.trim(box[0].firstChild.nodeValue).split(/\\s+/);\n
            var components = [];\n
            var point;\n
            if (coords.length > 3) {\n
                point = new OpenLayers.Geometry.Point(coords[1], coords[0]);\n
                components.push(point);\n
                point = new OpenLayers.Geometry.Point(coords[1], coords[2]);\n
                components.push(point);\n
                point = new OpenLayers.Geometry.Point(coords[3], coords[2]);\n
                components.push(point);\n
                point = new OpenLayers.Geometry.Point(coords[3], coords[0]);\n
                components.push(point);\n
                point = new OpenLayers.Geometry.Point(coords[1], coords[0]);\n
                components.push(point);\n
            }\n
            geometry = new OpenLayers.Geometry.Polygon([new OpenLayers.Geometry.LinearRing(components)]);\n
        }\n
        \n
        if (geometry && this.internalProjection && this.externalProjection) {\n
            geometry.transform(this.externalProjection, \n
                               this.internalProjection);\n
        }\n
\n
        return geometry;\n
    },        \n
\n
    /**\n
     * Method: createFeatureFromItem\n
     * Return a feature from a GeoRSS Item.\n
     *\n
     * Parameters:\n
     * item - {DOMElement} A GeoRSS item node.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Feature.Vector>} A feature representing the item.\n
     */\n
    createFeatureFromItem: function(item) {\n
        var geometry = this.createGeometryFromItem(item);\n
     \n
        /* Provide defaults for title and description */\n
        var title = this._getChildValue(item, "*", "title", this.featureTitle);\n
       \n
        /* First try RSS descriptions, then Atom summaries */\n
        var description = this._getChildValue(\n
            item, "*", "description",\n
            this._getChildValue(item, "*", "content",\n
                this._getChildValue(item, "*", "summary", this.featureDescription)));\n
\n
        /* If no link URL is found in the first child node, try the\n
           href attribute */\n
        var link = this._getChildValue(item, "*", "link");\n
        if(!link) {\n
            try {\n
                link = this.getElementsByTagNameNS(item, "*", "link")[0].getAttribute("href");\n
            } catch(e) {\n
                link = null;\n
            }\n
        }\n
\n
        var id = this._getChildValue(item, "*", "id", null);\n
        \n
        var data = {\n
            "title": title,\n
            "description": description,\n
            "link": link\n
        };\n
        var feature = new OpenLayers.Feature.Vector(geometry, data);\n
        feature.fid = id;\n
        return feature;\n
    },        \n
    \n
    /**\n
     * Method: _getChildValue\n
     *\n
     * Parameters:\n
     * node - {DOMElement}\n
     * nsuri - {String} Child node namespace uri ("*" for any).\n
     * name - {String} Child node name.\n
     * def - {String} Optional string default to return if no child found.\n
     *\n
     * Returns:\n
     * {String} The value of the first child with the given tag name.  Returns\n
     *     default value or empty string if none found.\n
     */\n
    _getChildValue: function(node, nsuri, name, def) {\n
        var value;\n
        var eles = this.getElementsByTagNameNS(node, nsuri, name);\n
        if(eles && eles[0] && eles[0].firstChild\n
            && eles[0].firstChild.nodeValue) {\n
            value = this.getChildValue(eles[0]);\n
        } else {\n
            value = (def == undefined) ? "" : def;\n
        }\n
        return value;\n
    },\n
    \n
    /**\n
     * APIMethod: read\n
     * Return a list of features from a GeoRSS doc\n
     *\n
     * Parameters:\n
     * doc - {Element} \n
     *\n
     * Returns:\n
     * {Array(<OpenLayers.Feature.Vector>)}\n
     */\n
    read: function(doc) {\n
        if (typeof doc == "string") { \n
            doc = OpenLayers.Format.XML.prototype.read.apply(this, [doc]);\n
        }\n
\n
        /* Try RSS items first, then Atom entries */\n
        var itemlist = null;\n
        itemlist = this.getElementsByTagNameNS(doc, \'*\', \'item\');\n
        if (itemlist.length == 0) {\n
            itemlist = this.getElementsByTagNameNS(doc, \'*\', \'entry\');\n
        }\n
        \n
        var numItems = itemlist.length;\n
        var features = new Array(numItems);\n
        for(var i=0; i<numItems; i++) {\n
            features[i] = this.createFeatureFromItem(itemlist[i]);\n
        }\n
        return features;\n
    },\n
    \n
\n
    /**\n
     * APIMethod: write\n
     * Accept Feature Collection, and return a string. \n
     * \n
     * Parameters: \n
     * features - {Array(<OpenLayers.Feature.Vector>)} List of features to serialize into a string.\n
     */\n
    write: function(features) {\n
        var georss;\n
        if(OpenLayers.Util.isArray(features)) {\n
            georss = this.createElementNS(this.rssns, "rss");\n
            for(var i=0, len=features.length; i<len; i++) {\n
                georss.appendChild(this.createFeatureXML(features[i]));\n
            }\n
        } else {\n
            georss = this.createFeatureXML(features);\n
        }\n
        return OpenLayers.Format.XML.prototype.write.apply(this, [georss]);\n
    },\n
\n
    /**\n
     * Method: createFeatureXML\n
     * Accept an <OpenLayers.Feature.Vector>, and build a geometry for it.\n
     * \n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>} \n
     *\n
     * Returns:\n
     * {DOMElement}\n
     */\n
    createFeatureXML: function(feature) {\n
        var geometryNode = this.buildGeometryNode(feature.geometry);\n
        var featureNode = this.createElementNS(this.rssns, "item");\n
        var titleNode = this.createElementNS(this.rssns, "title");\n
        titleNode.appendChild(this.createTextNode(feature.attributes.title ? feature.attributes.title : ""));\n
        var descNode = this.createElementNS(this.rssns, "description");\n
        descNode.appendChild(this.createTextNode(feature.attributes.description ? feature.attributes.description : ""));\n
        featureNode.appendChild(titleNode);\n
        featureNode.appendChild(descNode);\n
        if (feature.attributes.link) {\n
            var linkNode = this.createElementNS(this.rssns, "link");\n
            linkNode.appendChild(this.createTextNode(feature.attributes.link));\n
            featureNode.appendChild(linkNode);\n
        }    \n
        for(var attr in feature.attributes) {\n
            if (attr == "link" || attr == "title" || attr == "description") { continue; } \n
            var attrText = this.createTextNode(feature.attributes[attr]); \n
            var nodename = attr;\n
            if (attr.search(":") != -1) {\n
                nodename = attr.split(":")[1];\n
            }    \n
            var attrContainer = this.createElementNS(this.featureNS, "feature:"+nodename);\n
            attrContainer.appendChild(attrText);\n
            featureNode.appendChild(attrContainer);\n
        }    \n
        featureNode.appendChild(geometryNode);\n
        return featureNode;\n
    },    \n
    \n
    /** \n
     * Method: buildGeometryNode\n
     * builds a GeoRSS node with a given geometry\n
     * \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     *\n
     * Returns:\n
     * {DOMElement} A gml node.\n
     */\n
    buildGeometryNode: function(geometry) {\n
        if (this.internalProjection && this.externalProjection) {\n
            geometry = geometry.clone();\n
            geometry.transform(this.internalProjection, \n
                               this.externalProjection);\n
        }\n
        var node;\n
        // match Polygon\n
        if (geometry.CLASS_NAME == "OpenLayers.Geometry.Polygon") {\n
            node = this.createElementNS(this.georssns, \'georss:polygon\');\n
            \n
            node.appendChild(this.buildCoordinatesNode(geometry.components[0]));\n
        }\n
        // match LineString\n
        else if (geometry.CLASS_NAME == "OpenLayers.Geometry.LineString") {\n
            node = this.createElementNS(this.georssns, \'georss:line\');\n
            \n
            node.appendChild(this.buildCoordinatesNode(geometry));\n
        }\n
        // match Point\n
        else if (geometry.CLASS_NAME == "OpenLayers.Geometry.Point") {\n
            node = this.createElementNS(this.georssns, \'georss:point\');\n
            node.appendChild(this.buildCoordinatesNode(geometry));\n
        } else {\n
            throw "Couldn\'t parse " + geometry.CLASS_NAME;\n
        }  \n
        return node;         \n
    },\n
    \n
    /** \n
     * Method: buildCoordinatesNode\n
     * \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     */\n
    buildCoordinatesNode: function(geometry) {\n
        var points = null;\n
        \n
        if (geometry.components) {\n
            points = geometry.components;\n
        }\n
\n
        var path;\n
        if (points) {\n
            var numPoints = points.length;\n
            var parts = new Array(numPoints);\n
            for (var i = 0; i < numPoints; i++) {\n
                parts[i] = points[i].y + " " + points[i].x;\n
            }\n
            path = parts.join(" ");\n
        } else {\n
            path = geometry.y + " " + geometry.x;\n
        }\n
        return this.createTextNode(path);\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Format.GeoRSS" \n
});     \n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>14717</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
