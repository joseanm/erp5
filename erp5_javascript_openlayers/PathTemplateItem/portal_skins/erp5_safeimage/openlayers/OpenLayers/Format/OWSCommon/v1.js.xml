<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.98</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>v1.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Format/OWSCommon.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Format.OWSCommon.v1\n
 * Common readers and writers for OWSCommon v1.X formats\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Format.XML>\n
 */\n
OpenLayers.Format.OWSCommon.v1 = OpenLayers.Class(OpenLayers.Format.XML, {\n
   \n
    /**\n
     * Property: regExes\n
     * Compiled regular expressions for manipulating strings.\n
     */\n
    regExes: {\n
        trimSpace: (/^\\s*|\\s*$/g),\n
        removeSpace: (/\\s*/g),\n
        splitSpace: (/\\s+/),\n
        trimComma: (/\\s*,\\s*/g)\n
    },\n
\n
    /**\n
     * Method: read\n
     *\n
     * Parameters:\n
     * data - {DOMElement} An OWSCommon document element.\n
     * options - {Object} Options for the reader.\n
     *\n
     * Returns:\n
     * {Object} An object representing the OWSCommon document.\n
     */\n
    read: function(data, options) {\n
        options = OpenLayers.Util.applyDefaults(options, this.options);\n
        var ows = {};\n
        this.readChildNodes(data, ows);\n
        return ows;\n
    },\n
\n
    /**\n
     * Property: readers\n
     * Contains public functions, grouped by namespace prefix, that will\n
     *     be applied when a namespaced node is found matching the function\n
     *     name.  The function will be applied in the scope of this parser\n
     *     with two arguments: the node being read and a context object passed\n
     *     from the parent.\n
     */\n
    readers: {\n
        "ows": {\n
            "Exception": function(node, exceptionReport) {\n
                var exception = {\n
                    code: node.getAttribute(\'exceptionCode\'),\n
                    locator: node.getAttribute(\'locator\'),\n
                    texts: []\n
                };\n
                exceptionReport.exceptions.push(exception);\n
                this.readChildNodes(node, exception);\n
            },\n
            "ExceptionText": function(node, exception) {\n
                var text = this.getChildValue(node);\n
                exception.texts.push(text);\n
            },\n
            "ServiceIdentification": function(node, obj) {\n
                obj.serviceIdentification = {};\n
                this.readChildNodes(node, obj.serviceIdentification);\n
            },\n
            "Title": function(node, obj) {\n
                obj.title = this.getChildValue(node);\n
            },\n
            "Abstract": function(node, serviceIdentification) {\n
                serviceIdentification["abstract"] = this.getChildValue(node);\n
            },\n
            "Keywords": function(node, serviceIdentification) {\n
                serviceIdentification.keywords = {};\n
                this.readChildNodes(node, serviceIdentification.keywords);\n
            },\n
            "Keyword": function(node, keywords) {\n
                keywords[this.getChildValue(node)] = true;\n
            },\n
            "ServiceType": function(node, serviceIdentification) {\n
                serviceIdentification.serviceType = {\n
                    codeSpace: node.getAttribute(\'codeSpace\'), \n
                    value: this.getChildValue(node)};\n
            },\n
            "ServiceTypeVersion": function(node, serviceIdentification) {\n
                serviceIdentification.serviceTypeVersion = this.getChildValue(node);\n
            },\n
            "Fees": function(node, serviceIdentification) {\n
                serviceIdentification.fees = this.getChildValue(node);\n
            },\n
            "AccessConstraints": function(node, serviceIdentification) {\n
                serviceIdentification.accessConstraints = \n
                    this.getChildValue(node);\n
            },\n
            "ServiceProvider": function(node, obj) {\n
                obj.serviceProvider = {};\n
                this.readChildNodes(node, obj.serviceProvider);\n
            },\n
            "ProviderName": function(node, serviceProvider) {\n
                serviceProvider.providerName = this.getChildValue(node);\n
            },\n
            "ProviderSite": function(node, serviceProvider) {\n
                serviceProvider.providerSite = this.getAttributeNS(node, \n
                    this.namespaces.xlink, "href");\n
            },\n
            "ServiceContact": function(node, serviceProvider) {\n
                serviceProvider.serviceContact = {};\n
                this.readChildNodes(node, serviceProvider.serviceContact);\n
            },\n
            "IndividualName": function(node, serviceContact) {\n
                serviceContact.individualName = this.getChildValue(node);\n
            },\n
            "PositionName": function(node, serviceContact) {\n
                serviceContact.positionName = this.getChildValue(node);\n
            },\n
            "ContactInfo": function(node, serviceContact) {\n
                serviceContact.contactInfo = {};\n
                this.readChildNodes(node, serviceContact.contactInfo);\n
            },\n
            "Phone": function(node, contactInfo) {\n
                contactInfo.phone = {};\n
                this.readChildNodes(node, contactInfo.phone);\n
            },\n
            "Voice": function(node, phone) {\n
                phone.voice = this.getChildValue(node);\n
            },\n
            "Address": function(node, contactInfo) {\n
                contactInfo.address = {};\n
                this.readChildNodes(node, contactInfo.address);\n
            },\n
            "DeliveryPoint": function(node, address) {\n
                address.deliveryPoint = this.getChildValue(node);\n
            },\n
            "City": function(node, address) {\n
                address.city = this.getChildValue(node);\n
            },\n
            "AdministrativeArea": function(node, address) {\n
                address.administrativeArea = this.getChildValue(node);\n
            },\n
            "PostalCode": function(node, address) {\n
                address.postalCode = this.getChildValue(node);\n
            },\n
            "Country": function(node, address) {\n
                address.country = this.getChildValue(node);\n
            },\n
            "ElectronicMailAddress": function(node, address) {\n
                address.electronicMailAddress = this.getChildValue(node);\n
            },\n
            "Role": function(node, serviceContact) {\n
                serviceContact.role = this.getChildValue(node);\n
            },\n
            "OperationsMetadata": function(node, obj) {\n
                obj.operationsMetadata = {};\n
                this.readChildNodes(node, obj.operationsMetadata);\n
            },\n
            "Operation": function(node, operationsMetadata) {\n
                var name = node.getAttribute("name");\n
                operationsMetadata[name] = {};\n
                this.readChildNodes(node, operationsMetadata[name]);\n
            },\n
            "DCP": function(node, operation) {\n
                operation.dcp = {};\n
                this.readChildNodes(node, operation.dcp);\n
            },\n
            "HTTP": function(node, dcp) {\n
                dcp.http = {};\n
                this.readChildNodes(node, dcp.http);\n
            },\n
            "Get": function(node, http) {\n
                if (!http.get) {\n
                    http.get = [];\n
                }\n
                var obj = {\n
                    url: this.getAttributeNS(node, this.namespaces.xlink, "href")\n
                };\n
                this.readChildNodes(node, obj);\n
                http.get.push(obj);\n
            },\n
            "Post": function(node, http) {\n
                if (!http.post) {\n
                    http.post = [];\n
                }\n
                var obj = {\n
                    url: this.getAttributeNS(node, this.namespaces.xlink, "href")\n
                };\n
                this.readChildNodes(node, obj);\n
                http.post.push(obj);\n
            },\n
            "Parameter": function(node, operation) {\n
                if (!operation.parameters) {\n
                    operation.parameters = {};\n
                }\n
                var name = node.getAttribute("name");\n
                operation.parameters[name] = {};\n
                this.readChildNodes(node, operation.parameters[name]);\n
            },\n
            "Constraint": function(node, obj) {\n
                if (!obj.constraints) {\n
                    obj.constraints = {};\n
                }\n
                var name = node.getAttribute("name");\n
                obj.constraints[name] = {};\n
                this.readChildNodes(node, obj.constraints[name]);\n
            },\n
            "Value": function(node, allowedValues) {\n
                allowedValues[this.getChildValue(node)] = true;\n
            },\n
            "OutputFormat": function(node, obj) {\n
                obj.formats.push({value: this.getChildValue(node)});\n
                this.readChildNodes(node, obj);\n
            },\n
            "WGS84BoundingBox": function(node, obj) {\n
                var boundingBox = {};\n
                boundingBox.crs = node.getAttribute("crs");\n
                if (obj.BoundingBox) {\n
                    obj.BoundingBox.push(boundingBox);\n
                } else {\n
                    obj.projection = boundingBox.crs;\n
                    boundingBox = obj;\n
               }\n
               this.readChildNodes(node, boundingBox);\n
            },\n
            "BoundingBox": function(node, obj) {\n
                // FIXME: We consider that BoundingBox is the same as WGS84BoundingBox\n
                // LowerCorner = "min_x min_y"\n
                // UpperCorner = "max_x max_y"\n
                // It should normally depend on the projection\n
                this.readers[\'ows\'][\'WGS84BoundingBox\'].apply(this, [node, obj]);\n
            },\n
            "LowerCorner": function(node, obj) {\n
                var str = this.getChildValue(node).replace(\n
                    this.regExes.trimSpace, "");\n
                str = str.replace(this.regExes.trimComma, ",");\n
                var pointList = str.split(this.regExes.splitSpace);\n
                obj.left = pointList[0];\n
                obj.bottom = pointList[1];\n
            },\n
            "UpperCorner": function(node, obj) {\n
                var str = this.getChildValue(node).replace(\n
                    this.regExes.trimSpace, "");\n
                str = str.replace(this.regExes.trimComma, ",");\n
                var pointList = str.split(this.regExes.splitSpace);\n
                obj.right = pointList[0];\n
                obj.top = pointList[1];\n
                obj.bounds = new OpenLayers.Bounds(obj.left, obj.bottom,\n
                    obj.right, obj.top);\n
                delete obj.left;\n
                delete obj.bottom;\n
                delete obj.right;\n
                delete obj.top;\n
            },\n
            "Language": function(node, obj) {\n
                obj.language = this.getChildValue(node);\n
            }\n
        }\n
    },\n
\n
    /**\n
     * Property: writers\n
     * As a compliment to the readers property, this structure contains public\n
     *     writing functions grouped by namespace alias and named like the\n
     *     node names they produce.\n
     */\n
    writers: {\n
        "ows": {\n
            "BoundingBox": function(options) {\n
                var node = this.createElementNSPlus("ows:BoundingBox", {\n
                    attributes: {\n
                        crs: options.projection\n
                    }\n
                });\n
                this.writeNode("ows:LowerCorner", options, node);\n
                this.writeNode("ows:UpperCorner", options, node);\n
                return node;\n
            },\n
            "LowerCorner": function(options) {\n
                var node = this.createElementNSPlus("ows:LowerCorner", {\n
                    value: options.bounds.left + " " + options.bounds.bottom });\n
                return node;\n
            },\n
            "UpperCorner": function(options) {\n
                var node = this.createElementNSPlus("ows:UpperCorner", {\n
                    value: options.bounds.right + " " + options.bounds.top });\n
                return node;\n
            },\n
            "Identifier": function(identifier) {\n
                var node = this.createElementNSPlus("ows:Identifier", {\n
                    value: identifier });\n
                return node;\n
            },\n
            "Title": function(title) {\n
                var node = this.createElementNSPlus("ows:Title", {\n
                    value: title });\n
                return node;\n
            },\n
            "Abstract": function(abstractValue) {\n
                var node = this.createElementNSPlus("ows:Abstract", {\n
                    value: abstractValue });\n
                return node;\n
            },\n
            "OutputFormat": function(format) {\n
                var node = this.createElementNSPlus("ows:OutputFormat", {\n
                    value: format });\n
                return node;\n
            }\n
        }\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Format.OWSCommon.v1"\n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>12883</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
