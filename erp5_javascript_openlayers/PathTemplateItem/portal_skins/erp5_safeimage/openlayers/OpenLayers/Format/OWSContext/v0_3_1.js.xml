<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.96</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>v0_3_1.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Format/XML.js\n
 * @requires OpenLayers/Format/KML.js\n
 * @requires OpenLayers/Format/GML.js\n
 * @requires OpenLayers/Format/GML/v2.js\n
 * @requires OpenLayers/Format/SLD/v1_0_0.js\n
 * @requires OpenLayers/Format/OWSContext.js\n
 * @requires OpenLayers/Format/OWSCommon/v1_0_0.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Format.OWSContext.v0_3_1\n
 * Read and write OWSContext version 0.3.1.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Format.XML>\n
 */\n
OpenLayers.Format.OWSContext.v0_3_1 = OpenLayers.Class(OpenLayers.Format.XML, {\n
    \n
    /**\n
     * Property: namespaces\n
     * {Object} Mapping of namespace aliases to namespace URIs.\n
     */\n
    namespaces: {\n
        owc: "http://www.opengis.net/ows-context",\n
        gml: "http://www.opengis.net/gml",\n
        kml: "http://www.opengis.net/kml/2.2",\n
        ogc: "http://www.opengis.net/ogc",\n
        ows: "http://www.opengis.net/ows",\n
        sld: "http://www.opengis.net/sld",\n
        xlink: "http://www.w3.org/1999/xlink",\n
        xsi: "http://www.w3.org/2001/XMLSchema-instance"\n
    },\n
\n
    /**\n
     * Constant: VERSION\n
     * {String} 0.3.1\n
     */\n
    VERSION: "0.3.1", \n
\n
    /**\n
     * Property: schemaLocation\n
     * {String} Schema location\n
     */\n
    schemaLocation: "http://www.opengis.net/ows-context http://www.ogcnetwork.net/schemas/owc/0.3.1/owsContext.xsd",\n
\n
    /**\n
     * Property: defaultPrefix\n
     * {String} Default namespace prefix to use.\n
     */\n
    defaultPrefix: "owc",\n
\n
    /**\n
     * APIProperty: extractAttributes\n
     * {Boolean} Extract attributes from GML.  Default is true.\n
     */\n
    extractAttributes: true,\n
    \n
    /**\n
     * APIProperty: xy\n
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)\n
     * Changing is not recommended, a new Format should be instantiated.\n
     */ \n
    xy: true, \n
\n
    /**\n
     * Property: regExes\n
     * Compiled regular expressions for manipulating strings.\n
     */\n
    regExes: {\n
        trimSpace: (/^\\s*|\\s*$/g),\n
        removeSpace: (/\\s*/g),\n
        splitSpace: (/\\s+/),\n
        trimComma: (/\\s*,\\s*/g)\n
    },\n
\n
    /**\n
     * Property: featureNS\n
     * {String} The namespace uri to use for writing InlineGeometry\n
     */\n
    featureNS: "http://mapserver.gis.umn.edu/mapserver",\n
\n
    /**\n
     * Property: featureType\n
     * {String} The name to use as the feature type when writing out\n
     *     InlineGeometry\n
     */\n
    featureType: \'vector\',\n
              \n
    /**\n
     * Property: geometryName\n
     * {String} The name to use for the geometry attribute when writing out\n
     *     InlineGeometry\n
     */\n
    geometryName: \'geometry\',\n
\n
    /**\n
     * Property: nestingLayerLookup\n
     * {Object} Hashtable lookup for nesting layer nodes. Used while writing \n
     *     the OWS context document. It is necessary to keep track of the \n
     *     nestingPaths for which nesting layer nodes have already been \n
     *     created, so (nesting) layer nodes are added to those nodes.\n
     *\n
     * For example:\n
     *\n
     *     If there are three layers with nestingPaths:\n
     *         layer1.metadata.nestingPath = "a/b/"\n
     *         layer2.metadata.nestingPath = "a/b/"\n
     *         layer2.metadata.nestingPath = "a/c"\n
     *\n
     *     then a nesting layer node "a" should be created once and added \n
     *     to the resource list, a nesting layer node "b" should be created \n
     *     once and added under "a", and a nesting layer node "c" should be \n
     *     created and added under "a". The lookup paths for these nodes \n
     *     will be "a", "a/b", and "a/c" respectively.\n
     */\n
    nestingLayerLookup: null,\n
\n
    /**\n
     * Constructor: OpenLayers.Format.OWSContext.v0_3_1\n
     * Instances of this class are not created directly.  Use the\n
     *     <OpenLayers.Format.OWSContext> constructor instead.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     */\n
    initialize: function(options) {\n
        OpenLayers.Format.XML.prototype.initialize.apply(this, [options]);\n
        OpenLayers.Format.GML.v2.prototype.setGeometryTypes.call(this);\n
    },\n
\n
    /**\n
     * Method: setNestingPath\n
     * Set the nestingPath property of the layer depending on the position\n
     *     of the layer in hierarchy of layers.\n
     *\n
     * Parameters:\n
     * l - {Object} An object that may have a layersContext array property.\n
     * \n
     */\n
    setNestingPath : function(l){\n
        if(l.layersContext){\n
            for (var i = 0, len = l.layersContext.length; i < len; i++) {\n
                var layerContext = l.layersContext[i];\n
                var nPath = [];\n
                var nTitle = l.title || "";\n
                if(l.metadata && l.metadata.nestingPath){\n
                    nPath = l.metadata.nestingPath.slice();\n
                }\n
                if (nTitle != "") {\n
                    nPath.push(nTitle);\n
                }\n
                layerContext.metadata.nestingPath = nPath;\n
                if(layerContext.layersContext){\n
                    this.setNestingPath(layerContext);\n
                }\n
            }\n
        }\n
    },\n
\n
    /**\n
     * Function: decomposeNestingPath\n
     * Takes a nestingPath like "a/b/c" and decomposes it into subpaths:\n
     * "a", "a/b", "a/b/c"\n
     *\n
     * Parameters:\n
     * nPath  - {Array} the nesting path\n
     *\n
     * Returns:\n
     * Array({String}) Array with subpaths, or empty array if there is nothing\n
     *     to decompose\n
     */\n
    decomposeNestingPath: function(nPath){\n
        var a = [];\n
        if (OpenLayers.Util.isArray(nPath)) {\n
            var path = nPath.slice();\n
            while (path.length > 0) {\n
                a.push(path.slice());\n
                path.pop();\n
            }\n
            a.reverse();\n
        }\n
        return a;\n
    },\n
\n
    /**\n
     * APIMethod: read\n
     * Read OWS context data from a string or DOMElement, and return a list \n
     *     of layers. \n
     * \n
     * Parameters: \n
     * data - {String} or {DOMElement} data to read/parse.\n
     *\n
     * Returns:\n
     * {Object} The context object with a flat layer list as a property named\n
     *     layersContext.\n
     */\n
    read: function(data) {\n
        if(typeof data == "string") {\n
            data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);\n
        }\n
        if(data && data.nodeType == 9) {\n
            data = data.documentElement;\n
        }\n
        var context = {};\n
        this.readNode(data, context);\n
        // since an OWSContext can be nested we need to go through this\n
        // structure recursively      \n
        this.setNestingPath({layersContext : context.layersContext});\n
        // after nesting path has been set, create a flat list of layers\n
        var layers = [];\n
        this.processLayer(layers, context);\n
        delete context.layersContext;\n
        context.layersContext = layers;\n
        return context;\n
    },\n
\n
    /**\n
     * Method: processLayer\n
     * Recursive function to get back a flat list of layers from the hierarchic\n
     *     layer structure.\n
     *\n
     * Parameters:\n
     * layerArray - {Array({Object})} Array of layerContext objects\n
     * layer - {Object} layerContext object\n
     */\n
    processLayer: function(layerArray, layer) {\n
        if (layer.layersContext) {\n
            for (var i=0, len = layer.layersContext.length; i<len; i++) {\n
                var l = layer.layersContext[i];\n
                layerArray.push(l);\n
                if (l.layersContext) {\n
                    this.processLayer(layerArray, l);\n
                }\n
            }\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: write\n
     *\n
     * Parameters:\n
     * context - {Object} An object representing the map context.\n
     * options - {Object} Optional object.\n
     *\n
     * Returns:\n
     * {String} An OWS Context document string.\n
     */\n
    write: function(context, options) {\n
        var name = "OWSContext";\n
        this.nestingLayerLookup = {}; //start with empty lookup\n
        options = options || {};\n
        OpenLayers.Util.applyDefaults(options, context);\n
        var root = this.writeNode(name, options);\n
        this.nestingLayerLookup = null; //clear lookup\n
        this.setAttributeNS(\n
            root, this.namespaces["xsi"],\n
            "xsi:schemaLocation", this.schemaLocation\n
        );\n
        return OpenLayers.Format.XML.prototype.write.apply(this, [root]);\n
    }, \n
\n
    /**\n
     * Property: readers\n
     * Contains public functions, grouped by namespace prefix, that will\n
     *     be applied when a namespaced node is found matching the function\n
     *     name.  The function will be applied in the scope of this parser\n
     *     with two arguments: the node being read and a context object passed\n
     *     from the parent.\n
     */\n
    readers: {\n
        "kml": {\n
            "Document": function(node, obj) {\n
                obj.features = new OpenLayers.Format.KML(\n
                    {kmlns: this.namespaces.kml, \n
                        extractStyles: true}).read(node);\n
            }\n
        },\n
        "owc": { \n
            "OWSContext": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            }, \n
            "General": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            },\n
            "ResourceList": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            },\n
            "Layer": function(node, obj) {\n
                var layerContext = {\n
                    metadata: {},\n
                    visibility: (node.getAttribute("hidden") != "1"),\n
                    queryable: (node.getAttribute("queryable") == "1"),\n
                    opacity: ((node.getAttribute("opacity") != null) ? \n
                        parseFloat(node.getAttribute("opacity")) : null),\n
                    name: node.getAttribute("name"),\n
                    /* A category layer is a dummy layer meant for creating\n
                       hierarchies. It is not a physical layer in the \n
                       OpenLayers sense. The assumption we make here is that\n
                       category layers do not have a name attribute */\n
                    categoryLayer: (node.getAttribute("name") == null),\n
                    formats: [],\n
                    styles: []\n
                };\n
                if (!obj.layersContext) {\n
                    obj.layersContext = [];\n
                }\n
                obj.layersContext.push(layerContext);\n
                this.readChildNodes(node, layerContext);\n
            },\n
            "InlineGeometry": function(node, obj) {\n
                obj.features = [];\n
                var elements = this.getElementsByTagNameNS(node, \n
                    this.namespaces.gml, "featureMember");\n
                var el;\n
                if (elements.length >= 1) {\n
                    el = elements[0];\n
                }\n
                if (el && el.firstChild) {\n
                    var featurenode = (el.firstChild.nextSibling) ? \n
                        el.firstChild.nextSibling : el.firstChild;\n
                    this.setNamespace("feature", featurenode.namespaceURI);\n
                    this.featureType = featurenode.localName || \n
                        featurenode.nodeName.split(":").pop();\n
                    this.readChildNodes(node, obj);\n
                }\n
            },\n
            "Server": function(node, obj) {\n
                // when having multiple Server types, we prefer WMS\n
                if ((!obj.service && !obj.version) || \n
                    (obj.service != \n
                        OpenLayers.Format.Context.serviceTypes.WMS)) {\n
                            obj.service = node.getAttribute("service");\n
                            obj.version = node.getAttribute("version");\n
                            this.readChildNodes(node, obj);\n
                }\n
            },\n
            "Name": function(node, obj) {\n
                obj.name = this.getChildValue(node);\n
                this.readChildNodes(node, obj);\n
            },\n
            "Title": function(node, obj) {\n
                obj.title = this.getChildValue(node);\n
                this.readChildNodes(node, obj);\n
            },\n
            "StyleList": function(node, obj) {\n
                this.readChildNodes(node, obj.styles);\n
            },\n
            "Style": function(node, obj) {\n
                var style = {};\n
                obj.push(style);\n
                this.readChildNodes(node, style);\n
            },\n
            "LegendURL": function(node, obj) {\n
                var legend = {};\n
                obj.legend = legend;\n
                this.readChildNodes(node, legend);\n
            },\n
            "OnlineResource": function(node, obj) {\n
                obj.url = this.getAttributeNS(node, this.namespaces.xlink, \n
                    "href");\n
                this.readChildNodes(node, obj);\n
            }\n
        },\n
        "ows": OpenLayers.Format.OWSCommon.v1_0_0.prototype.readers.ows,\n
        "gml": OpenLayers.Format.GML.v2.prototype.readers.gml,\n
        "sld": OpenLayers.Format.SLD.v1_0_0.prototype.readers.sld,\n
        "feature": OpenLayers.Format.GML.v2.prototype.readers.feature\n
    },\n
\n
    /**\n
     * Property: writers\n
     * As a compliment to the readers property, this structure contains public\n
     *     writing functions grouped by namespace alias and named like the\n
     *     node names they produce.\n
     */\n
    writers: {\n
        "owc": {\n
            "OWSContext": function(options) {\n
                var node = this.createElementNSPlus("OWSContext", {\n
                    attributes: {\n
                        version: this.VERSION,\n
                        id: options.id || OpenLayers.Util.createUniqueID("OpenLayers_OWSContext_")\n
                    } \n
                }); \n
                this.writeNode("General", options, node);\n
                this.writeNode("ResourceList", options, node);\n
                return node; \n
            },\n
            "General": function(options) {\n
                var node = this.createElementNSPlus("General");\n
                this.writeNode("ows:BoundingBox", options, node);\n
                this.writeNode("ows:Title", options.title || \'OpenLayers OWSContext\', node);\n
                return node;\n
            },\n
            "ResourceList": function(options) {\n
                var node = this.createElementNSPlus("ResourceList");\n
                for (var i=0, len=options.layers.length; i<len; i++) {\n
                    var layer = options.layers[i];\n
                    var decomposedPath = this.decomposeNestingPath(layer.metadata.nestingPath);\n
                    this.writeNode("_Layer", {layer: layer, subPaths: decomposedPath}, node);\n
                }\n
                return node;\n
            },\n
            "Server": function(options) {\n
                var node = this.createElementNSPlus("Server", {attributes: {\n
                    version: options.version,\n
                    service: options.service }\n
                });\n
                this.writeNode("OnlineResource", options, node);\n
                return node;\n
            },\n
            "OnlineResource": function(options) {\n
                var node = this.createElementNSPlus("OnlineResource", {attributes: {\n
                    "xlink:href": options.url }\n
                });\n
                return node;\n
            },\n
            "InlineGeometry": function(layer) {\n
                var node = this.createElementNSPlus("InlineGeometry");\n
                this.writeNode("gml:boundedBy", layer.getDataExtent(), node);\n
                for (var i=0, len=layer.features.length; i<len; i++) {\n
                    this.writeNode("gml:featureMember", layer.features[i], node);\n
                }\n
                return node;\n
            },\n
            "StyleList": function(styles) {\n
                var node = this.createElementNSPlus("StyleList");\n
                for (var i=0, len=styles.length; i<len; i++) {\n
                    this.writeNode("Style", styles[i], node);\n
                }\n
                return node;\n
            },\n
            "Style": function(style) {\n
                var node = this.createElementNSPlus("Style");\n
                this.writeNode("Name", style, node);\n
                this.writeNode("Title", style, node);\n
                if (style.legend) {\n
                    this.writeNode("LegendURL", style, node);\n
                }\n
                return node;\n
            },\n
            "Name": function(obj) {\n
                var node = this.createElementNSPlus("Name", {\n
                    value: obj.name });\n
                return node;\n
            },\n
            "Title": function(obj) {\n
                var node = this.createElementNSPlus("Title", {\n
                    value: obj.title });\n
                return node;\n
            },\n
            "LegendURL": function(style) {\n
                var node = this.createElementNSPlus("LegendURL");\n
                this.writeNode("OnlineResource", style.legend, node);\n
                return node;\n
            },\n
            "_WMS": function(layer) {\n
                var node = this.createElementNSPlus("Layer", {attributes: {\n
                    name: layer.params.LAYERS,\n
                    queryable: layer.queryable ? "1" : "0",\n
                    hidden: layer.visibility ? "0" : "1",\n
                    opacity: layer.hasOwnProperty("opacity") ? layer.opacity : null}\n
                });\n
                this.writeNode("ows:Title", layer.name, node);\n
                this.writeNode("ows:OutputFormat", layer.params.FORMAT, node);\n
                this.writeNode("Server", {service: \n
                    OpenLayers.Format.Context.serviceTypes.WMS,\n
                    version: layer.params.VERSION, url: layer.url}, node);\n
                if (layer.metadata.styles && layer.metadata.styles.length > 0) {\n
                    this.writeNode("StyleList", layer.metadata.styles, node);\n
                }\n
                return node;\n
            },\n
            "_Layer": function(options) {\n
                var layer, subPaths, node, title;\n
                layer = options.layer;\n
                subPaths = options.subPaths;\n
                node = null;\n
                title = null;\n
                // subPaths is an array of an array\n
                // recursively calling _Layer writer eats up subPaths, until a \n
                // real writer is called and nodes are returned.\n
                if(subPaths.length > 0){\n
                    var path = subPaths[0].join("/");\n
                    var index = path.lastIndexOf("/");\n
                    node = this.nestingLayerLookup[path];\n
                    title = (index > 0)?path.substring(index + 1, path.length):path;\n
                    if(!node){\n
                        // category layer\n
                        node = this.createElementNSPlus("Layer");\n
                        this.writeNode("ows:Title", title, node);\n
                        this.nestingLayerLookup[path] = node;\n
                    }\n
                    options.subPaths.shift();//remove a path after each call\n
                    this.writeNode("_Layer", options, node);\n
                    return node;\n
                } else {\n
                    // write out the actual layer\n
                    if (layer instanceof OpenLayers.Layer.WMS) {\n
                        node = this.writeNode("_WMS", layer);\n
                    } else if (layer instanceof OpenLayers.Layer.Vector) {\n
                        if (layer.protocol instanceof OpenLayers.Protocol.WFS.v1) {\n
                            node = this.writeNode("_WFS", layer);\n
                        } else if (layer.protocol instanceof OpenLayers.Protocol.HTTP) {\n
                            if (layer.protocol.format instanceof OpenLayers.Format.GML) {\n
                                layer.protocol.format.version = "2.1.2";\n
                                node = this.writeNode("_GML", layer);\n
                            } else if (layer.protocol.format instanceof OpenLayers.Format.KML) {\n
                                layer.protocol.format.version = "2.2";\n
                                node = this.writeNode("_KML", layer);\n
                            }\n
                        } else {\n
                            // write out as inline GML since we have no idea\n
                            // about the original Format\n
                            this.setNamespace("feature", this.featureNS);\n
                            node = this.writeNode("_InlineGeometry", layer);\n
                        }\n
                    }\n
                    if (layer.options.maxScale) {\n
                        this.writeNode("sld:MinScaleDenominator", \n
                            layer.options.maxScale, node);\n
                    }\n
                    if (layer.options.minScale) {\n
                        this.writeNode("sld:MaxScaleDenominator", \n
                            layer.options.minScale, node);\n
                    }\n
                    this.nestingLayerLookup[layer.name] = node;\n
                    return node;\n
                }\n
            },\n
            "_WFS": function(layer) {\n
                var node = this.createElementNSPlus("Layer", {attributes: {\n
                    name: layer.protocol.featurePrefix + ":" + layer.protocol.featureType,\n
                    hidden: layer.visibility ? "0" : "1" }\n
                });\n
                this.writeNode("ows:Title", layer.name, node);\n
                this.writeNode("Server", {service: \n
                    OpenLayers.Format.Context.serviceTypes.WFS, \n
                    version: layer.protocol.version, \n
                    url: layer.protocol.url}, node);\n
                return node;\n
            },\n
            "_InlineGeometry": function(layer) {\n
                var node = this.createElementNSPlus("Layer", {attributes: {\n
                    name: this.featureType,\n
                    hidden: layer.visibility ? "0" : "1" }\n
                });\n
                this.writeNode("ows:Title", layer.name, node);\n
                this.writeNode("InlineGeometry", layer, node);\n
                return node;\n
            },\n
            "_GML": function(layer) {\n
                var node = this.createElementNSPlus("Layer");\n
                this.writeNode("ows:Title", layer.name, node);\n
                this.writeNode("Server", {service: \n
                    OpenLayers.Format.Context.serviceTypes.GML, \n
                    url: layer.protocol.url, version: \n
                    layer.protocol.format.version}, node);\n
                return node;\n
            },\n
            "_KML": function(layer) {\n
                var node = this.createElementNSPlus("Layer");\n
                this.writeNode("ows:Title", layer.name, node);\n
                this.writeNode("Server", {service: \n
                    OpenLayers.Format.Context.serviceTypes.KML,\n
                    version: layer.protocol.format.version, url: \n
                    layer.protocol.url}, node);\n
                return node;\n
            }\n
        },\n
        "gml": OpenLayers.Util.applyDefaults({\n
            "boundedBy": function(bounds) {\n
                var node = this.createElementNSPlus("gml:boundedBy");\n
                this.writeNode("gml:Box", bounds, node);\n
                return node;\n
            }\n
        }, OpenLayers.Format.GML.v2.prototype.writers.gml),\n
        "ows": OpenLayers.Format.OWSCommon.v1_0_0.prototype.writers.ows,\n
        "sld": OpenLayers.Format.SLD.v1_0_0.prototype.writers.sld,\n
        "feature": OpenLayers.Format.GML.v2.prototype.writers.feature\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Format.OWSContext.v0_3_1" \n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>23703</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
