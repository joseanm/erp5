<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.9</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>WCSGetCoverage.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Format/XML.js\n
 * @requires OpenLayers/Format/OWSCommon/v1_1_0.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Format.WCSGetCoverage version 1.1.0\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Format.XML>\n
 */\n
OpenLayers.Format.WCSGetCoverage = OpenLayers.Class(OpenLayers.Format.XML, {\n
    \n
    /**\n
     * Property: namespaces\n
     * {Object} Mapping of namespace aliases to namespace URIs.\n
     */\n
    namespaces: {\n
        ows: "http://www.opengis.net/ows/1.1",\n
        wcs: "http://www.opengis.net/wcs/1.1",\n
        xlink: "http://www.w3.org/1999/xlink",\n
        xsi: "http://www.w3.org/2001/XMLSchema-instance"\n
    },\n
\n
    /**\n
     * Property: regExes\n
     * Compiled regular expressions for manipulating strings.\n
     */\n
    regExes: {\n
        trimSpace: (/^\\s*|\\s*$/g),\n
        removeSpace: (/\\s*/g),\n
        splitSpace: (/\\s+/),\n
        trimComma: (/\\s*,\\s*/g)\n
    },\n
\n
    /**\n
     * Constant: VERSION\n
     * {String} 1.1.2\n
     */\n
    VERSION: "1.1.2",\n
\n
    /**\n
     * Property: schemaLocation\n
     * {String} Schema location\n
     */\n
    schemaLocation: "http://www.opengis.net/wcs/1.1 http://schemas.opengis.net/wcs/1.1/wcsGetCoverage.xsd",\n
\n
    /**\n
     * Constructor: OpenLayers.Format.WCSGetCoverage\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     */\n
\n
    /**\n
     * Method: write\n
     *\n
     * Parameters:\n
     * options - {Object} Optional object.\n
     *\n
     * Returns:\n
     * {String} A WCS GetCoverage request XML string.\n
     */\n
    write: function(options) {\n
        var node = this.writeNode("wcs:GetCoverage", options);\n
        this.setAttributeNS(\n
            node, this.namespaces.xsi,\n
            "xsi:schemaLocation", this.schemaLocation\n
        );\n
        return OpenLayers.Format.XML.prototype.write.apply(this, [node]);\n
    }, \n
\n
    /**\n
     * Property: writers\n
     * As a compliment to the readers property, this structure contains public\n
     *     writing functions grouped by namespace alias and named like the\n
     *     node names they produce.\n
     */\n
    writers: {\n
        "wcs": {\n
            "GetCoverage": function(options) {\n
                var node = this.createElementNSPlus("wcs:GetCoverage", {\n
                    attributes: {\n
                        version: options.version || this.VERSION,\n
                        service: \'WCS\'\n
                    } \n
                }); \n
                this.writeNode("ows:Identifier", options.identifier, node);\n
                this.writeNode("wcs:DomainSubset", options.domainSubset, node);\n
                this.writeNode("wcs:Output", options.output, node);\n
                return node; \n
            },\n
            "DomainSubset": function(domainSubset) {\n
                var node = this.createElementNSPlus("wcs:DomainSubset", {});\n
                this.writeNode("ows:BoundingBox", domainSubset.boundingBox, node);\n
                if (domainSubset.temporalSubset) {\n
                    this.writeNode("wcs:TemporalSubset", domainSubset.temporalSubset, node);\n
                }\n
                return node;\n
            },\n
            "TemporalSubset": function(temporalSubset) {\n
                var node = this.createElementNSPlus("wcs:TemporalSubset", {});\n
                for (var i=0, len=temporalSubset.timePeriods.length; i<len; ++i) {\n
                    this.writeNode("wcs:TimePeriod", temporalSubset.timePeriods[i], node);\n
                }\n
                return node;\n
            },\n
            "TimePeriod": function(timePeriod) {\n
                var node = this.createElementNSPlus("wcs:TimePeriod", {});\n
                this.writeNode("wcs:BeginPosition", timePeriod.begin, node);\n
                this.writeNode("wcs:EndPosition", timePeriod.end, node);\n
                if (timePeriod.resolution) {\n
                    this.writeNode("wcs:TimeResolution", timePeriod.resolution, node);\n
                }\n
                return node;\n
            },\n
            "BeginPosition": function(begin) {\n
                var node = this.createElementNSPlus("wcs:BeginPosition", {\n
                    value: begin\n
                });\n
                return node;\n
            },\n
            "EndPosition": function(end) {\n
                var node = this.createElementNSPlus("wcs:EndPosition", {\n
                    value: end\n
                });\n
                return node;\n
            },\n
            "TimeResolution": function(resolution) {\n
                var node = this.createElementNSPlus("wcs:TimeResolution", {\n
                    value: resolution\n
                });\n
                return node;\n
            },\n
            "Output": function(output) {\n
                var node = this.createElementNSPlus("wcs:Output", {\n
                    attributes: {\n
                        format: output.format,\n
                        store: output.store\n
                    }\n
                });\n
                if (output.gridCRS) {\n
                    this.writeNode("wcs:GridCRS", output.gridCRS, node);\n
                }\n
                return node;\n
            },\n
            "GridCRS": function(gridCRS) {\n
                var node = this.createElementNSPlus("wcs:GridCRS", {});\n
                this.writeNode("wcs:GridBaseCRS", gridCRS.baseCRS, node);\n
                if (gridCRS.type) {\n
                    this.writeNode("wcs:GridType", gridCRS.type, node);\n
                }\n
                if (gridCRS.origin) {\n
                    this.writeNode("wcs:GridOrigin", gridCRS.origin, node);\n
                }\n
                this.writeNode("wcs:GridOffsets", gridCRS.offsets, node);\n
                if (gridCRS.CS) {\n
                    this.writeNode("wcs:GridCS", gridCRS.CS, node);\n
                }\n
                return node;\n
            },\n
            "GridBaseCRS": function(baseCRS) {\n
                return this.createElementNSPlus("wcs:GridBaseCRS", {\n
                    value: baseCRS\n
                });\n
            },\n
            "GridOrigin": function(origin) {\n
                return this.createElementNSPlus("wcs:GridOrigin", {\n
                    value: origin\n
                });\n
            },\n
            "GridType": function(type) {\n
                return this.createElementNSPlus("wcs:GridType", {\n
                    value: type\n
                });\n
            },\n
            "GridOffsets": function(offsets) {\n
                return this.createElementNSPlus("wcs:GridOffsets", {\n
                    value: offsets\n
                });\n
            },\n
            "GridCS": function(CS) {\n
                return this.createElementNSPlus("wcs:GridCS", {\n
                    value: CS\n
                });\n
            }\n
        },\n
        "ows": OpenLayers.Format.OWSCommon.v1_1_0.prototype.writers.ows\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Format.WCSGetCoverage" \n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>7036</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
