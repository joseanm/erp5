<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.91</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>JSON.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * Note:\n
 * This work draws heavily from the public domain JSON serializer/deserializer\n
 *     at http://www.json.org/json.js. Rewritten so that it doesn\'t modify\n
 *     basic data prototypes.\n
 */\n
\n
/**\n
 * @requires OpenLayers/Format.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Format.JSON\n
 * A parser to read/write JSON safely.  Create a new instance with the\n
 *     <OpenLayers.Format.JSON> constructor.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Format>\n
 */\n
OpenLayers.Format.JSON = OpenLayers.Class(OpenLayers.Format, {\n
    \n
    /**\n
     * APIProperty: indent\n
     * {String} For "pretty" printing, the indent string will be used once for\n
     *     each indentation level.\n
     */\n
    indent: "    ",\n
    \n
    /**\n
     * APIProperty: space\n
     * {String} For "pretty" printing, the space string will be used after\n
     *     the ":" separating a name/value pair.\n
     */\n
    space: " ",\n
    \n
    /**\n
     * APIProperty: newline\n
     * {String} For "pretty" printing, the newline string will be used at the\n
     *     end of each name/value pair or array item.\n
     */\n
    newline: "\\n",\n
    \n
    /**\n
     * Property: level\n
     * {Integer} For "pretty" printing, this is incremented/decremented during\n
     *     serialization.\n
     */\n
    level: 0,\n
\n
    /**\n
     * Property: pretty\n
     * {Boolean} Serialize with extra whitespace for structure.  This is set\n
     *     by the <write> method.\n
     */\n
    pretty: false,\n
\n
    /**\n
     * Property: nativeJSON\n
     * {Boolean} Does the browser support native json?\n
     */\n
    nativeJSON: (function() {\n
        return !!(window.JSON && typeof JSON.parse == "function" && typeof JSON.stringify == "function");\n
    })(),\n
\n
    /**\n
     * Constructor: OpenLayers.Format.JSON\n
     * Create a new parser for JSON.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     */\n
\n
    /**\n
     * APIMethod: read\n
     * Deserialize a json string.\n
     *\n
     * Parameters:\n
     * json - {String} A JSON string\n
     * filter - {Function} A function which will be called for every key and\n
     *     value at every level of the final result. Each value will be\n
     *     replaced by the result of the filter function. This can be used to\n
     *     reform generic objects into instances of classes, or to transform\n
     *     date strings into Date objects.\n
     *     \n
     * Returns:\n
     * {Object} An object, array, string, or number .\n
     */\n
    read: function(json, filter) {\n
        var object;\n
        if (this.nativeJSON) {\n
            object = JSON.parse(json, filter);\n
        } else try {\n
            /**\n
             * Parsing happens in three stages. In the first stage, we run the\n
             *     text against a regular expression which looks for non-JSON\n
             *     characters. We are especially concerned with \'()\' and \'new\'\n
             *     because they can cause invocation, and \'=\' because it can\n
             *     cause mutation. But just to be safe, we will reject all\n
             *     unexpected characters.\n
             */\n
            if (/^[\\],:{}\\s]*$/.test(json.replace(/\\\\["\\\\\\/bfnrtu]/g, \'@\').\n
                                replace(/"[^"\\\\\\n\\r]*"|true|false|null|-?\\d+(?:\\.\\d*)?(?:[eE][+\\-]?\\d+)?/g, \']\').\n
                                replace(/(?:^|:|,)(?:\\s*\\[)+/g, \'\'))) {\n
\n
                /**\n
                 * In the second stage we use the eval function to compile the\n
                 *     text into a JavaScript structure. The \'{\' operator is\n
                 *     subject to a syntactic ambiguity in JavaScript - it can\n
                 *     begin a block or an object literal. We wrap the text in\n
                 *     parens to eliminate the ambiguity.\n
                 */\n
                object = eval(\'(\' + json + \')\');\n
\n
                /**\n
                 * In the optional third stage, we recursively walk the new\n
                 *     structure, passing each name/value pair to a filter\n
                 *     function for possible transformation.\n
                 */\n
                if(typeof filter === \'function\') {\n
                    function walk(k, v) {\n
                        if(v && typeof v === \'object\') {\n
                            for(var i in v) {\n
                                if(v.hasOwnProperty(i)) {\n
                                    v[i] = walk(i, v[i]);\n
                                }\n
                            }\n
                        }\n
                        return filter(k, v);\n
                    }\n
                    object = walk(\'\', object);\n
                }\n
            }\n
        } catch(e) {\n
            // Fall through if the regexp test fails.\n
        }\n
\n
        if(this.keepData) {\n
            this.data = object;\n
        }\n
\n
        return object;\n
    },\n
\n
    /**\n
     * APIMethod: write\n
     * Serialize an object into a JSON string.\n
     *\n
     * Parameters:\n
     * value - {String} The object, array, string, number, boolean or date\n
     *     to be serialized.\n
     * pretty - {Boolean} Structure the output with newlines and indentation.\n
     *     Default is false.\n
     *\n
     * Returns:\n
     * {String} The JSON string representation of the input value.\n
     */\n
    write: function(value, pretty) {\n
        this.pretty = !!pretty;\n
        var json = null;\n
        var type = typeof value;\n
        if(this.serialize[type]) {\n
            try {\n
                json = (!this.pretty && this.nativeJSON) ?\n
                    JSON.stringify(value) :\n
                    this.serialize[type].apply(this, [value]);\n
            } catch(err) {\n
                OpenLayers.Console.error("Trouble serializing: " + err);\n
            }\n
        }\n
        return json;\n
    },\n
    \n
    /**\n
     * Method: writeIndent\n
     * Output an indentation string depending on the indentation level.\n
     *\n
     * Returns:\n
     * {String} An appropriate indentation string.\n
     */\n
    writeIndent: function() {\n
        var pieces = [];\n
        if(this.pretty) {\n
            for(var i=0; i<this.level; ++i) {\n
                pieces.push(this.indent);\n
            }\n
        }\n
        return pieces.join(\'\');\n
    },\n
    \n
    /**\n
     * Method: writeNewline\n
     * Output a string representing a newline if in pretty printing mode.\n
     *\n
     * Returns:\n
     * {String} A string representing a new line.\n
     */\n
    writeNewline: function() {\n
        return (this.pretty) ? this.newline : \'\';\n
    },\n
    \n
    /**\n
     * Method: writeSpace\n
     * Output a string representing a space if in pretty printing mode.\n
     *\n
     * Returns:\n
     * {String} A space.\n
     */\n
    writeSpace: function() {\n
        return (this.pretty) ? this.space : \'\';\n
    },\n
\n
    /**\n
     * Property: serialize\n
     * Object with properties corresponding to the serializable data types.\n
     *     Property values are functions that do the actual serializing.\n
     */\n
    serialize: {\n
        /**\n
         * Method: serialize.object\n
         * Transform an object into a JSON string.\n
         *\n
         * Parameters:\n
         * object - {Object} The object to be serialized.\n
         * \n
         * Returns:\n
         * {String} A JSON string representing the object.\n
         */\n
        \'object\': function(object) {\n
            // three special objects that we want to treat differently\n
            if(object == null) {\n
                return "null";\n
            }\n
            if(object.constructor == Date) {\n
                return this.serialize.date.apply(this, [object]);\n
            }\n
            if(object.constructor == Array) {\n
                return this.serialize.array.apply(this, [object]);\n
            }\n
            var pieces = [\'{\'];\n
            this.level += 1;\n
            var key, keyJSON, valueJSON;\n
            \n
            var addComma = false;\n
            for(key in object) {\n
                if(object.hasOwnProperty(key)) {\n
                    // recursive calls need to allow for sub-classing\n
                    keyJSON = OpenLayers.Format.JSON.prototype.write.apply(this,\n
                                                    [key, this.pretty]);\n
                    valueJSON = OpenLayers.Format.JSON.prototype.write.apply(this,\n
                                                    [object[key], this.pretty]);\n
                    if(keyJSON != null && valueJSON != null) {\n
                        if(addComma) {\n
                            pieces.push(\',\');\n
                        }\n
                        pieces.push(this.writeNewline(), this.writeIndent(),\n
                                    keyJSON, \':\', this.writeSpace(), valueJSON);\n
                        addComma = true;\n
                    }\n
                }\n
            }\n
            \n
            this.level -= 1;\n
            pieces.push(this.writeNewline(), this.writeIndent(), \'}\');\n
            return pieces.join(\'\');\n
        },\n
        \n
        /**\n
         * Method: serialize.array\n
         * Transform an array into a JSON string.\n
         *\n
         * Parameters:\n
         * array - {Array} The array to be serialized\n
         * \n
         * Returns:\n
         * {String} A JSON string representing the array.\n
         */\n
        \'array\': function(array) {\n
            var json;\n
            var pieces = [\'[\'];\n
            this.level += 1;\n
    \n
            for(var i=0, len=array.length; i<len; ++i) {\n
                // recursive calls need to allow for sub-classing\n
                json = OpenLayers.Format.JSON.prototype.write.apply(this,\n
                                                    [array[i], this.pretty]);\n
                if(json != null) {\n
                    if(i > 0) {\n
                        pieces.push(\',\');\n
                    }\n
                    pieces.push(this.writeNewline(), this.writeIndent(), json);\n
                }\n
            }\n
\n
            this.level -= 1;    \n
            pieces.push(this.writeNewline(), this.writeIndent(), \']\');\n
            return pieces.join(\'\');\n
        },\n
        \n
        /**\n
         * Method: serialize.string\n
         * Transform a string into a JSON string.\n
         *\n
         * Parameters:\n
         * string - {String} The string to be serialized\n
         * \n
         * Returns:\n
         * {String} A JSON string representing the string.\n
         */\n
        \'string\': function(string) {\n
            // If the string contains no control characters, no quote characters, and no\n
            // backslash characters, then we can simply slap some quotes around it.\n
            // Otherwise we must also replace the offending characters with safe\n
            // sequences.    \n
            var m = {\n
                \'\\b\': \'\\\\b\',\n
                \'\\t\': \'\\\\t\',\n
                \'\\n\': \'\\\\n\',\n
                \'\\f\': \'\\\\f\',\n
                \'\\r\': \'\\\\r\',\n
                \'"\' : \'\\\\"\',\n
                \'\\\\\': \'\\\\\\\\\'\n
            };\n
            if(/["\\\\\\x00-\\x1f]/.test(string)) {\n
                return \'"\' + string.replace(/([\\x00-\\x1f\\\\"])/g, function(a, b) {\n
                    var c = m[b];\n
                    if(c) {\n
                        return c;\n
                    }\n
                    c = b.charCodeAt();\n
                    return \'\\\\u00\' +\n
                        Math.floor(c / 16).toString(16) +\n
                        (c % 16).toString(16);\n
                }) + \'"\';\n
            }\n
            return \'"\' + string + \'"\';\n
        },\n
\n
        /**\n
         * Method: serialize.number\n
         * Transform a number into a JSON string.\n
         *\n
         * Parameters:\n
         * number - {Number} The number to be serialized.\n
         *\n
         * Returns:\n
         * {String} A JSON string representing the number.\n
         */\n
        \'number\': function(number) {\n
            return isFinite(number) ? String(number) : "null";\n
        },\n
        \n
        /**\n
         * Method: serialize.boolean\n
         * Transform a boolean into a JSON string.\n
         *\n
         * Parameters:\n
         * bool - {Boolean} The boolean to be serialized.\n
         * \n
         * Returns:\n
         * {String} A JSON string representing the boolean.\n
         */\n
        \'boolean\': function(bool) {\n
            return String(bool);\n
        },\n
        \n
        /**\n
         * Method: serialize.object\n
         * Transform a date into a JSON string.\n
         *\n
         * Parameters:\n
         * date - {Date} The date to be serialized.\n
         * \n
         * Returns:\n
         * {String} A JSON string representing the date.\n
         */\n
        \'date\': function(date) {    \n
            function format(number) {\n
                // Format integers to have at least two digits.\n
                return (number < 10) ? \'0\' + number : number;\n
            }\n
            return \'"\' + date.getFullYear() + \'-\' +\n
                    format(date.getMonth() + 1) + \'-\' +\n
                    format(date.getDate()) + \'T\' +\n
                    format(date.getHours()) + \':\' +\n
                    format(date.getMinutes()) + \':\' +\n
                    format(date.getSeconds()) + \'"\';\n
        }\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Format.JSON" \n
\n
});     \n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>13212</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
