<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.92</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>KML.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/BaseTypes/Date.js\n
 * @requires OpenLayers/Format/XML.js\n
 * @requires OpenLayers/Feature/Vector.js\n
 * @requires OpenLayers/Geometry/Point.js\n
 * @requires OpenLayers/Geometry/LineString.js\n
 * @requires OpenLayers/Geometry/Polygon.js\n
 * @requires OpenLayers/Geometry/Collection.js\n
 * @requires OpenLayers/Request/XMLHttpRequest.js\n
 * @requires OpenLayers/Projection.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Format.KML\n
 * Read/Write KML. Create a new instance with the <OpenLayers.Format.KML>\n
 *     constructor. \n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Format.XML>\n
 */\n
OpenLayers.Format.KML = OpenLayers.Class(OpenLayers.Format.XML, {\n
    \n
    /**\n
     * Property: namespaces\n
     * {Object} Mapping of namespace aliases to namespace URIs.\n
     */\n
    namespaces: {\n
        kml: "http://www.opengis.net/kml/2.2",\n
        gx: "http://www.google.com/kml/ext/2.2"\n
    },\n
\n
    /**\n
     * APIProperty: kmlns\n
     * {String} KML Namespace to use. Defaults to 2.0 namespace.\n
     */\n
    kmlns: "http://earth.google.com/kml/2.0",\n
    \n
    /** \n
     * APIProperty: placemarksDesc\n
     * {String} Name of the placemarks.  Default is "No description available".\n
     */\n
    placemarksDesc: "No description available",\n
    \n
    /** \n
     * APIProperty: foldersName\n
     * {String} Name of the folders.  Default is "OpenLayers export".\n
     *          If set to null, no name element will be created.\n
     */\n
    foldersName: "OpenLayers export",\n
    \n
    /** \n
     * APIProperty: foldersDesc\n
     * {String} Description of the folders. Default is "Exported on [date]."\n
     *          If set to null, no description element will be created.\n
     */\n
    foldersDesc: "Exported on " + new Date(),\n
    \n
    /**\n
     * APIProperty: extractAttributes\n
     * {Boolean} Extract attributes from KML.  Default is true.\n
     *           Extracting styleUrls requires this to be set to true\n
     *           Note that currently only Data and SimpleData \n
     *           elements are handled.\n
     */\n
    extractAttributes: true,\n
    \n
    /**\n
     * APIProperty: kvpAttributes\n
     * {Boolean} Only used if extractAttributes is true.\n
     *           If set to true, attributes will be simple\n
     *           key-value pairs, compatible with other formats,\n
     *           Any displayName elements will be ignored.\n
     *           If set to false, attributes will be objects,\n
     *           retaining any displayName elements, but not\n
     *           compatible with other formats. Any CDATA in\n
     *           displayName will be read in as a string value.\n
     *           Default is false.\n
     */\n
    kvpAttributes: false,\n
    \n
    /**\n
     * Property: extractStyles\n
     * {Boolean} Extract styles from KML.  Default is false.\n
     *           Extracting styleUrls also requires extractAttributes to be\n
     *           set to true\n
     */\n
    extractStyles: false,\n
    \n
    /**\n
     * APIProperty: extractTracks\n
     * {Boolean} Extract gx:Track elements from Placemark elements.  Default\n
     *     is false.  If true, features will be generated for all points in\n
     *     all gx:Track elements.  Features will have a when (Date) attribute\n
     *     based on when elements in the track.  If tracks include angle\n
     *     elements, features will have heading, tilt, and roll attributes.\n
     *     If track point coordinates have three values, features will have\n
     *     an altitude attribute with the third coordinate value.\n
     */\n
    extractTracks: false,\n
    \n
    /**\n
     * APIProperty: trackAttributes\n
     * {Array} If <extractTracks> is true, points within gx:Track elements will \n
     *     be parsed as features with when, heading, tilt, and roll attributes.\n
     *     Any additional attribute names can be provided in <trackAttributes>.\n
     */\n
    trackAttributes: null,\n
    \n
    /**\n
     * Property: internalns\n
     * {String} KML Namespace to use -- defaults to the namespace of the\n
     *     Placemark node being parsed, but falls back to kmlns. \n
     */\n
    internalns: null,\n
\n
    /**\n
     * Property: features\n
     * {Array} Array of features\n
     *     \n
     */\n
    features: null,\n
\n
    /**\n
     * Property: styles\n
     * {Object} Storage of style objects\n
     *     \n
     */\n
    styles: null,\n
    \n
    /**\n
     * Property: styleBaseUrl\n
     * {String}\n
     */\n
    styleBaseUrl: "",\n
\n
    /**\n
     * Property: fetched\n
     * {Object} Storage of KML URLs that have been fetched before\n
     *     in order to prevent reloading them.\n
     */\n
    fetched: null,\n
\n
    /**\n
     * APIProperty: maxDepth\n
     * {Integer} Maximum depth for recursive loading external KML URLs \n
     *           Defaults to 0: do no external fetching\n
     */\n
    maxDepth: 0,\n
\n
    /**\n
     * Constructor: OpenLayers.Format.KML\n
     * Create a new parser for KML.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     */\n
    initialize: function(options) {\n
        // compile regular expressions once instead of every time they are used\n
        this.regExes = {\n
            trimSpace: (/^\\s*|\\s*$/g),\n
            removeSpace: (/\\s*/g),\n
            splitSpace: (/\\s+/),\n
            trimComma: (/\\s*,\\s*/g),\n
            kmlColor: (/(\\w{2})(\\w{2})(\\w{2})(\\w{2})/),\n
            kmlIconPalette: (/root:\\/\\/icons\\/palette-(\\d+)(\\.\\w+)/),\n
            straightBracket: (/\\$\\[(.*?)\\]/g)\n
        };\n
        // KML coordinates are always in longlat WGS84\n
        this.externalProjection = new OpenLayers.Projection("EPSG:4326");\n
\n
        OpenLayers.Format.XML.prototype.initialize.apply(this, [options]);\n
    },\n
\n
    /**\n
     * APIMethod: read\n
     * Read data from a string, and return a list of features. \n
     * \n
     * Parameters: \n
     * data    - {String} or {DOMElement} data to read/parse.\n
     *\n
     * Returns:\n
     * {Array(<OpenLayers.Feature.Vector>)} List of features.\n
     */\n
    read: function(data) {\n
        this.features = [];\n
        this.styles   = {};\n
        this.fetched  = {};\n
\n
        // Set default options \n
        var options = {\n
            depth: 0,\n
            styleBaseUrl: this.styleBaseUrl\n
        };\n
\n
        return this.parseData(data, options);\n
    },\n
\n
    /**\n
     * Method: parseData\n
     * Read data from a string, and return a list of features. \n
     * \n
     * Parameters: \n
     * data    - {String} or {DOMElement} data to read/parse.\n
     * options - {Object} Hash of options\n
     *\n
     * Returns:\n
     * {Array(<OpenLayers.Feature.Vector>)} List of features.\n
     */\n
    parseData: function(data, options) {\n
        if(typeof data == "string") {\n
            data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);\n
        }\n
\n
        // Loop throught the following node types in this order and\n
        // process the nodes found \n
        var types = ["Link", "NetworkLink", "Style", "StyleMap", "Placemark"];\n
        for(var i=0, len=types.length; i<len; ++i) {\n
            var type = types[i];\n
\n
            var nodes = this.getElementsByTagNameNS(data, "*", type);\n
\n
            // skip to next type if no nodes are found\n
            if(nodes.length == 0) { \n
                continue;\n
            }\n
\n
            switch (type.toLowerCase()) {\n
\n
                // Fetch external links \n
                case "link":\n
                case "networklink":\n
                    this.parseLinks(nodes, options);\n
                    break;\n
\n
                // parse style information\n
                case "style":\n
                    if (this.extractStyles) {\n
                        this.parseStyles(nodes, options);\n
                    }\n
                    break;\n
                case "stylemap":\n
                    if (this.extractStyles) {\n
                        this.parseStyleMaps(nodes, options);\n
                    }\n
                    break;\n
\n
                // parse features\n
                case "placemark":\n
                    this.parseFeatures(nodes, options);\n
                    break;\n
            }\n
        }\n
        \n
        return this.features;\n
    },\n
\n
    /**\n
     * Method: parseLinks\n
     * Finds URLs of linked KML documents and fetches them\n
     * \n
     * Parameters: \n
     * nodes   - {Array} of {DOMElement} data to read/parse.\n
     * options - {Object} Hash of options\n
     * \n
     */\n
    parseLinks: function(nodes, options) {\n
        \n
        // Fetch external links <NetworkLink> and <Link>\n
        // Don\'t do anything if we have reached our maximum depth for recursion\n
        if (options.depth >= this.maxDepth) {\n
            return false;\n
        }\n
\n
        // increase depth\n
        var newOptions = OpenLayers.Util.extend({}, options);\n
        newOptions.depth++;\n
\n
        for(var i=0, len=nodes.length; i<len; i++) {\n
            var href = this.parseProperty(nodes[i], "*", "href");\n
            if(href && !this.fetched[href]) {\n
                this.fetched[href] = true; // prevent reloading the same urls\n
                var data = this.fetchLink(href);\n
                if (data) {\n
                    this.parseData(data, newOptions);\n
                }\n
            } \n
        }\n
\n
    },\n
\n
    /**\n
     * Method: fetchLink\n
     * Fetches a URL and returns the result\n
     * \n
     * Parameters: \n
     * href  - {String} url to be fetched\n
     * \n
     */\n
    fetchLink: function(href) {\n
        var request = OpenLayers.Request.GET({url: href, async: false});\n
        if (request) {\n
            return request.responseText;\n
        }\n
    },\n
\n
    /**\n
     * Method: parseStyles\n
     * Looks for <Style> nodes in the data and parses them\n
     * Also parses <StyleMap> nodes, but only uses the \'normal\' key\n
     * \n
     * Parameters: \n
     * nodes    - {Array} of {DOMElement} data to read/parse.\n
     * options  - {Object} Hash of options\n
     * \n
     */\n
    parseStyles: function(nodes, options) {\n
        for(var i=0, len=nodes.length; i<len; i++) {\n
            var style = this.parseStyle(nodes[i]);\n
            if(style) {\n
                var styleName = (options.styleBaseUrl || "") + "#" + style.id;\n
                \n
                this.styles[styleName] = style;\n
            }\n
        }\n
    },\n
\n
    /**\n
     * Method: parseKmlColor\n
     * Parses a kml color (in \'aabbggrr\' format) and returns the corresponding \n
     * color and opacity or null if the color is invalid.\n
     *\n
     * Parameters: \n
     * kmlColor - {String} a kml formated color\n
     *\n
     * Returns:\n
     * {Object}\n
     */\n
    parseKmlColor: function(kmlColor) {\n
        var color = null;\n
        if (kmlColor) {\n
            var matches = kmlColor.match(this.regExes.kmlColor);\n
            if (matches) {\n
                color = {\n
                    color: \'#\' + matches[4] + matches[3] + matches[2],\n
                    opacity: parseInt(matches[1], 16) / 255\n
                };\n
            }\n
        }\n
        return color;\n
    },\n
\n
    /**\n
     * Method: parseStyle\n
     * Parses the children of a <Style> node and builds the style hash\n
     * accordingly\n
     * \n
     * Parameters: \n
     * node - {DOMElement} <Style> node\n
     * \n
     */\n
    parseStyle: function(node) {\n
        var style = {};\n
        \n
        var types = ["LineStyle", "PolyStyle", "IconStyle", "BalloonStyle", \n
                     "LabelStyle"];\n
        var type, styleTypeNode, nodeList, geometry, parser;\n
        for(var i=0, len=types.length; i<len; ++i) {\n
            type = types[i];\n
            styleTypeNode = this.getElementsByTagNameNS(node, "*", type)[0];\n
            if(!styleTypeNode) { \n
                continue;\n
            }\n
\n
            // only deal with first geometry of this type\n
            switch (type.toLowerCase()) {\n
                case "linestyle":\n
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");\n
                    var color = this.parseKmlColor(kmlColor);\n
                    if (color) {\n
                        style["strokeColor"] = color.color;\n
                        style["strokeOpacity"] = color.opacity;\n
                    }\n
                    \n
                    var width = this.parseProperty(styleTypeNode, "*", "width");\n
                    if (width) {\n
                        style["strokeWidth"] = width;\n
                    }\n
                    break;\n
\n
                case "polystyle":\n
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");\n
                    var color = this.parseKmlColor(kmlColor);\n
                    if (color) {\n
                        style["fillOpacity"] = color.opacity;\n
                        style["fillColor"] = color.color;\n
                    }\n
                    // Check if fill is disabled\n
                    var fill = this.parseProperty(styleTypeNode, "*", "fill");\n
                    if (fill == "0") {\n
                        style["fillColor"] = "none";\n
                    }\n
                    // Check if outline is disabled\n
                    var outline = this.parseProperty(styleTypeNode, "*", "outline");\n
                    if (outline == "0") {\n
                        style["strokeWidth"] = "0";\n
                    }\n
                   \n
                    break;\n
\n
                case "iconstyle":\n
                    // set scale\n
                    var scale = parseFloat(this.parseProperty(styleTypeNode, \n
                                                          "*", "scale") || 1);\n
  \n
                    // set default width and height of icon\n
                    var width = 32 * scale;\n
                    var height = 32 * scale;\n
\n
                    var iconNode = this.getElementsByTagNameNS(styleTypeNode, \n
                                               "*", \n
                                               "Icon")[0];\n
                    if (iconNode) {\n
                        var href = this.parseProperty(iconNode, "*", "href");\n
                        if (href) {                                                   \n
\n
                            var w = this.parseProperty(iconNode, "*", "w");\n
                            var h = this.parseProperty(iconNode, "*", "h");\n
\n
                            // Settings for Google specific icons that are 64x64\n
                            // We set the width and height to 64 and halve the\n
                            // scale to prevent icons from being too big\n
                            var google = "http://maps.google.com/mapfiles/kml";\n
                            if (OpenLayers.String.startsWith(\n
                                                 href, google) && !w && !h) {\n
                                w = 64;\n
                                h = 64;\n
                                scale = scale / 2;\n
                            }\n
                                \n
                            // if only dimension is defined, make sure the\n
                            // other one has the same value\n
                            w = w || h;\n
                            h = h || w;\n
\n
                            if (w) {\n
                                width = parseInt(w) * scale;\n
                            }\n
\n
                            if (h) {\n
                                height = parseInt(h) * scale;\n
                            }\n
\n
                            // support for internal icons \n
                            //    (/root://icons/palette-x.png)\n
                            // x and y tell the position on the palette:\n
                            // - in pixels\n
                            // - starting from the left bottom\n
                            // We translate that to a position in the list \n
                            // and request the appropriate icon from the \n
                            // google maps website\n
                            var matches = href.match(this.regExes.kmlIconPalette);\n
                            if (matches)  {\n
                                var palette = matches[1];\n
                                var file_extension = matches[2];\n
\n
                                var x = this.parseProperty(iconNode, "*", "x");\n
                                var y = this.parseProperty(iconNode, "*", "y");\n
\n
                                var posX = x ? x/32 : 0;\n
                                var posY = y ? (7 - y/32) : 7;\n
\n
                                var pos = posY * 8 + posX;\n
                                href = "http://maps.google.com/mapfiles/kml/pal" \n
                                     + palette + "/icon" + pos + file_extension;\n
                            }\n
\n
                            style["graphicOpacity"] = 1; // fully opaque\n
                            style["externalGraphic"] = href;\n
                        }\n
\n
                    }\n
\n
\n
                    // hotSpots define the offset for an Icon\n
                    var hotSpotNode = this.getElementsByTagNameNS(styleTypeNode, \n
                                               "*", \n
                                               "hotSpot")[0];\n
                    if (hotSpotNode) {\n
                        var x = parseFloat(hotSpotNode.getAttribute("x"));\n
                        var y = parseFloat(hotSpotNode.getAttribute("y"));\n
\n
                        var xUnits = hotSpotNode.getAttribute("xunits");\n
                        if (xUnits == "pixels") {\n
                            style["graphicXOffset"] = -x * scale;\n
                        }\n
                        else if (xUnits == "insetPixels") {\n
                            style["graphicXOffset"] = -width + (x * scale);\n
                        }\n
                        else if (xUnits == "fraction") {\n
                            style["graphicXOffset"] = -width * x;\n
                        }\n
\n
                        var yUnits = hotSpotNode.getAttribute("yunits");\n
                        if (yUnits == "pixels") {\n
                            style["graphicYOffset"] = -height + (y * scale) + 1;\n
                        }\n
                        else if (yUnits == "insetPixels") {\n
                            style["graphicYOffset"] = -(y * scale) + 1;\n
                        }\n
                        else if (yUnits == "fraction") {\n
                            style["graphicYOffset"] =  -height * (1 - y) + 1;\n
                        }\n
                    }\n
\n
                    style["graphicWidth"] = width;\n
                    style["graphicHeight"] = height;\n
                    break;\n
\n
                case "balloonstyle":\n
                    var balloonStyle = OpenLayers.Util.getXmlNodeValue(\n
                                            styleTypeNode);\n
                    if (balloonStyle) {\n
                        style["balloonStyle"] = balloonStyle.replace(\n
                                       this.regExes.straightBracket, "${$1}");\n
                    }\n
                    break;\n
                case "labelstyle":\n
                    var kmlColor = this.parseProperty(styleTypeNode, "*", "color");\n
                    var color = this.parseKmlColor(kmlColor);\n
                    if (color) {\n
                        style["fontColor"] = color.color;\n
                        style["fontOpacity"] = color.opacity;\n
                    }\n
                    break;\n
\n
                default:\n
            }\n
        }\n
\n
        // Some polygons have no line color, so we use the fillColor for that\n
        if (!style["strokeColor"] && style["fillColor"]) {\n
            style["strokeColor"] = style["fillColor"];\n
        }\n
\n
        var id = node.getAttribute("id");\n
        if (id && style) {\n
            style.id = id;\n
        }\n
\n
        return style;\n
    },\n
\n
    /**\n
     * Method: parseStyleMaps\n
     * Looks for <Style> nodes in the data and parses them\n
     * Also parses <StyleMap> nodes, but only uses the \'normal\' key\n
     * \n
     * Parameters: \n
     * nodes    - {Array} of {DOMElement} data to read/parse.\n
     * options  - {Object} Hash of options\n
     * \n
     */\n
    parseStyleMaps: function(nodes, options) {\n
        // Only the default or "normal" part of the StyleMap is processed now\n
        // To do the select or "highlight" bit, we\'d need to change lots more\n
\n
        for(var i=0, len=nodes.length; i<len; i++) {\n
            var node = nodes[i];\n
            var pairs = this.getElementsByTagNameNS(node, "*", \n
                            "Pair");\n
\n
            var id = node.getAttribute("id");\n
            for (var j=0, jlen=pairs.length; j<jlen; j++) {\n
                var pair = pairs[j];\n
                // Use the shortcut in the SLD format to quickly retrieve the \n
                // value of a node. Maybe it\'s good to have a method in \n
                // Format.XML to do this\n
                var key = this.parseProperty(pair, "*", "key");\n
                var styleUrl = this.parseProperty(pair, "*", "styleUrl");\n
\n
                if (styleUrl && key == "normal") {\n
                    this.styles[(options.styleBaseUrl || "") + "#" + id] =\n
                        this.styles[(options.styleBaseUrl || "") + styleUrl];\n
                }\n
\n
                // TODO: implement the "select" part\n
                //if (styleUrl && key == "highlight") {\n
                //}\n
\n
            }\n
        }\n
\n
    },\n
\n
\n
    /**\n
     * Method: parseFeatures\n
     * Loop through all Placemark nodes and parse them.\n
     * Will create a list of features\n
     * \n
     * Parameters: \n
     * nodes    - {Array} of {DOMElement} data to read/parse.\n
     * options  - {Object} Hash of options\n
     * \n
     */\n
    parseFeatures: function(nodes, options) {\n
        var features = [];\n
        for(var i=0, len=nodes.length; i<len; i++) {\n
            var featureNode = nodes[i];\n
            var feature = this.parseFeature.apply(this,[featureNode]) ;\n
            if(feature) {\n
\n
                // Create reference to styleUrl \n
                if (this.extractStyles && feature.attributes &&\n
                    feature.attributes.styleUrl) {\n
                    feature.style = this.getStyle(feature.attributes.styleUrl, options);\n
                }\n
\n
                if (this.extractStyles) {\n
                    // Make sure that <Style> nodes within a placemark are \n
                    // processed as well\n
                    var inlineStyleNode = this.getElementsByTagNameNS(featureNode,\n
                                                        "*",\n
                                                        "Style")[0];\n
                    if (inlineStyleNode) {\n
                        var inlineStyle= this.parseStyle(inlineStyleNode);\n
                        if (inlineStyle) {\n
                            feature.style = OpenLayers.Util.extend(\n
                                feature.style, inlineStyle\n
                            );\n
                        }\n
                    }\n
                }\n
\n
                // check if gx:Track elements should be parsed\n
                if (this.extractTracks) {\n
                    var tracks = this.getElementsByTagNameNS(\n
                        featureNode, this.namespaces.gx, "Track"\n
                    );\n
                    if (tracks && tracks.length > 0) {\n
                        var track = tracks[0];\n
                        var container = {\n
                            features: [],\n
                            feature: feature\n
                        };\n
                        this.readNode(track, container);\n
                        if (container.features.length > 0) {\n
                            features.push.apply(features, container.features);\n
                        }\n
                    }\n
                } else {\n
                    // add feature to list of features\n
                    features.push(feature);                    \n
                }\n
            } else {\n
                throw "Bad Placemark: " + i;\n
            }\n
        }\n
\n
        // add new features to existing feature list\n
        this.features = this.features.concat(features);\n
    },\n
    \n
    /**\n
     * Property: readers\n
     * Contains public functions, grouped by namespace prefix, that will\n
     *     be applied when a namespaced node is found matching the function\n
     *     name.  The function will be applied in the scope of this parser\n
     *     with two arguments: the node being read and a context object passed\n
     *     from the parent.\n
     */\n
    readers: {\n
        "kml": {\n
            "when": function(node, container) {\n
                container.whens.push(OpenLayers.Date.parse(\n
                    this.getChildValue(node)\n
                ));\n
            },\n
            "_trackPointAttribute": function(node, container) {\n
                var name = node.nodeName.split(":").pop();\n
                container.attributes[name].push(this.getChildValue(node));\n
            }\n
        },\n
        "gx": {\n
            "Track": function(node, container) {\n
                var obj = {\n
                    whens: [],\n
                    points: [],\n
                    angles: []\n
                };\n
                if (this.trackAttributes) {\n
                    var name;\n
                    obj.attributes = {};\n
                    for (var i=0, ii=this.trackAttributes.length; i<ii; ++i) {\n
                        name = this.trackAttributes[i];\n
                        obj.attributes[name] = [];\n
                        if (!(name in this.readers.kml)) {\n
                            this.readers.kml[name] = this.readers.kml._trackPointAttribute;\n
                        }\n
                    }\n
                }\n
                this.readChildNodes(node, obj);\n
                if (obj.whens.length !== obj.points.length) {\n
                    throw new Error("gx:Track with unequal number of when (" +\n
                                    obj.whens.length + ") and gx:coord (" +\n
                                    obj.points.length + ") elements.");\n
                }\n
                var hasAngles = obj.angles.length > 0;\n
                if (hasAngles && obj.whens.length !== obj.angles.length) {\n
                    throw new Error("gx:Track with unequal number of when (" +\n
                                    obj.whens.length + ") and gx:angles (" +\n
                                    obj.angles.length + ") elements.");\n
                }\n
                var feature, point, angles;\n
                for (var i=0, ii=obj.whens.length; i<ii; ++i) {\n
                    feature = container.feature.clone();\n
                    feature.fid = container.feature.fid || container.feature.id;\n
                    point = obj.points[i];\n
                    feature.geometry = point;\n
                    if ("z" in point) {\n
                        feature.attributes.altitude = point.z;\n
                    }\n
                    if (this.internalProjection && this.externalProjection) {\n
                        feature.geometry.transform(\n
                            this.externalProjection, this.internalProjection\n
                        ); \n
                    }\n
                    if (this.trackAttributes) {\n
                        for (var j=0, jj=this.trackAttributes.length; j<jj; ++j) {\n
                            feature.attributes[name] = obj.attributes[this.trackAttributes[j]][i];\n
                        }\n
                    }\n
                    feature.attributes.when = obj.whens[i];\n
                    feature.attributes.trackId = container.feature.id;\n
                    if (hasAngles) {\n
                        angles = obj.angles[i];\n
                        feature.attributes.heading = parseFloat(angles[0]);\n
                        feature.attributes.tilt = parseFloat(angles[1]);\n
                        feature.attributes.roll = parseFloat(angles[2]);\n
                    }\n
                    container.features.push(feature);\n
                }\n
            },\n
            "coord": function(node, container) {\n
                var str = this.getChildValue(node);\n
                var coords = str.replace(this.regExes.trimSpace, "").split(/\\s+/);\n
                var point = new OpenLayers.Geometry.Point(coords[0], coords[1]);\n
                if (coords.length > 2) {\n
                    point.z = parseFloat(coords[2]);\n
                }\n
                container.points.push(point);\n
            },\n
            "angles": function(node, container) {\n
                var str = this.getChildValue(node);\n
                var parts = str.replace(this.regExes.trimSpace, "").split(/\\s+/);\n
                container.angles.push(parts);\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: parseFeature\n
     * This function is the core of the KML parsing code in OpenLayers.\n
     *     It creates the geometries that are then attached to the returned\n
     *     feature, and calls parseAttributes() to get attribute data out.\n
     *\n
     * Parameters:\n
     * node - {DOMElement}\n
     *\n
     * Returns:\n
     * {<OpenLayers.Feature.Vector>} A vector feature.\n
     */\n
    parseFeature: function(node) {\n
        // only accept one geometry per feature - look for highest "order"\n
        var order = ["MultiGeometry", "Polygon", "LineString", "Point"];\n
        var type, nodeList, geometry, parser;\n
        for(var i=0, len=order.length; i<len; ++i) {\n
            type = order[i];\n
            this.internalns = node.namespaceURI ? \n
                    node.namespaceURI : this.kmlns;\n
            nodeList = this.getElementsByTagNameNS(node, \n
                                                   this.internalns, type);\n
            if(nodeList.length > 0) {\n
                // only deal with first geometry of this type\n
                var parser = this.parseGeometry[type.toLowerCase()];\n
                if(parser) {\n
                    geometry = parser.apply(this, [nodeList[0]]);\n
                    if (this.internalProjection && this.externalProjection) {\n
                        geometry.transform(this.externalProjection, \n
                                           this.internalProjection); \n
                    }                       \n
                } else {\n
                    throw new TypeError("Unsupported geometry type: " + type);\n
                }\n
                // stop looking for different geometry types\n
                break;\n
            }\n
        }\n
\n
        // construct feature (optionally with attributes)\n
        var attributes;\n
        if(this.extractAttributes) {\n
            attributes = this.parseAttributes(node);\n
        }\n
        var feature = new OpenLayers.Feature.Vector(geometry, attributes);\n
\n
        var fid = node.getAttribute("id") || node.getAttribute("name");\n
        if(fid != null) {\n
            feature.fid = fid;\n
        }\n
\n
        return feature;\n
    },        \n
    \n
    /**\n
     * Method: getStyle\n
     * Retrieves a style from a style hash using styleUrl as the key\n
     * If the styleUrl doesn\'t exist yet, we try to fetch it \n
     * Internet\n
     * \n
     * Parameters: \n
     * styleUrl  - {String} URL of style\n
     * options   - {Object} Hash of options \n
     *\n
     * Returns:\n
     * {Object}  - (reference to) Style hash\n
     */\n
    getStyle: function(styleUrl, options) {\n
\n
        var styleBaseUrl = OpenLayers.Util.removeTail(styleUrl);\n
\n
        var newOptions = OpenLayers.Util.extend({}, options);\n
        newOptions.depth++;\n
        newOptions.styleBaseUrl = styleBaseUrl;\n
\n
        // Fetch remote Style URLs (if not fetched before) \n
        if (!this.styles[styleUrl] \n
                && !OpenLayers.String.startsWith(styleUrl, "#") \n
                && newOptions.depth <= this.maxDepth\n
                && !this.fetched[styleBaseUrl] ) {\n
\n
            var data = this.fetchLink(styleBaseUrl);\n
            if (data) {\n
                this.parseData(data, newOptions);\n
            }\n
\n
        }\n
\n
        // return requested style\n
        var style = OpenLayers.Util.extend({}, this.styles[styleUrl]);\n
        return style;\n
    },\n
    \n
    /**\n
     * Property: parseGeometry\n
     * Properties of this object are the functions that parse geometries based\n
     *     on their type.\n
     */\n
    parseGeometry: {\n
        \n
        /**\n
         * Method: parseGeometry.point\n
         * Given a KML node representing a point geometry, create an OpenLayers\n
         *     point geometry.\n
         *\n
         * Parameters:\n
         * node - {DOMElement} A KML Point node.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry.Point>} A point geometry.\n
         */\n
        point: function(node) {\n
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,\n
                                                       "coordinates");\n
            var coords = [];\n
            if(nodeList.length > 0) {\n
                var coordString = nodeList[0].firstChild.nodeValue;\n
                coordString = coordString.replace(this.regExes.removeSpace, "");\n
                coords = coordString.split(",");\n
            }\n
\n
            var point = null;\n
            if(coords.length > 1) {\n
                // preserve third dimension\n
                if(coords.length == 2) {\n
                    coords[2] = null;\n
                }\n
                point = new OpenLayers.Geometry.Point(coords[0], coords[1],\n
                                                      coords[2]);\n
            } else {\n
                throw "Bad coordinate string: " + coordString;\n
            }\n
            return point;\n
        },\n
        \n
        /**\n
         * Method: parseGeometry.linestring\n
         * Given a KML node representing a linestring geometry, create an\n
         *     OpenLayers linestring geometry.\n
         *\n
         * Parameters:\n
         * node - {DOMElement} A KML LineString node.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry.LineString>} A linestring geometry.\n
         */\n
        linestring: function(node, ring) {\n
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,\n
                                                       "coordinates");\n
            var line = null;\n
            if(nodeList.length > 0) {\n
                var coordString = this.getChildValue(nodeList[0]);\n
\n
                coordString = coordString.replace(this.regExes.trimSpace,\n
                                                  "");\n
                coordString = coordString.replace(this.regExes.trimComma,\n
                                                  ",");\n
                var pointList = coordString.split(this.regExes.splitSpace);\n
                var numPoints = pointList.length;\n
                var points = new Array(numPoints);\n
                var coords, numCoords;\n
                for(var i=0; i<numPoints; ++i) {\n
                    coords = pointList[i].split(",");\n
                    numCoords = coords.length;\n
                    if(numCoords > 1) {\n
                        if(coords.length == 2) {\n
                            coords[2] = null;\n
                        }\n
                        points[i] = new OpenLayers.Geometry.Point(coords[0],\n
                                                                  coords[1],\n
                                                                  coords[2]);\n
                    } else {\n
                        throw "Bad LineString point coordinates: " +\n
                              pointList[i];\n
                    }\n
                }\n
                if(numPoints) {\n
                    if(ring) {\n
                        line = new OpenLayers.Geometry.LinearRing(points);\n
                    } else {\n
                        line = new OpenLayers.Geometry.LineString(points);\n
                    }\n
                } else {\n
                    throw "Bad LineString coordinates: " + coordString;\n
                }\n
            }\n
\n
            return line;\n
        },\n
        \n
        /**\n
         * Method: parseGeometry.polygon\n
         * Given a KML node representing a polygon geometry, create an\n
         *     OpenLayers polygon geometry.\n
         *\n
         * Parameters:\n
         * node - {DOMElement} A KML Polygon node.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry.Polygon>} A polygon geometry.\n
         */\n
        polygon: function(node) {\n
            var nodeList = this.getElementsByTagNameNS(node, this.internalns,\n
                                                       "LinearRing");\n
            var numRings = nodeList.length;\n
            var components = new Array(numRings);\n
            if(numRings > 0) {\n
                // this assumes exterior ring first, inner rings after\n
                var ring;\n
                for(var i=0, len=nodeList.length; i<len; ++i) {\n
                    ring = this.parseGeometry.linestring.apply(this,\n
                                                        [nodeList[i], true]);\n
                    if(ring) {\n
                        components[i] = ring;\n
                    } else {\n
                        throw "Bad LinearRing geometry: " + i;\n
                    }\n
                }\n
            }\n
            return new OpenLayers.Geometry.Polygon(components);\n
        },\n
        \n
        /**\n
         * Method: parseGeometry.multigeometry\n
         * Given a KML node representing a multigeometry, create an\n
         *     OpenLayers geometry collection.\n
         *\n
         * Parameters:\n
         * node - {DOMElement} A KML MultiGeometry node.\n
         *\n
         * Returns:\n
         * {<OpenLayers.Geometry.Collection>} A geometry collection.\n
         */\n
        multigeometry: function(node) {\n
            var child, parser;\n
            var parts = [];\n
            var children = node.childNodes;\n
            for(var i=0, len=children.length; i<len; ++i ) {\n
                child = children[i];\n
                if(child.nodeType == 1) {\n
                    var type = (child.prefix) ?\n
                            child.nodeName.split(":")[1] :\n
                            child.nodeName;\n
                    var parser = this.parseGeometry[type.toLowerCase()];\n
                    if(parser) {\n
                        parts.push(parser.apply(this, [child]));\n
                    }\n
                }\n
            }\n
            return new OpenLayers.Geometry.Collection(parts);\n
        }\n
        \n
    },\n
\n
    /**\n
     * Method: parseAttributes\n
     *\n
     * Parameters:\n
     * node - {DOMElement}\n
     *\n
     * Returns:\n
     * {Object} An attributes object.\n
     */\n
    parseAttributes: function(node) {\n
        var attributes = {};\n
       \n
        // Extended Data is parsed first.\n
        var edNodes = node.getElementsByTagName("ExtendedData");\n
        if (edNodes.length) {\n
            attributes = this.parseExtendedData(edNodes[0]);\n
        }\n
        \n
        // assume attribute nodes are type 1 children with a type 3 or 4 child\n
        var child, grandchildren, grandchild;\n
        var children = node.childNodes;\n
\n
        for(var i=0, len=children.length; i<len; ++i) {\n
            child = children[i];\n
            if(child.nodeType == 1) {\n
                grandchildren = child.childNodes;\n
                if(grandchildren.length >= 1 && grandchildren.length <= 3) {\n
                    var grandchild;\n
                    switch (grandchildren.length) {\n
                        case 1:\n
                            grandchild = grandchildren[0];\n
                            break;\n
                        case 2:\n
                            var c1 = grandchildren[0];\n
                            var c2 = grandchildren[1];\n
                            grandchild = (c1.nodeType == 3 || c1.nodeType == 4) ?\n
                                c1 : c2;\n
                            break;\n
                        case 3:\n
                        default:\n
                            grandchild = grandchildren[1];\n
                            break;\n
                    }\n
                    if(grandchild.nodeType == 3 || grandchild.nodeType == 4) {\n
                        var name = (child.prefix) ?\n
                                child.nodeName.split(":")[1] :\n
                                child.nodeName;\n
                        var value = OpenLayers.Util.getXmlNodeValue(grandchild);\n
                        if (value) {\n
                            value = value.replace(this.regExes.trimSpace, "");\n
                            attributes[name] = value;\n
                        }\n
                    }\n
                } \n
            }\n
        }\n
        return attributes;\n
    },\n
\n
    /**\n
     * Method: parseExtendedData\n
     * Parse ExtendedData from KML. Limited support for schemas/datatypes.\n
     *     See http://code.google.com/apis/kml/documentation/kmlreference.html#extendeddata\n
     *     for more information on extendeddata.\n
     */\n
    parseExtendedData: function(node) {\n
        var attributes = {};\n
        var i, len, data, key;\n
        var dataNodes = node.getElementsByTagName("Data");\n
        for (i = 0, len = dataNodes.length; i < len; i++) {\n
            data = dataNodes[i];\n
            key = data.getAttribute("name");\n
            var ed = {};\n
            var valueNode = data.getElementsByTagName("value");\n
            if (valueNode.length) {\n
                ed[\'value\'] = this.getChildValue(valueNode[0]);\n
            }\n
            if (this.kvpAttributes) {\n
                attributes[key] = ed[\'value\'];\n
            } else {\n
                var nameNode = data.getElementsByTagName("displayName");\n
                if (nameNode.length) {\n
                    ed[\'displayName\'] = this.getChildValue(nameNode[0]);\n
                }\n
                attributes[key] = ed;\n
            } \n
        }\n
        var simpleDataNodes = node.getElementsByTagName("SimpleData");\n
        for (i = 0, len = simpleDataNodes.length; i < len; i++) {\n
            var ed = {};\n
            data = simpleDataNodes[i];\n
            key = data.getAttribute("name");\n
            ed[\'value\'] = this.getChildValue(data);\n
            if (this.kvpAttributes) {\n
                attributes[key] = ed[\'value\'];\n
            } else {\n
                ed[\'displayName\'] = key;\n
                attributes[key] = ed;\n
            }\n
        }\n
        \n
        return attributes;    \n
    },\n
    \n
    /**\n
     * Method: parseProperty\n
     * Convenience method to find a node and return its value\n
     *\n
     * Parameters:\n
     * xmlNode    - {<DOMElement>}\n
     * namespace  - {String} namespace of the node to find\n
     * tagName    - {String} name of the property to parse\n
     * \n
     * Returns:\n
     * {String} The value for the requested property (defaults to null)\n
     */    \n
    parseProperty: function(xmlNode, namespace, tagName) {\n
        var value;\n
        var nodeList = this.getElementsByTagNameNS(xmlNode, namespace, tagName);\n
        try {\n
            value = OpenLayers.Util.getXmlNodeValue(nodeList[0]);\n
        } catch(e) {\n
            value = null;\n
        }\n
     \n
        return value;\n
    },                                                              \n
\n
    /**\n
     * APIMethod: write\n
     * Accept Feature Collection, and return a string. \n
     * \n
     * Parameters:\n
     * features - {Array(<OpenLayers.Feature.Vector>)} An array of features.\n
     *\n
     * Returns:\n
     * {String} A KML string.\n
     */\n
    write: function(features) {\n
        if(!(OpenLayers.Util.isArray(features))) {\n
            features = [features];\n
        }\n
        var kml = this.createElementNS(this.kmlns, "kml");\n
        var folder = this.createFolderXML();\n
        for(var i=0, len=features.length; i<len; ++i) {\n
            folder.appendChild(this.createPlacemarkXML(features[i]));\n
        }\n
        kml.appendChild(folder);\n
        return OpenLayers.Format.XML.prototype.write.apply(this, [kml]);\n
    },\n
\n
    /**\n
     * Method: createFolderXML\n
     * Creates and returns a KML folder node\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    createFolderXML: function() {\n
        // Folder\n
        var folder = this.createElementNS(this.kmlns, "Folder");\n
\n
        // Folder name\n
        if (this.foldersName) {\n
            var folderName = this.createElementNS(this.kmlns, "name");\n
            var folderNameText = this.createTextNode(this.foldersName); \n
            folderName.appendChild(folderNameText);\n
            folder.appendChild(folderName);\n
        }\n
\n
        // Folder description\n
        if (this.foldersDesc) {\n
            var folderDesc = this.createElementNS(this.kmlns, "description");        \n
            var folderDescText = this.createTextNode(this.foldersDesc); \n
            folderDesc.appendChild(folderDescText);\n
            folder.appendChild(folderDesc);\n
        }\n
\n
        return folder;\n
    },\n
\n
    /**\n
     * Method: createPlacemarkXML\n
     * Creates and returns a KML placemark node representing the given feature. \n
     * \n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>}\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    createPlacemarkXML: function(feature) {        \n
        // Placemark name\n
        var placemarkName = this.createElementNS(this.kmlns, "name");\n
        var name = feature.style && feature.style.label ? feature.style.label :\n
                   feature.attributes.name || feature.id;\n
        placemarkName.appendChild(this.createTextNode(name));\n
\n
        // Placemark description\n
        var placemarkDesc = this.createElementNS(this.kmlns, "description");\n
        var desc = feature.attributes.description || this.placemarksDesc;\n
        placemarkDesc.appendChild(this.createTextNode(desc));\n
        \n
        // Placemark\n
        var placemarkNode = this.createElementNS(this.kmlns, "Placemark");\n
        if(feature.fid != null) {\n
            placemarkNode.setAttribute("id", feature.fid);\n
        }\n
        placemarkNode.appendChild(placemarkName);\n
        placemarkNode.appendChild(placemarkDesc);\n
\n
        // Geometry node (Point, LineString, etc. nodes)\n
        var geometryNode = this.buildGeometryNode(feature.geometry);\n
        placemarkNode.appendChild(geometryNode);        \n
        \n
        // output attributes as extendedData\n
        if (feature.attributes) {\n
            var edNode = this.buildExtendedData(feature.attributes);\n
            if (edNode) {\n
                placemarkNode.appendChild(edNode);\n
            }\n
        }\n
        \n
        return placemarkNode;\n
    },    \n
\n
    /**\n
     * Method: buildGeometryNode\n
     * Builds and returns a KML geometry node with the given geometry.\n
     * \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    buildGeometryNode: function(geometry) {\n
        var className = geometry.CLASS_NAME;\n
        var type = className.substring(className.lastIndexOf(".") + 1);\n
        var builder = this.buildGeometry[type.toLowerCase()];\n
        var node = null;\n
        if(builder) {\n
            node = builder.apply(this, [geometry]);\n
        }\n
        return node;\n
    },\n
\n
    /**\n
     * Property: buildGeometry\n
     * Object containing methods to do the actual geometry node building\n
     *     based on geometry type.\n
     */\n
    buildGeometry: {\n
        // TBD: Anybody care about namespace aliases here (these nodes have\n
        //    no prefixes)?\n
\n
        /**\n
         * Method: buildGeometry.point\n
         * Given an OpenLayers point geometry, create a KML point.\n
         *\n
         * Parameters:\n
         * geometry - {<OpenLayers.Geometry.Point>} A point geometry.\n
         *\n
         * Returns:\n
         * {DOMElement} A KML point node.\n
         */\n
        point: function(geometry) {\n
            var kml = this.createElementNS(this.kmlns, "Point");\n
            kml.appendChild(this.buildCoordinatesNode(geometry));\n
            return kml;\n
        },\n
        \n
        /**\n
         * Method: buildGeometry.multipoint\n
         * Given an OpenLayers multipoint geometry, create a KML\n
         *     GeometryCollection.\n
         *\n
         * Parameters:\n
         * geometry - {<OpenLayers.Geometry.Point>} A multipoint geometry.\n
         *\n
         * Returns:\n
         * {DOMElement} A KML GeometryCollection node.\n
         */\n
        multipoint: function(geometry) {\n
            return this.buildGeometry.collection.apply(this, [geometry]);\n
        },\n
\n
        /**\n
         * Method: buildGeometry.linestring\n
         * Given an OpenLayers linestring geometry, create a KML linestring.\n
         *\n
         * Parameters:\n
         * geometry - {<OpenLayers.Geometry.LineString>} A linestring geometry.\n
         *\n
         * Returns:\n
         * {DOMElement} A KML linestring node.\n
         */\n
        linestring: function(geometry) {\n
            var kml = this.createElementNS(this.kmlns, "LineString");\n
            kml.appendChild(this.buildCoordinatesNode(geometry));\n
            return kml;\n
        },\n
        \n
        /**\n
         * Method: buildGeometry.multilinestring\n
         * Given an OpenLayers multilinestring geometry, create a KML\n
         *     GeometryCollection.\n
         *\n
         * Parameters:\n
         * geometry - {<OpenLayers.Geometry.Point>} A multilinestring geometry.\n
         *\n
         * Returns:\n
         * {DOMElement} A KML GeometryCollection node.\n
         */\n
        multilinestring: function(geometry) {\n
            return this.buildGeometry.collection.apply(this, [geometry]);\n
        },\n
\n
        /**\n
         * Method: buildGeometry.linearring\n
         * Given an OpenLayers linearring geometry, create a KML linearring.\n
         *\n
         * Parameters:\n
         * geometry - {<OpenLayers.Geometry.LinearRing>} A linearring geometry.\n
         *\n
         * Returns:\n
         * {DOMElement} A KML linearring node.\n
         */\n
        linearring: function(geometry) {\n
            var kml = this.createElementNS(this.kmlns, "LinearRing");\n
            kml.appendChild(this.buildCoordinatesNode(geometry));\n
            return kml;\n
        },\n
        \n
        /**\n
         * Method: buildGeometry.polygon\n
         * Given an OpenLayers polygon geometry, create a KML polygon.\n
         *\n
         * Parameters:\n
         * geometry - {<OpenLayers.Geometry.Polygon>} A polygon geometry.\n
         *\n
         * Returns:\n
         * {DOMElement} A KML polygon node.\n
         */\n
        polygon: function(geometry) {\n
            var kml = this.createElementNS(this.kmlns, "Polygon");\n
            var rings = geometry.components;\n
            var ringMember, ringGeom, type;\n
            for(var i=0, len=rings.length; i<len; ++i) {\n
                type = (i==0) ? "outerBoundaryIs" : "innerBoundaryIs";\n
                ringMember = this.createElementNS(this.kmlns, type);\n
                ringGeom = this.buildGeometry.linearring.apply(this,\n
                                                               [rings[i]]);\n
                ringMember.appendChild(ringGeom);\n
                kml.appendChild(ringMember);\n
            }\n
            return kml;\n
        },\n
        \n
        /**\n
         * Method: buildGeometry.multipolygon\n
         * Given an OpenLayers multipolygon geometry, create a KML\n
         *     GeometryCollection.\n
         *\n
         * Parameters:\n
         * geometry - {<OpenLayers.Geometry.Point>} A multipolygon geometry.\n
         *\n
         * Returns:\n
         * {DOMElement} A KML GeometryCollection node.\n
         */\n
        multipolygon: function(geometry) {\n
            return this.buildGeometry.collection.apply(this, [geometry]);\n
        },\n
\n
        /**\n
         * Method: buildGeometry.collection\n
         * Given an OpenLayers geometry collection, create a KML MultiGeometry.\n
         *\n
         * Parameters:\n
         * geometry - {<OpenLayers.Geometry.Collection>} A geometry collection.\n
         *\n
         * Returns:\n
         * {DOMElement} A KML MultiGeometry node.\n
         */\n
        collection: function(geometry) {\n
            var kml = this.createElementNS(this.kmlns, "MultiGeometry");\n
            var child;\n
            for(var i=0, len=geometry.components.length; i<len; ++i) {\n
                child = this.buildGeometryNode.apply(this,\n
                                                     [geometry.components[i]]);\n
                if(child) {\n
                    kml.appendChild(child);\n
                }\n
            }\n
            return kml;\n
        }\n
    },\n
\n
    /**\n
     * Method: buildCoordinatesNode\n
     * Builds and returns the KML coordinates node with the given geometry\n
     * <coordinates>...</coordinates>\n
     * \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */     \n
    buildCoordinatesNode: function(geometry) {\n
        var coordinatesNode = this.createElementNS(this.kmlns, "coordinates");\n
        \n
        var path;\n
        var points = geometry.components;\n
        if(points) {\n
            // LineString or LinearRing\n
            var point;\n
            var numPoints = points.length;\n
            var parts = new Array(numPoints);\n
            for(var i=0; i<numPoints; ++i) {\n
                point = points[i];\n
                parts[i] = this.buildCoordinates(point);\n
            }\n
            path = parts.join(" ");\n
        } else {\n
            // Point\n
            path = this.buildCoordinates(geometry);\n
        }\n
        \n
        var txtNode = this.createTextNode(path);\n
        coordinatesNode.appendChild(txtNode);\n
        \n
        return coordinatesNode;\n
    },    \n
    \n
    /**\n
     * Method: buildCoordinates\n
     *\n
     * Parameters:\n
     * point - {<OpenLayers.Geometry.Point>}\n
     *\n
     * Returns\n
     * {String} a coordinate pair\n
     */\n
    buildCoordinates: function(point) {\n
        if (this.internalProjection && this.externalProjection) {\n
            point = point.clone();\n
            point.transform(this.internalProjection, \n
                               this.externalProjection);\n
        }\n
        return point.x + "," + point.y;                     \n
    },\n
\n
    /**\n
     * Method: buildExtendedData\n
     *\n
     * Parameters:\n
     * attributes - {Object}\n
     *\n
     * Returns\n
     * {DOMElement} A KML ExtendedData node or {null} if no attributes.\n
     */\n
    buildExtendedData: function(attributes) {\n
        var extendedData = this.createElementNS(this.kmlns, "ExtendedData");\n
        for (var attributeName in attributes) {\n
            // empty, name, description, styleUrl attributes ignored\n
            if (attributes[attributeName] && attributeName != "name" && attributeName != "description" && attributeName != "styleUrl") {\n
                var data = this.createElementNS(this.kmlns, "Data");\n
                data.setAttribute("name", attributeName);\n
                var value = this.createElementNS(this.kmlns, "value");\n
                if (typeof attributes[attributeName] == "object") {\n
                    // cater for object attributes with \'value\' properties\n
                    // other object properties will output an empty node\n
                    if (attributes[attributeName].value) {\n
                        value.appendChild(this.createTextNode(attributes[attributeName].value));\n
                    }\n
                    if (attributes[attributeName].displayName) {\n
                        var displayName = this.createElementNS(this.kmlns, "displayName");\n
                        // displayName always written as CDATA\n
                        displayName.appendChild(this.getXMLDoc().createCDATASection(attributes[attributeName].displayName));\n
                        data.appendChild(displayName);\n
                    }\n
                } else {\n
                    value.appendChild(this.createTextNode(attributes[attributeName]));\n
                }\n
                data.appendChild(value);\n
                extendedData.appendChild(data);\n
            }\n
        }\n
        if (this.isSimpleContent(extendedData)) {\n
            return null;\n
        } else {\n
            return extendedData;\n
        }\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Format.KML" \n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>55468</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
