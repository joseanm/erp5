<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.96</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>v1.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Rule.js\n
 * @requires OpenLayers/Format/SLD.js\n
 * @requires OpenLayers/Format/Filter/v1_0_0.js\n
 * @requires OpenLayers/Symbolizer/Point.js\n
 * @requires OpenLayers/Symbolizer/Line.js\n
 * @requires OpenLayers/Symbolizer/Polygon.js\n
 * @requires OpenLayers/Symbolizer/Text.js\n
 * @requires OpenLayers/Symbolizer/Raster.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Format.SLD.v1\n
 * Superclass for SLD version 1 parsers.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Format.Filter.v1_0_0>\n
 */\n
OpenLayers.Format.SLD.v1 = OpenLayers.Class(OpenLayers.Format.Filter.v1_0_0, {\n
    \n
    /**\n
     * Property: namespaces\n
     * {Object} Mapping of namespace aliases to namespace URIs.\n
     */\n
    namespaces: {\n
        sld: "http://www.opengis.net/sld",\n
        ogc: "http://www.opengis.net/ogc",\n
        gml: "http://www.opengis.net/gml",\n
        xlink: "http://www.w3.org/1999/xlink",\n
        xsi: "http://www.w3.org/2001/XMLSchema-instance"\n
    },\n
    \n
    /**\n
     * Property: defaultPrefix\n
     */\n
    defaultPrefix: "sld",\n
\n
    /**\n
     * Property: schemaLocation\n
     * {String} Schema location for a particular minor version.\n
     */\n
    schemaLocation: null,\n
    \n
    /** \n
     * APIProperty: multipleSymbolizers\n
     * {Boolean} Support multiple symbolizers per rule.  Default is false.  if\n
     *     true, an OpenLayers.Style2 instance will be created to represent \n
     *     user styles instead of an OpenLayers.Style instace.  The \n
     *     OpenLayers.Style2 class allows collections of rules with multiple\n
     *     symbolizers, but is not currently useful for client side rendering.\n
     *     If multiple symbolizers is true, multiple FeatureTypeStyle elements\n
     *     are preserved in reading/writing by setting symbolizer zIndex values.\n
     *     In addition, the <defaultSymbolizer> property is ignored if \n
     *     multiple symbolizers are supported (defaults should be applied\n
     *     when rendering).\n
     */\n
    multipleSymbolizers: false,\n
\n
    /**\n
     * Property: featureTypeCounter\n
     * {Number} Private counter for multiple feature type styles.\n
     */\n
    featureTypeCounter: null,\n
\n
    /**\n
     * APIProperty: defaultSymbolizer.\n
     * {Object} A symbolizer with the SLD defaults.\n
     */\n
    defaultSymbolizer: {\n
        fillColor: "#808080",\n
        fillOpacity: 1,\n
        strokeColor: "#000000",\n
        strokeOpacity: 1,\n
        strokeWidth: 1,\n
        strokeDashstyle: "solid",\n
        pointRadius: 3,\n
        graphicName: "square"\n
    },\n
    \n
    /**\n
     * Constructor: OpenLayers.Format.SLD.v1\n
     * Instances of this class are not created directly.  Use the\n
     *     <OpenLayers.Format.SLD> constructor instead.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     */\n
    \n
    /**\n
     * Method: read\n
     *\n
     * Parameters:\n
     * data - {DOMElement} An SLD document element.\n
     * options - {Object} Options for the reader.\n
     *\n
     * Valid options:\n
     * namedLayersAsArray - {Boolean}  Generate a namedLayers array.  If false,\n
     *     the namedLayers property value will be an object keyed by layer name.\n
     *     Default is false.\n
     *\n
     * Returns:\n
     * {Object} An object representing the SLD.\n
     */\n
    read: function(data, options) {\n
        options = OpenLayers.Util.applyDefaults(options, this.options);\n
        var sld = {\n
            namedLayers: options.namedLayersAsArray === true ? [] : {}\n
        };\n
        this.readChildNodes(data, sld);\n
        return sld;\n
    },\n
    \n
    /**\n
     * Property: readers\n
     * Contains public functions, grouped by namespace prefix, that will\n
     *     be applied when a namespaced node is found matching the function\n
     *     name.  The function will be applied in the scope of this parser\n
     *     with two arguments: the node being read and a context object passed\n
     *     from the parent.\n
     */\n
    readers: OpenLayers.Util.applyDefaults({\n
        "sld": {\n
            "StyledLayerDescriptor": function(node, sld) {\n
                sld.version = node.getAttribute("version");\n
                this.readChildNodes(node, sld);\n
            },\n
            "Name": function(node, obj) {\n
                obj.name = this.getChildValue(node);\n
            },\n
            "Title": function(node, obj) {\n
                obj.title = this.getChildValue(node);\n
            },\n
            "Abstract": function(node, obj) {\n
                obj.description = this.getChildValue(node);\n
            },\n
            "NamedLayer": function(node, sld) {\n
                var layer = {\n
                    userStyles: [],\n
                    namedStyles: []\n
                };\n
                this.readChildNodes(node, layer);\n
                // give each of the user styles this layer name\n
                for(var i=0, len=layer.userStyles.length; i<len; ++i) {\n
                    layer.userStyles[i].layerName = layer.name;\n
                }\n
                if(OpenLayers.Util.isArray(sld.namedLayers)) {\n
                    sld.namedLayers.push(layer);                \n
                } else {\n
                    sld.namedLayers[layer.name] = layer;\n
                }\n
            },\n
            "NamedStyle": function(node, layer) {\n
                layer.namedStyles.push(\n
                    this.getChildName(node.firstChild)\n
                );\n
            },\n
            "UserStyle": function(node, layer) {\n
                var obj = {defaultsPerSymbolizer: true, rules: []};\n
                this.featureTypeCounter = -1;\n
                this.readChildNodes(node, obj);\n
                var style;\n
                if (this.multipleSymbolizers) {\n
                    delete obj.defaultsPerSymbolizer;\n
                    style = new OpenLayers.Style2(obj);\n
                } else {\n
                    style = new OpenLayers.Style(this.defaultSymbolizer, obj);\n
                }\n
                layer.userStyles.push(style);\n
            },\n
            "IsDefault": function(node, style) {\n
                if(this.getChildValue(node) == "1") {\n
                    style.isDefault = true;\n
                }\n
            },\n
            "FeatureTypeStyle": function(node, style) {\n
                ++this.featureTypeCounter;\n
                var obj = {\n
                    rules: this.multipleSymbolizers ? style.rules : []\n
                };\n
                this.readChildNodes(node, obj);\n
                if (!this.multipleSymbolizers) {\n
                    style.rules = obj.rules;\n
                }\n
            },\n
            "Rule": function(node, obj) {\n
                var config;\n
                if (this.multipleSymbolizers) {\n
                    config = {symbolizers: []};\n
                }\n
                var rule = new OpenLayers.Rule(config);\n
                this.readChildNodes(node, rule);\n
                obj.rules.push(rule);\n
            },\n
            "ElseFilter": function(node, rule) {\n
                rule.elseFilter = true;\n
            },\n
            "MinScaleDenominator": function(node, rule) {\n
                rule.minScaleDenominator = parseFloat(this.getChildValue(node));\n
            },\n
            "MaxScaleDenominator": function(node, rule) {\n
                rule.maxScaleDenominator = parseFloat(this.getChildValue(node));\n
            },\n
            "TextSymbolizer": function(node, rule) {\n
                var config = {};\n
                this.readChildNodes(node, config);\n
                if (this.multipleSymbolizers) {\n
                    config.zIndex = this.featureTypeCounter;\n
                    rule.symbolizers.push(\n
                        new OpenLayers.Symbolizer.Text(config)\n
                    );\n
                } else {\n
                    rule.symbolizer["Text"] = OpenLayers.Util.applyDefaults(\n
                        config, rule.symbolizer["Text"]\n
                    );\n
                }\n
            },\n
            "LabelPlacement": function(node, symbolizer) {\n
                this.readChildNodes(node, symbolizer);\n
            },\n
            "PointPlacement": function(node, symbolizer) {\n
                var config = {};\n
                this.readChildNodes(node, config);\n
                config.labelRotation = config.rotation;\n
                delete config.rotation;\n
                var labelAlign,\n
                    x = symbolizer.labelAnchorPointX,\n
                    y = symbolizer.labelAnchorPointY;\n
                if (x <= 1/3) {\n
                    labelAlign = \'l\';\n
                } else if (x > 1/3 && x < 2/3) {\n
                    labelAlign = \'c\';\n
                } else if (x >= 2/3) {\n
                    labelAlign = \'r\';\n
                }\n
                if (y <= 1/3) {\n
                    labelAlign += \'b\';\n
                } else if (y > 1/3 && y < 2/3) {\n
                    labelAlign += \'m\';\n
                } else if (y >= 2/3) {\n
                    labelAlign += \'t\';\n
                }\n
                config.labelAlign = labelAlign;\n
                OpenLayers.Util.applyDefaults(symbolizer, config);\n
            },\n
            "AnchorPoint": function(node, symbolizer) {\n
                this.readChildNodes(node, symbolizer);\n
            },\n
            "AnchorPointX": function(node, symbolizer) {\n
                var labelAnchorPointX = this.readers.ogc._expression.call(this, node);\n
                // always string, could be empty string\n
                if(labelAnchorPointX) {\n
                    symbolizer.labelAnchorPointX = labelAnchorPointX;\n
                }\n
            },\n
            "AnchorPointY": function(node, symbolizer) {\n
                var labelAnchorPointY = this.readers.ogc._expression.call(this, node);\n
                // always string, could be empty string\n
                if(labelAnchorPointY) {\n
                    symbolizer.labelAnchorPointY = labelAnchorPointY;\n
                }\n
            },\n
            "Displacement": function(node, symbolizer) {\n
                this.readChildNodes(node, symbolizer);\n
            },\n
            "DisplacementX": function(node, symbolizer) {\n
                var labelXOffset = this.readers.ogc._expression.call(this, node);\n
                // always string, could be empty string\n
                if(labelXOffset) {\n
                    symbolizer.labelXOffset = labelXOffset;\n
                }\n
            },\n
            "DisplacementY": function(node, symbolizer) {\n
                var labelYOffset = this.readers.ogc._expression.call(this, node);\n
                // always string, could be empty string\n
                if(labelYOffset) {\n
                    symbolizer.labelYOffset = labelYOffset;\n
                }\n
            },\n
            "LinePlacement": function(node, symbolizer) {\n
                this.readChildNodes(node, symbolizer);\n
            },\n
            "PerpendicularOffset": function(node, symbolizer) {\n
                var labelPerpendicularOffset = this.readers.ogc._expression.call(this, node);\n
                // always string, could be empty string\n
                if(labelPerpendicularOffset) {\n
                    symbolizer.labelPerpendicularOffset = labelPerpendicularOffset;\n
                }\n
            },\n
            "Label": function(node, symbolizer) {\n
                var value = this.readers.ogc._expression.call(this, node);\n
                if (value) {\n
                    symbolizer.label = value;\n
                }\n
            },\n
            "Font": function(node, symbolizer) {\n
                this.readChildNodes(node, symbolizer);\n
            },\n
            "Halo": function(node, symbolizer) {\n
                // halo has a fill, so send fresh object\n
                var obj = {};\n
                this.readChildNodes(node, obj);\n
                symbolizer.haloRadius = obj.haloRadius;\n
                symbolizer.haloColor = obj.fillColor;\n
                symbolizer.haloOpacity = obj.fillOpacity;\n
            },\n
            "Radius": function(node, symbolizer) {\n
                var radius = this.readers.ogc._expression.call(this, node);\n
                if(radius != null) {\n
                    // radius is only used for halo\n
                    symbolizer.haloRadius = radius;\n
                }\n
            },\n
            "RasterSymbolizer": function(node, rule) {\n
                var config = {};\n
                this.readChildNodes(node, config);\n
                if (this.multipleSymbolizers) {\n
                    config.zIndex = this.featureTypeCounter;\n
                    rule.symbolizers.push(\n
                        new OpenLayers.Symbolizer.Raster(config)\n
                    );\n
                } else {\n
                    rule.symbolizer["Raster"] = OpenLayers.Util.applyDefaults(\n
                        config, rule.symbolizer["Raster"]\n
                    );\n
                }\n
            },\n
            "Geometry": function(node, obj) {\n
                obj.geometry = {};\n
                this.readChildNodes(node, obj.geometry);\n
            },\n
            "ColorMap": function(node, symbolizer) {\n
                symbolizer.colorMap = [];\n
                this.readChildNodes(node, symbolizer.colorMap);\n
            },\n
            "ColorMapEntry": function(node, colorMap) {\n
                var q = node.getAttribute("quantity");\n
                var o = node.getAttribute("opacity");\n
                colorMap.push({\n
                    color: node.getAttribute("color"),\n
                    quantity: q !== null ? parseFloat(q) : undefined,\n
                    label: node.getAttribute("label") || undefined,\n
                    opacity: o !== null ? parseFloat(o) : undefined\n
                });\n
            },\n
            "LineSymbolizer": function(node, rule) {\n
                var config = {};\n
                this.readChildNodes(node, config);\n
                if (this.multipleSymbolizers) {\n
                    config.zIndex = this.featureTypeCounter;\n
                    rule.symbolizers.push(\n
                        new OpenLayers.Symbolizer.Line(config)\n
                    );\n
                } else {\n
                    rule.symbolizer["Line"] = OpenLayers.Util.applyDefaults(\n
                        config, rule.symbolizer["Line"]\n
                    );\n
                }\n
            },\n
            "PolygonSymbolizer": function(node, rule) {\n
                var config = {\n
                    fill: false,\n
                    stroke: false\n
                };\n
                if (!this.multipleSymbolizers) {\n
                    config = rule.symbolizer["Polygon"] || config;\n
                }\n
                this.readChildNodes(node, config);\n
                if (this.multipleSymbolizers) {\n
                    config.zIndex = this.featureTypeCounter;\n
                    rule.symbolizers.push(\n
                        new OpenLayers.Symbolizer.Polygon(config)\n
                    );\n
                } else {\n
                    rule.symbolizer["Polygon"] = config;\n
                }\n
            },\n
            "PointSymbolizer": function(node, rule) {\n
                var config = {\n
                    fill: false,\n
                    stroke: false,\n
                    graphic: false\n
                };\n
                if (!this.multipleSymbolizers) {\n
                    config = rule.symbolizer["Point"] || config;\n
                }\n
                this.readChildNodes(node, config);\n
                if (this.multipleSymbolizers) {\n
                    config.zIndex = this.featureTypeCounter;\n
                    rule.symbolizers.push(\n
                        new OpenLayers.Symbolizer.Point(config)\n
                    );\n
                } else {\n
                    rule.symbolizer["Point"] = config;\n
                }\n
            },\n
            "Stroke": function(node, symbolizer) {\n
                symbolizer.stroke = true;\n
                this.readChildNodes(node, symbolizer);\n
            },\n
            "Fill": function(node, symbolizer) {\n
                symbolizer.fill = true;\n
                this.readChildNodes(node, symbolizer);\n
            },\n
            "CssParameter": function(node, symbolizer) {\n
                var cssProperty = node.getAttribute("name");\n
                var symProperty = this.cssMap[cssProperty];\n
                // for labels, fill should map to fontColor and fill-opacity \n
                // to fontOpacity\n
                if (symbolizer.label) {\n
                    if (cssProperty === \'fill\') {\n
                        symProperty = "fontColor";\n
                    } else if (cssProperty === \'fill-opacity\') {\n
                        symProperty = "fontOpacity";\n
                    }\n
                }\n
                if(symProperty) {\n
                    // Limited support for parsing of OGC expressions\n
                    var value = this.readers.ogc._expression.call(this, node);\n
                    // always string, could be an empty string\n
                    if(value) {\n
                        symbolizer[symProperty] = value;\n
                    }\n
                }\n
            },\n
            "Graphic": function(node, symbolizer) {\n
                symbolizer.graphic = true;\n
                var graphic = {};\n
                // painter\'s order not respected here, clobber previous with next\n
                this.readChildNodes(node, graphic);\n
                // directly properties with names that match symbolizer properties\n
                var properties = [\n
                    "stroke", "strokeColor", "strokeWidth", "strokeOpacity",\n
                    "strokeLinecap", "fill", "fillColor", "fillOpacity",\n
                    "graphicName", "rotation", "graphicFormat"\n
                ];\n
                var prop, value;\n
                for(var i=0, len=properties.length; i<len; ++i) {\n
                    prop = properties[i];\n
                    value = graphic[prop];\n
                    if(value != undefined) {\n
                        symbolizer[prop] = value;\n
                    }\n
                }\n
                // set other generic properties with specific graphic property names\n
                if(graphic.opacity != undefined) {\n
                    symbolizer.graphicOpacity = graphic.opacity;\n
                }\n
                if(graphic.size != undefined) {\n
                    var pointRadius = graphic.size / 2;\n
                    if (isNaN(pointRadius)) {\n
                        // likely a property name\n
                        symbolizer.graphicWidth = graphic.size;\n
                    } else {\n
                        symbolizer.pointRadius = graphic.size / 2;\n
                    }\n
                }\n
                if(graphic.href != undefined) {\n
                    symbolizer.externalGraphic = graphic.href;\n
                }\n
                if(graphic.rotation != undefined) {\n
                    symbolizer.rotation = graphic.rotation;\n
                }\n
            },\n
            "ExternalGraphic": function(node, graphic) {\n
                this.readChildNodes(node, graphic);\n
            },\n
            "Mark": function(node, graphic) {\n
                this.readChildNodes(node, graphic);\n
            },\n
            "WellKnownName": function(node, graphic) {\n
                graphic.graphicName = this.getChildValue(node);\n
            },\n
            "Opacity": function(node, obj) {\n
                var opacity = this.readers.ogc._expression.call(this, node);\n
                // always string, could be empty string\n
                if(opacity) {\n
                    obj.opacity = opacity;\n
                }\n
            },\n
            "Size": function(node, obj) {\n
                var size = this.readers.ogc._expression.call(this, node);\n
                // always string, could be empty string\n
                if(size) {\n
                    obj.size = size;\n
                }\n
            },\n
            "Rotation": function(node, obj) {\n
                var rotation = this.readers.ogc._expression.call(this, node);\n
                // always string, could be empty string\n
                if(rotation) {\n
                    obj.rotation = rotation;\n
                }\n
            },\n
            "OnlineResource": function(node, obj) {\n
                obj.href = this.getAttributeNS(\n
                    node, this.namespaces.xlink, "href"\n
                );\n
            },\n
            "Format": function(node, graphic) {\n
                graphic.graphicFormat = this.getChildValue(node);\n
            }\n
        }\n
    }, OpenLayers.Format.Filter.v1_0_0.prototype.readers),\n
    \n
    /**\n
     * Property: cssMap\n
     * {Object} Object mapping supported css property names to OpenLayers\n
     *     symbolizer property names.\n
     */\n
    cssMap: {\n
        "stroke": "strokeColor",\n
        "stroke-opacity": "strokeOpacity",\n
        "stroke-width": "strokeWidth",\n
        "stroke-linecap": "strokeLinecap",\n
        "stroke-dasharray": "strokeDashstyle",\n
        "fill": "fillColor",\n
        "fill-opacity": "fillOpacity",\n
        "font-family": "fontFamily",\n
        "font-size": "fontSize",\n
        "font-weight": "fontWeight",\n
        "font-style": "fontStyle"\n
    },\n
    \n
    /**\n
     * Method: getCssProperty\n
     * Given a symbolizer property, get the corresponding CSS property\n
     *     from the <cssMap>.\n
     *\n
     * Parameters:\n
     * sym - {String} A symbolizer property name.\n
     *\n
     * Returns:\n
     * {String} A CSS property name or null if none found.\n
     */\n
    getCssProperty: function(sym) {\n
        var css = null;\n
        for(var prop in this.cssMap) {\n
            if(this.cssMap[prop] == sym) {\n
                css = prop;\n
                break;\n
            }\n
        }\n
        return css;\n
    },\n
    \n
    /**\n
     * Method: getGraphicFormat\n
     * Given a href for an external graphic, try to determine the mime-type.\n
     *     This method doesn\'t try too hard, and will fall back to\n
     *     <defaultGraphicFormat> if one of the known <graphicFormats> is not\n
     *     the file extension of the provided href.\n
     *\n
     * Parameters:\n
     * href - {String}\n
     *\n
     * Returns:\n
     * {String} The graphic format.\n
     */\n
    getGraphicFormat: function(href) {\n
        var format, regex;\n
        for(var key in this.graphicFormats) {\n
            if(this.graphicFormats[key].test(href)) {\n
                format = key;\n
                break;\n
            }\n
        }\n
        return format || this.defaultGraphicFormat;\n
    },\n
    \n
    /**\n
     * Property: defaultGraphicFormat\n
     * {String} If none other can be determined from <getGraphicFormat>, this\n
     *     default will be returned.\n
     */\n
    defaultGraphicFormat: "image/png",\n
    \n
    /**\n
     * Property: graphicFormats\n
     * {Object} Mapping of image mime-types to regular extensions matching \n
     *     well-known file extensions.\n
     */\n
    graphicFormats: {\n
        "image/jpeg": /\\.jpe?g$/i,\n
        "image/gif": /\\.gif$/i,\n
        "image/png": /\\.png$/i\n
    },\n
\n
    /**\n
     * Method: write\n
     *\n
     * Parameters:\n
     * sld - {Object} An object representing the SLD.\n
     *\n
     * Returns:\n
     * {DOMElement} The root of an SLD document.\n
     */\n
    write: function(sld) {\n
        return this.writers.sld.StyledLayerDescriptor.apply(this, [sld]);\n
    },\n
    \n
    /**\n
     * Property: writers\n
     * As a compliment to the readers property, this structure contains public\n
     *     writing functions grouped by namespace alias and named like the\n
     *     node names they produce.\n
     */\n
    writers: OpenLayers.Util.applyDefaults({\n
        "sld": {\n
            "_OGCExpression": function(nodeName, value) {\n
                // only the simplest of ogc:expression handled\n
                // {label: "some text and a ${propertyName}"}\n
                var node = this.createElementNSPlus(nodeName);\n
                var tokens = typeof value == "string" ?\n
                    value.split("${") :\n
                    [value];\n
                node.appendChild(this.createTextNode(tokens[0]));\n
                var item, last;\n
                for(var i=1, len=tokens.length; i<len; i++) {\n
                    item = tokens[i];\n
                    last = item.indexOf("}"); \n
                    if(last > 0) {\n
                        this.writeNode(\n
                            "ogc:PropertyName",\n
                            {property: item.substring(0, last)},\n
                            node\n
                        );\n
                        node.appendChild(\n
                            this.createTextNode(item.substring(++last))\n
                        );\n
                    } else {\n
                        // no ending }, so this is a literal ${\n
                        node.appendChild(\n
                            this.createTextNode("${" + item)\n
                        );\n
                    }\n
                }\n
                return node;\n
            },\n
            "StyledLayerDescriptor": function(sld) {\n
                var root = this.createElementNSPlus(\n
                    "sld:StyledLayerDescriptor",\n
                    {attributes: {\n
                        "version": this.VERSION,\n
                        "xsi:schemaLocation": this.schemaLocation\n
                    }}\n
                );\n
\n
                // For ArcGIS Server it is necessary to define this\n
                // at the root level (see ticket:2166).\n
                root.setAttribute("xmlns:ogc", this.namespaces.ogc);\n
                root.setAttribute("xmlns:gml", this.namespaces.gml);\n
\n
                // add in optional name\n
                if(sld.name) {\n
                    this.writeNode("Name", sld.name, root);\n
                }\n
                // add in optional title\n
                if(sld.title) {\n
                    this.writeNode("Title", sld.title, root);\n
                }\n
                // add in optional description\n
                if(sld.description) {\n
                    this.writeNode("Abstract", sld.description, root);\n
                }\n
                // add in named layers\n
                // allow namedLayers to be an array\n
                if(OpenLayers.Util.isArray(sld.namedLayers)) {\n
                    for(var i=0, len=sld.namedLayers.length; i<len; ++i) {\n
                        this.writeNode("NamedLayer", sld.namedLayers[i], root);\n
                    }\n
                } else {\n
                    for(var name in sld.namedLayers) {\n
                        this.writeNode("NamedLayer", sld.namedLayers[name], root);\n
                    }\n
                }\n
                return root;\n
            },\n
            "Name": function(name) {\n
                return this.createElementNSPlus("sld:Name", {value: name});\n
            },\n
            "Title": function(title) {\n
                return this.createElementNSPlus("sld:Title", {value: title});\n
            },\n
            "Abstract": function(description) {\n
                return this.createElementNSPlus(\n
                    "sld:Abstract", {value: description}\n
                );\n
            },\n
            "NamedLayer": function(layer) {\n
                var node = this.createElementNSPlus("sld:NamedLayer");\n
\n
                // add in required name\n
                this.writeNode("Name", layer.name, node);\n
\n
                // optional sld:LayerFeatureConstraints here\n
\n
                // add in named styles\n
                if(layer.namedStyles) {\n
                    for(var i=0, len=layer.namedStyles.length; i<len; ++i) {\n
                        this.writeNode(\n
                            "NamedStyle", layer.namedStyles[i], node\n
                        );\n
                    }\n
                }\n
                \n
                // add in user styles\n
                if(layer.userStyles) {\n
                    for(var i=0, len=layer.userStyles.length; i<len; ++i) {\n
                        this.writeNode(\n
                            "UserStyle", layer.userStyles[i], node\n
                        );\n
                    }\n
                }\n
                \n
                return node;\n
            },\n
            "NamedStyle": function(name) {\n
                var node = this.createElementNSPlus("sld:NamedStyle");\n
                this.writeNode("Name", name, node);\n
                return node;\n
            },\n
            "UserStyle": function(style) {\n
                var node = this.createElementNSPlus("sld:UserStyle");\n
\n
                // add in optional name\n
                if(style.name) {\n
                    this.writeNode("Name", style.name, node);\n
                }\n
                // add in optional title\n
                if(style.title) {\n
                    this.writeNode("Title", style.title, node);\n
                }\n
                // add in optional description\n
                if(style.description) {\n
                    this.writeNode("Abstract", style.description, node);\n
                }\n
                \n
                // add isdefault\n
                if(style.isDefault) {\n
                    this.writeNode("IsDefault", style.isDefault, node);\n
                }\n
                \n
                // add FeatureTypeStyles\n
                if (this.multipleSymbolizers && style.rules) {\n
                    // group style objects by symbolizer zIndex\n
                    var rulesByZ = {\n
                        0: []\n
                    };\n
                    var zValues = [0];\n
                    var rule, ruleMap, symbolizer, zIndex, clone;\n
                    for (var i=0, ii=style.rules.length; i<ii; ++i) {\n
                        rule = style.rules[i];\n
                        if (rule.symbolizers) {\n
                            ruleMap = {};\n
                            for (var j=0, jj=rule.symbolizers.length; j<jj; ++j) {\n
                                symbolizer = rule.symbolizers[j];\n
                                zIndex = symbolizer.zIndex;\n
                                if (!(zIndex in ruleMap)) {\n
                                    clone = rule.clone();\n
                                    clone.symbolizers = [];\n
                                    ruleMap[zIndex] = clone;\n
                                }\n
                                ruleMap[zIndex].symbolizers.push(symbolizer.clone());\n
                            }\n
                            for (zIndex in ruleMap) {\n
                                if (!(zIndex in rulesByZ)) {\n
                                    zValues.push(zIndex);\n
                                    rulesByZ[zIndex] = [];\n
                                }\n
                                rulesByZ[zIndex].push(ruleMap[zIndex]);\n
                            }\n
                        } else {\n
                            // no symbolizers in rule\n
                            rulesByZ[0].push(rule.clone());\n
                        }\n
                    }\n
                    // write one FeatureTypeStyle per zIndex\n
                    zValues.sort();\n
                    var rules;\n
                    for (var i=0, ii=zValues.length; i<ii; ++i) {\n
                        rules = rulesByZ[zValues[i]];\n
                        if (rules.length > 0) {\n
                            clone = style.clone();\n
                            clone.rules = rulesByZ[zValues[i]];\n
                            this.writeNode("FeatureTypeStyle", clone, node);\n
                        }\n
                    }                    \n
                } else {\n
                    this.writeNode("FeatureTypeStyle", style, node);\n
                }\n
                \n
                return node;\n
            },\n
            "IsDefault": function(bool) {\n
                return this.createElementNSPlus(\n
                    "sld:IsDefault", {value: (bool) ? "1" : "0"}\n
                );\n
            },\n
            "FeatureTypeStyle": function(style) {\n
                var node = this.createElementNSPlus("sld:FeatureTypeStyle");\n
                \n
                // OpenLayers currently stores no Name, Title, Abstract,\n
                // FeatureTypeName, or SemanticTypeIdentifier information\n
                // related to FeatureTypeStyle\n
                \n
                // add in rules\n
                for(var i=0, len=style.rules.length; i<len; ++i) {\n
                    this.writeNode("Rule", style.rules[i], node);\n
                }\n
                \n
                return node;\n
            },\n
            "Rule": function(rule) {\n
                var node = this.createElementNSPlus("sld:Rule");\n
\n
                // add in optional name\n
                if(rule.name) {\n
                    this.writeNode("Name", rule.name, node);\n
                }\n
                // add in optional title\n
                if(rule.title) {\n
                    this.writeNode("Title", rule.title, node);\n
                }\n
                // add in optional description\n
                if(rule.description) {\n
                    this.writeNode("Abstract", rule.description, node);\n
                }\n
                \n
                // add in LegendGraphic here\n
                \n
                // add in optional filters\n
                if(rule.elseFilter) {\n
                    this.writeNode("ElseFilter", null, node);\n
                } else if(rule.filter) {\n
                    this.writeNode("ogc:Filter", rule.filter, node);\n
                }\n
                \n
                // add in scale limits\n
                if(rule.minScaleDenominator != undefined) {\n
                    this.writeNode(\n
                        "MinScaleDenominator", rule.minScaleDenominator, node\n
                    );\n
                }\n
                if(rule.maxScaleDenominator != undefined) {\n
                    this.writeNode(\n
                        "MaxScaleDenominator", rule.maxScaleDenominator, node\n
                    );\n
                }\n
                \n
                var type, symbolizer;\n
                if (this.multipleSymbolizers && rule.symbolizers) {\n
                    var symbolizer;\n
                    for (var i=0, ii=rule.symbolizers.length; i<ii; ++i) {\n
                        symbolizer = rule.symbolizers[i];\n
                        type = symbolizer.CLASS_NAME.split(".").pop();\n
                        this.writeNode(\n
                            type + "Symbolizer", symbolizer, node\n
                        );\n
                    }\n
                } else {\n
                    // add in symbolizers (relies on geometry type keys)\n
                    var types = OpenLayers.Style.SYMBOLIZER_PREFIXES;\n
                    for(var i=0, len=types.length; i<len; ++i) {\n
                        type = types[i];\n
                        symbolizer = rule.symbolizer[type];\n
                        if(symbolizer) {\n
                            this.writeNode(\n
                                type + "Symbolizer", symbolizer, node\n
                            );\n
                        }\n
                    }\n
                }\n
                return node;\n
\n
            },\n
            "ElseFilter": function() {\n
                return this.createElementNSPlus("sld:ElseFilter");\n
            },\n
            "MinScaleDenominator": function(scale) {\n
                return this.createElementNSPlus(\n
                    "sld:MinScaleDenominator", {value: scale}\n
                );\n
            },\n
            "MaxScaleDenominator": function(scale) {\n
                return this.createElementNSPlus(\n
                    "sld:MaxScaleDenominator", {value: scale}\n
                );\n
            },\n
            "LineSymbolizer": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:LineSymbolizer");\n
                this.writeNode("Stroke", symbolizer, node);\n
                return node;\n
            },\n
            "Stroke": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:Stroke");\n
\n
                // GraphicFill here\n
                // GraphicStroke here\n
\n
                // add in CssParameters\n
                if(symbolizer.strokeColor != undefined) {\n
                    this.writeNode(\n
                        "CssParameter",\n
                        {symbolizer: symbolizer, key: "strokeColor"},\n
                        node\n
                    );\n
                }\n
                if(symbolizer.strokeOpacity != undefined) {\n
                    this.writeNode(\n
                        "CssParameter",\n
                        {symbolizer: symbolizer, key: "strokeOpacity"},\n
                        node\n
                    );\n
                }\n
                if(symbolizer.strokeWidth != undefined) {\n
                    this.writeNode(\n
                        "CssParameter",\n
                        {symbolizer: symbolizer, key: "strokeWidth"},\n
                        node\n
                    );\n
                }\n
                if(symbolizer.strokeDashstyle != undefined && symbolizer.strokeDashstyle !== "solid") {\n
                    // assumes valid stroke-dasharray value\n
                    this.writeNode(\n
                        "CssParameter", \n
                        {symbolizer: symbolizer, key: "strokeDashstyle"},\n
                        node\n
                    );\n
                }\n
                if(symbolizer.strokeLinecap != undefined) {\n
                    this.writeNode(\n
                        "CssParameter", \n
                        {symbolizer: symbolizer, key: "strokeLinecap"},\n
                        node\n
                    );\n
                }\n
                return node;\n
            },\n
            "CssParameter": function(obj) {\n
                // not handling ogc:expressions for now\n
                return this.createElementNSPlus("sld:CssParameter", {\n
                    attributes: {name: this.getCssProperty(obj.key)},\n
                    value: obj.symbolizer[obj.key]\n
                });\n
            },\n
            "TextSymbolizer": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:TextSymbolizer");\n
                // add in optional Label\n
                if(symbolizer.label != null) {\n
                    this.writeNode("Label", symbolizer.label, node);\n
                }\n
                // add in optional Font\n
                if(symbolizer.fontFamily != null ||\n
                    symbolizer.fontSize != null ||\n
                    symbolizer.fontWeight != null ||\n
                    symbolizer.fontStyle != null) {\n
                        this.writeNode("Font", symbolizer, node);\n
                }\n
                // add in optional LabelPlacement\n
                if (symbolizer.labelAnchorPointX != null ||\n
                    symbolizer.labelAnchorPointY != null || \n
                    symbolizer.labelAlign != null ||\n
                    symbolizer.labelXOffset != null ||\n
                    symbolizer.labelYOffset != null ||\n
                    symbolizer.labelRotation != null ||\n
                    symbolizer.labelPerpendicularOffset != null) {\n
                        this.writeNode("LabelPlacement", symbolizer, node);\n
                }\n
                // add in optional Halo\n
                if(symbolizer.haloRadius != null ||\n
                    symbolizer.haloColor != null ||\n
                    symbolizer.haloOpacity != null) {\n
                        this.writeNode("Halo", symbolizer, node);\n
                }\n
                // add in optional Fill\n
                if(symbolizer.fontColor != null ||\n
                   symbolizer.fontOpacity != null) {\n
                    this.writeNode("Fill", {\n
                        fillColor: symbolizer.fontColor,\n
                        fillOpacity: symbolizer.fontOpacity\n
                    }, node);\n
                }\n
                return node;\n
            },\n
            "LabelPlacement": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:LabelPlacement");\n
                // PointPlacement and LinePlacement are choices, so don\'t output both\n
                if ((symbolizer.labelAnchorPointX != null ||\n
                    symbolizer.labelAnchorPointY != null ||\n
                    symbolizer.labelAlign != null ||\n
                    symbolizer.labelXOffset != null ||\n
                    symbolizer.labelYOffset != null ||\n
                    symbolizer.labelRotation != null) && \n
                    symbolizer.labelPerpendicularOffset == null) {\n
                        this.writeNode("PointPlacement", symbolizer, node);\n
                }\n
                if (symbolizer.labelPerpendicularOffset != null) {\n
                    this.writeNode("LinePlacement", symbolizer, node);\n
                }\n
                return node;\n
            },\n
            "LinePlacement": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:LinePlacement");\n
                this.writeNode("PerpendicularOffset", symbolizer.labelPerpendicularOffset, node);\n
                return node;\n
            },\n
            "PerpendicularOffset": function(value) {\n
                return this.createElementNSPlus("sld:PerpendicularOffset", {\n
                    value: value\n
                });\n
            },\n
            "PointPlacement": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:PointPlacement");\n
                if (symbolizer.labelAnchorPointX != null ||\n
                    symbolizer.labelAnchorPointY != null ||\n
                    symbolizer.labelAlign != null) {\n
                        this.writeNode("AnchorPoint", symbolizer, node);\n
                }\n
                if (symbolizer.labelXOffset != null ||\n
                    symbolizer.labelYOffset != null) {\n
                        this.writeNode("Displacement", symbolizer, node);\n
                }\n
                if (symbolizer.labelRotation != null) {\n
                    this.writeNode("Rotation", symbolizer.labelRotation, node);\n
                }\n
                return node;\n
            },\n
            "AnchorPoint": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:AnchorPoint");\n
                var x = symbolizer.labelAnchorPointX,\n
                    y = symbolizer.labelAnchorPointY;\n
                if (x != null) {\n
                    this.writeNode("AnchorPointX", x, node);\n
                }\n
                if (y != null) {\n
                    this.writeNode("AnchorPointY", y, node);\n
                }\n
                if (x == null && y == null) {\n
                    var xAlign = symbolizer.labelAlign.substr(0, 1),\n
                        yAlign = symbolizer.labelAlign.substr(1, 1);\n
                    if (xAlign === "l") {\n
                        x = 0;\n
                    } else if (xAlign === "c") {\n
                        x = 0.5;\n
                    } else if (xAlign === "r") {\n
                        x = 1;\n
                    }\n
                    if (yAlign === "b") {\n
                        y = 0;\n
                    } else if (yAlign === "m") {\n
                        y = 0.5;\n
                    } else if (yAlign === "t") {\n
                        y = 1;\n
                    }\n
                    this.writeNode("AnchorPointX", x, node);\n
                    this.writeNode("AnchorPointY", y, node);\n
                }\n
                return node;\n
            },\n
            "AnchorPointX": function(value) {\n
                return this.createElementNSPlus("sld:AnchorPointX", {\n
                    value: value\n
                }); \n
            },\n
            "AnchorPointY": function(value) {\n
                return this.createElementNSPlus("sld:AnchorPointY", {\n
                    value: value\n
                });\n
            },\n
            "Displacement": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:Displacement");\n
                if (symbolizer.labelXOffset != null) {\n
                    this.writeNode("DisplacementX", symbolizer.labelXOffset, node);\n
                }\n
                if (symbolizer.labelYOffset != null) {\n
                    this.writeNode("DisplacementY", symbolizer.labelYOffset, node);\n
                }\n
                return node;\n
            },\n
            "DisplacementX": function(value) {\n
                return this.createElementNSPlus("sld:DisplacementX", {\n
                    value: value\n
                });\n
            },\n
            "DisplacementY": function(value) {\n
                return this.createElementNSPlus("sld:DisplacementY", {\n
                    value: value\n
                });\n
            },\n
            "Font": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:Font");\n
                // add in CssParameters\n
                if(symbolizer.fontFamily) {\n
                    this.writeNode(\n
                        "CssParameter",\n
                        {symbolizer: symbolizer, key: "fontFamily"},\n
                        node\n
                    );\n
                }\n
                if(symbolizer.fontSize) {\n
                    this.writeNode(\n
                        "CssParameter",\n
                        {symbolizer: symbolizer, key: "fontSize"},\n
                        node\n
                    );\n
                }\n
                if(symbolizer.fontWeight) {\n
                    this.writeNode(\n
                        "CssParameter",\n
                        {symbolizer: symbolizer, key: "fontWeight"},\n
                        node\n
                    );\n
                }\n
                if(symbolizer.fontStyle) {\n
                    this.writeNode(\n
                        "CssParameter",\n
                        {symbolizer: symbolizer, key: "fontStyle"},\n
                        node\n
                    );\n
                }\n
                return node;\n
            },\n
            "Label": function(label) {\n
                return this.writers.sld._OGCExpression.call(\n
                    this, "sld:Label", label\n
                );\n
            },\n
            "Halo": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:Halo");\n
                if(symbolizer.haloRadius) {\n
                    this.writeNode("Radius", symbolizer.haloRadius, node);\n
                }\n
                if(symbolizer.haloColor || symbolizer.haloOpacity) {\n
                    this.writeNode("Fill", {\n
                        fillColor: symbolizer.haloColor,\n
                        fillOpacity: symbolizer.haloOpacity\n
                    }, node);\n
                }\n
                return node;\n
            },\n
            "Radius": function(value) {\n
                return this.createElementNSPlus("sld:Radius", {\n
                    value: value\n
                });\n
            },\n
            "RasterSymbolizer": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:RasterSymbolizer");\n
                if (symbolizer.geometry) {\n
                    this.writeNode("Geometry", symbolizer.geometry, node);\n
                }\n
                if (symbolizer.opacity) {\n
                    this.writeNode("Opacity", symbolizer.opacity, node);\n
                }\n
                if (symbolizer.colorMap) {\n
                    this.writeNode("ColorMap", symbolizer.colorMap, node);\n
                }\n
                return node;\n
            },\n
            "Geometry": function(geometry) {\n
                var node = this.createElementNSPlus("sld:Geometry");\n
                if (geometry.property) {\n
                    this.writeNode("ogc:PropertyName", geometry, node);\n
                }\n
                return node;\n
            },\n
            "ColorMap": function(colorMap) {\n
                var node = this.createElementNSPlus("sld:ColorMap");\n
                for (var i=0, len=colorMap.length; i<len; ++i) {\n
                    this.writeNode("ColorMapEntry", colorMap[i], node);\n
                }\n
                return node;\n
            },\n
            "ColorMapEntry": function(colorMapEntry) {\n
                var node = this.createElementNSPlus("sld:ColorMapEntry");\n
                var a = colorMapEntry;\n
                node.setAttribute("color", a.color);\n
                a.opacity !== undefined && node.setAttribute("opacity",\n
                    parseFloat(a.opacity));\n
                a.quantity !== undefined && node.setAttribute("quantity",\n
                    parseFloat(a.quantity));\n
                a.label !== undefined && node.setAttribute("label", a.label);\n
                return node;\n
            },\n
            "PolygonSymbolizer": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:PolygonSymbolizer");\n
                if(symbolizer.fill !== false) {\n
                    this.writeNode("Fill", symbolizer, node);\n
                }\n
                if(symbolizer.stroke !== false) {\n
                    this.writeNode("Stroke", symbolizer, node);\n
                }\n
                return node;\n
            },\n
            "Fill": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:Fill");\n
                \n
                // GraphicFill here\n
                \n
                // add in CssParameters\n
                if(symbolizer.fillColor) {\n
                    this.writeNode(\n
                        "CssParameter",\n
                        {symbolizer: symbolizer, key: "fillColor"},\n
                        node\n
                    );\n
                }\n
                if(symbolizer.fillOpacity != null) {\n
                    this.writeNode(\n
                        "CssParameter",\n
                        {symbolizer: symbolizer, key: "fillOpacity"},\n
                        node\n
                    );\n
                }\n
                return node;\n
            },\n
            "PointSymbolizer": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:PointSymbolizer");\n
                this.writeNode("Graphic", symbolizer, node);\n
                return node;\n
            },\n
            "Graphic": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:Graphic");\n
                if(symbolizer.externalGraphic != undefined) {\n
                    this.writeNode("ExternalGraphic", symbolizer, node);\n
                } else {\n
                    this.writeNode("Mark", symbolizer, node);\n
                }\n
                \n
                if(symbolizer.graphicOpacity != undefined) {\n
                    this.writeNode("Opacity", symbolizer.graphicOpacity, node);\n
                }\n
                if(symbolizer.pointRadius != undefined) {\n
                    this.writeNode("Size", symbolizer.pointRadius * 2, node);\n
                } else if (symbolizer.graphicWidth != undefined) {\n
                    this.writeNode("Size", symbolizer.graphicWidth, node);\n
                }\n
                if(symbolizer.rotation != undefined) {\n
                    this.writeNode("Rotation", symbolizer.rotation, node);\n
                }\n
                return node;\n
            },\n
            "ExternalGraphic": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:ExternalGraphic");\n
                this.writeNode(\n
                    "OnlineResource", symbolizer.externalGraphic, node\n
                );\n
                var format = symbolizer.graphicFormat ||\n
                             this.getGraphicFormat(symbolizer.externalGraphic);\n
                this.writeNode("Format", format, node);\n
                return node;\n
            },\n
            "Mark": function(symbolizer) {\n
                var node = this.createElementNSPlus("sld:Mark");\n
                if(symbolizer.graphicName) {\n
                    this.writeNode("WellKnownName", symbolizer.graphicName, node);\n
                }\n
                if (symbolizer.fill !== false) {\n
                    this.writeNode("Fill", symbolizer, node);\n
                }\n
                if (symbolizer.stroke !== false) {\n
                    this.writeNode("Stroke", symbolizer, node);\n
                }\n
                return node;\n
            },\n
            "WellKnownName": function(name) {\n
                return this.createElementNSPlus("sld:WellKnownName", {\n
                    value: name\n
                });\n
            },\n
            "Opacity": function(value) {\n
                return this.createElementNSPlus("sld:Opacity", {\n
                    value: value\n
                });\n
            },\n
            "Size": function(value) {\n
                return this.writers.sld._OGCExpression.call(\n
                    this, "sld:Size", value\n
                );\n
            },\n
            "Rotation": function(value) {\n
                return this.createElementNSPlus("sld:Rotation", {\n
                    value: value\n
                });\n
            },\n
            "OnlineResource": function(href) {\n
                return this.createElementNSPlus("sld:OnlineResource", {\n
                    attributes: {\n
                        "xlink:type": "simple",\n
                        "xlink:href": href\n
                    }\n
                });\n
            },\n
            "Format": function(format) {\n
                return this.createElementNSPlus("sld:Format", {\n
                    value: format\n
                });\n
            }\n
        }\n
    }, OpenLayers.Format.Filter.v1_0_0.prototype.writers),\n
    \n
    CLASS_NAME: "OpenLayers.Format.SLD.v1" \n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>52979</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
