<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.91</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>WFSDescribeFeatureType.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Format/XML.js\n
 */\n
 \n
/**\n
 * Class: OpenLayers.Format.WFSDescribeFeatureType\n
 * Read WFS DescribeFeatureType response\n
 * \n
 * Inherits from:\n
 *  - <OpenLayers.Format.XML>\n
 */\n
OpenLayers.Format.WFSDescribeFeatureType = OpenLayers.Class(\n
    OpenLayers.Format.XML, {\n
    \n
    /**\n
     * Property: namespaces\n
     * {Object} Mapping of namespace aliases to namespace URIs.\n
     */\n
    namespaces: {\n
        xsd: "http://www.w3.org/2001/XMLSchema"\n
    },\n
    \n
    /**\n
     * Constructor: OpenLayers.Format.WFSDescribeFeatureType\n
     * Create a new parser for WFS DescribeFeatureType responses.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     */\n
    \n
    /**\n
     * Property: readers\n
     * Contains public functions, grouped by namespace prefix, that will\n
     *     be applied when a namespaced node is found matching the function\n
     *     name.  The function will be applied in the scope of this parser\n
     *     with two arguments: the node being read and a context object passed\n
     *     from the parent.\n
     */\n
    readers: {\n
        "xsd": {\n
            "schema": function(node, obj) {\n
                var complexTypes = [];\n
                var customTypes = {};\n
                var schema = {\n
                    complexTypes: complexTypes,\n
                    customTypes: customTypes\n
                };\n
                \n
                this.readChildNodes(node, schema);\n
\n
                var attributes = node.attributes;\n
                var attr, name;\n
                for(var i=0, len=attributes.length; i<len; ++i) {\n
                    attr = attributes[i];\n
                    name = attr.name;\n
                    if(name.indexOf("xmlns") == 0) {\n
                        this.setNamespace(name.split(":")[1] || "", attr.value);\n
                    } else {\n
                        obj[name] = attr.value;\n
                    }\n
                }\n
                obj.featureTypes = complexTypes;                \n
                obj.targetPrefix = this.namespaceAlias[obj.targetNamespace];\n
                \n
                // map complexTypes to names of customTypes\n
                var complexType, customType;\n
                for(var i=0, len=complexTypes.length; i<len; ++i) {\n
                    complexType = complexTypes[i];\n
                    customType = customTypes[complexType.typeName];\n
                    if(customTypes[complexType.typeName]) {\n
                        complexType.typeName = customType.name;\n
                    }\n
                }\n
            },\n
            "complexType": function(node, obj) {\n
                var complexType = {\n
                    // this is a temporary typeName, it will be overwritten by\n
                    // the schema reader with the metadata found in the\n
                    // customTypes hash\n
                    "typeName": node.getAttribute("name")\n
                };\n
                this.readChildNodes(node, complexType);\n
                obj.complexTypes.push(complexType);\n
            },\n
            "complexContent": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            },\n
            "extension": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            },\n
            "sequence": function(node, obj) {\n
                var sequence = {\n
                    elements: []\n
                };\n
                this.readChildNodes(node, sequence);\n
                obj.properties = sequence.elements;\n
            },\n
            "element": function(node, obj) {\n
                if(obj.elements) {\n
                    var element = {};\n
                    var attributes = node.attributes;\n
                    var attr;\n
                    for(var i=0, len=attributes.length; i<len; ++i) {\n
                        attr = attributes[i];\n
                        element[attr.name] = attr.value;\n
                    }\n
                    \n
                    var type = element.type;\n
                    if(!type) {\n
                        type = {};\n
                        this.readChildNodes(node, type);\n
                        element.restriction = type;\n
                        element.type = type.base;\n
                    }\n
                    var fullType = type.base || type;\n
                    element.localType = fullType.split(":").pop();\n
                    obj.elements.push(element);\n
                }\n
                \n
                if(obj.complexTypes) {\n
                    var type = node.getAttribute("type");\n
                    var localType = type.split(":").pop();\n
                    obj.customTypes[localType] = {\n
                        "name": node.getAttribute("name"),\n
                        "type": type\n
                    };\n
                }\n
            },\n
            "simpleType": function(node, obj) {\n
                this.readChildNodes(node, obj);\n
            },\n
            "restriction": function(node, obj) {\n
                obj.base = node.getAttribute("base");\n
                this.readRestriction(node, obj);\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: readRestriction\n
     * Reads restriction defined in the child nodes of a restriction element\n
     * \n
     * Parameters:\n
     * node - {DOMElement} the node to parse\n
     * obj - {Object} the object that receives the read result\n
     */\n
    readRestriction: function(node, obj) {\n
        var children = node.childNodes;\n
        var child, nodeName, value;\n
        for(var i=0, len=children.length; i<len; ++i) {\n
            child = children[i];\n
            if(child.nodeType == 1) {\n
                nodeName = child.nodeName.split(":").pop();\n
                value = child.getAttribute("value");\n
                if(!obj[nodeName]) {\n
                    obj[nodeName] = value;\n
                } else {\n
                    if(typeof obj[nodeName] == "string") {\n
                        obj[nodeName] = [obj[nodeName]];\n
                    }\n
                    obj[nodeName].push(value);\n
                }\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: read\n
     *\n
     * Parameters:\n
     * data - {DOMElement|String} A WFS DescribeFeatureType document.\n
     *\n
     * Returns:\n
     * {Object} An object representing the WFS DescribeFeatureType response.\n
     */\n
    read: function(data) {\n
        if(typeof data == "string") { \n
            data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);\n
        }\n
        if(data && data.nodeType == 9) {\n
            data = data.documentElement;\n
        }\n
        var schema = {};\n
        this.readNode(data, schema);\n
        \n
        return schema;\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Format.WFSDescribeFeatureType" \n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>6993</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
