<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.94</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>v1.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Format/XML.js\n
 * @requires OpenLayers/Format/WFST.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Format.WFST.v1\n
 * Superclass for WFST parsers.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Format.XML>\n
 */\n
OpenLayers.Format.WFST.v1 = OpenLayers.Class(OpenLayers.Format.XML, {\n
    \n
    /**\n
     * Property: namespaces\n
     * {Object} Mapping of namespace aliases to namespace URIs.\n
     */\n
    namespaces: {\n
        xlink: "http://www.w3.org/1999/xlink",\n
        xsi: "http://www.w3.org/2001/XMLSchema-instance",\n
        wfs: "http://www.opengis.net/wfs",\n
        gml: "http://www.opengis.net/gml",\n
        ogc: "http://www.opengis.net/ogc",\n
        ows: "http://www.opengis.net/ows"\n
    },\n
    \n
    /**\n
     * Property: defaultPrefix\n
     */\n
    defaultPrefix: "wfs",\n
\n
    /**\n
     * Property: version\n
     * {String} WFS version number.\n
     */\n
    version: null,\n
\n
    /**\n
     * Property: schemaLocation\n
     * {String} Schema location for a particular minor version.\n
     */\n
    schemaLocations: null,\n
    \n
    /**\n
     * APIProperty: srsName\n
     * {String} URI for spatial reference system.\n
     */\n
    srsName: null,\n
\n
    /**\n
     * APIProperty: extractAttributes\n
     * {Boolean} Extract attributes from GML.  Default is true.\n
     */\n
    extractAttributes: true,\n
    \n
    /**\n
     * APIProperty: xy\n
     * {Boolean} Order of the GML coordinate true:(x,y) or false:(y,x)\n
     * Changing is not recommended, a new Format should be instantiated.\n
     */ \n
    xy: true,\n
\n
    /**\n
     * Property: stateName\n
     * {Object} Maps feature states to node names.\n
     */\n
    stateName: null,\n
    \n
    /**\n
     * Constructor: OpenLayers.Format.WFST.v1\n
     * Instances of this class are not created directly.  Use the\n
     *     <OpenLayers.Format.WFST.v1_0_0> or <OpenLayers.Format.WFST.v1_1_0>\n
     *     constructor instead.\n
     *\n
     * Parameters:\n
     * options - {Object} An optional object whose properties will be set on\n
     *     this instance.\n
     */\n
    initialize: function(options) {\n
        // set state name mapping\n
        this.stateName = {};\n
        this.stateName[OpenLayers.State.INSERT] = "wfs:Insert";\n
        this.stateName[OpenLayers.State.UPDATE] = "wfs:Update";\n
        this.stateName[OpenLayers.State.DELETE] = "wfs:Delete";\n
        OpenLayers.Format.XML.prototype.initialize.apply(this, [options]);\n
    },\n
    \n
    /**\n
     * Method: getSrsName\n
     */\n
    getSrsName: function(feature, options) {\n
        var srsName = options && options.srsName;\n
        if(!srsName) {\n
            if(feature && feature.layer) {\n
                srsName = feature.layer.projection.getCode();\n
            } else {\n
                srsName = this.srsName;\n
            }\n
        }\n
        return srsName;\n
    },\n
\n
    /**\n
     * APIMethod: read\n
     * Parse the response from a transaction.  Because WFS is split into\n
     *     Transaction requests (create, update, and delete) and GetFeature\n
     *     requests (read), this method handles parsing of both types of\n
     *     responses.\n
     *\n
     * Parameters:\n
     * data - {String | Document} The WFST document to read\n
     * options - {Object} Options for the reader\n
     *\n
     * Valid options properties:\n
     * output - {String} either "features" or "object". The default is\n
     *     "features", which means that the method will return an array of\n
     *     features. If set to "object", an object with a "features" property\n
     *     and other properties read by the parser will be returned.\n
     *\n
     * Returns:\n
     * {Array | Object} Output depending on the output option.\n
     */\n
    read: function(data, options) {\n
        options = options || {};\n
        OpenLayers.Util.applyDefaults(options, {\n
            output: "features"\n
        });\n
        \n
        if(typeof data == "string") { \n
            data = OpenLayers.Format.XML.prototype.read.apply(this, [data]);\n
        }\n
        if(data && data.nodeType == 9) {\n
            data = data.documentElement;\n
        }\n
        var obj = {};\n
        if(data) {\n
            this.readNode(data, obj, true);\n
        }\n
        if(obj.features && options.output === "features") {\n
            obj = obj.features;\n
        }\n
        return obj;\n
    },\n
    \n
    /**\n
     * Property: readers\n
     * Contains public functions, grouped by namespace prefix, that will\n
     *     be applied when a namespaced node is found matching the function\n
     *     name.  The function will be applied in the scope of this parser\n
     *     with two arguments: the node being read and a context object passed\n
     *     from the parent.\n
     */\n
    readers: {\n
        "wfs": {\n
            "FeatureCollection": function(node, obj) {\n
                obj.features = [];\n
                this.readChildNodes(node, obj);\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: write\n
     * Given an array of features, write a WFS transaction.  This assumes\n
     *     the features have a state property that determines the operation\n
     *     type - insert, update, or delete.\n
     *\n
     * Parameters:\n
     * features - {Array(<OpenLayers.Feature.Vector>)} A list of features. See\n
     *     below for a more detailed description of the influence of the\n
     *     feature\'s *modified* property.\n
     * options - {Object}\n
     *\n
     * feature.modified rules:\n
     * If a feature has a modified property set, the following checks will be\n
     * made before a feature\'s geometry or attribute is included in an Update\n
     * transaction:\n
     * - *modified* is not set at all: The geometry and all attributes will be\n
     *     included.\n
     * - *modified.geometry* is set (null or a geometry): The geometry will be\n
     *     included. If *modified.attributes* is not set, all attributes will\n
     *     be included.\n
     * - *modified.attributes* is set: Only the attributes set (i.e. to null or\n
     *     a value) in *modified.attributes* will be included. \n
     *     If *modified.geometry* is not set, the geometry will not be included.\n
     *\n
     * Valid options include:\n
     * - *multi* {Boolean} If set to true, geometries will be casted to\n
     *   Multi geometries before writing.\n
     *\n
     * Returns:\n
     * {String} A serialized WFS transaction.\n
     */\n
    write: function(features, options) {\n
        var node = this.writeNode("wfs:Transaction", {\n
            features:features,\n
            options: options\n
        });\n
        var value = this.schemaLocationAttr();\n
        if(value) {\n
            this.setAttributeNS(\n
                node, this.namespaces["xsi"], "xsi:schemaLocation",  value\n
            );\n
        }\n
        return OpenLayers.Format.XML.prototype.write.apply(this, [node]);\n
    },\n
    \n
    /**\n
     * Property: writers\n
     * As a compliment to the readers property, this structure contains public\n
     *     writing functions grouped by namespace alias and named like the\n
     *     node names they produce.\n
     */\n
    writers: {\n
        "wfs": {\n
            "GetFeature": function(options) {\n
                var node = this.createElementNSPlus("wfs:GetFeature", {\n
                    attributes: {\n
                        service: "WFS",\n
                        version: this.version,\n
                        handle: options && options.handle,\n
                        outputFormat: options && options.outputFormat,\n
                        maxFeatures: options && options.maxFeatures,\n
                        "xsi:schemaLocation": this.schemaLocationAttr(options)\n
                    }\n
                });\n
                if (typeof this.featureType == "string") {\n
                    this.writeNode("Query", options, node);\n
                } else {\n
                    for (var i=0,len = this.featureType.length; i<len; i++) { \n
                        options.featureType = this.featureType[i]; \n
                        this.writeNode("Query", options, node); \n
                    } \n
                }\n
                return node;\n
            },\n
            "Transaction": function(obj) {\n
                obj = obj || {};\n
                var options = obj.options || {};\n
                var node = this.createElementNSPlus("wfs:Transaction", {\n
                    attributes: {\n
                        service: "WFS",\n
                        version: this.version,\n
                        handle: options.handle\n
                    }\n
                });\n
                var i, len;\n
                var features = obj.features;\n
                if(features) {\n
                    // temporarily re-assigning geometry types\n
                    if (options.multi === true) {\n
                        OpenLayers.Util.extend(this.geometryTypes, {\n
                            "OpenLayers.Geometry.Point": "MultiPoint",\n
                            "OpenLayers.Geometry.LineString": (this.multiCurve === true) ? "MultiCurve": "MultiLineString",\n
                            "OpenLayers.Geometry.Polygon": (this.multiSurface === true) ? "MultiSurface" : "MultiPolygon"\n
                        });\n
                    }\n
                    var name, feature;\n
                    for(i=0, len=features.length; i<len; ++i) {\n
                        feature = features[i];\n
                        name = this.stateName[feature.state];\n
                        if(name) {\n
                            this.writeNode(name, {\n
                                feature: feature, \n
                                options: options\n
                            }, node);\n
                        }\n
                    }\n
                    // switch back to original geometry types assignment\n
                    if (options.multi === true) {\n
                        this.setGeometryTypes();\n
                    }\n
                }\n
                if (options.nativeElements) {\n
                    for (i=0, len=options.nativeElements.length; i<len; ++i) {\n
                        this.writeNode("wfs:Native", \n
                            options.nativeElements[i], node);\n
                    }\n
                }\n
                return node;\n
            },\n
            "Native": function(nativeElement) {\n
                var node = this.createElementNSPlus("wfs:Native", {\n
                    attributes: {\n
                        vendorId: nativeElement.vendorId,\n
                        safeToIgnore: nativeElement.safeToIgnore\n
                    },\n
                    value: nativeElement.value\n
                });\n
                return node;\n
            },\n
            "Insert": function(obj) {\n
                var feature = obj.feature;\n
                var options = obj.options;\n
                var node = this.createElementNSPlus("wfs:Insert", {\n
                    attributes: {\n
                        handle: options && options.handle\n
                    }\n
                });\n
                this.srsName = this.getSrsName(feature);\n
                this.writeNode("feature:_typeName", feature, node);\n
                return node;\n
            },\n
            "Update": function(obj) {\n
                var feature = obj.feature;\n
                var options = obj.options;\n
                var node = this.createElementNSPlus("wfs:Update", {\n
                    attributes: {\n
                        handle: options && options.handle,\n
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") +\n
                            this.featureType\n
                    }\n
                });\n
                if(this.featureNS) {\n
                    node.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);\n
                }\n
                \n
                // add in geometry\n
                var modified = feature.modified;\n
                if (this.geometryName !== null && (!modified || modified.geometry !== undefined)) {\n
                    this.srsName = this.getSrsName(feature);\n
                    this.writeNode(\n
                        "Property", {name: this.geometryName, value: feature.geometry}, node\n
                    );\n
                }\n
        \n
                // add in attributes\n
                for(var key in feature.attributes) {\n
                    if(feature.attributes[key] !== undefined &&\n
                                (!modified || !modified.attributes ||\n
                                (modified.attributes && modified.attributes[key] !== undefined))) {\n
                        this.writeNode(\n
                            "Property", {name: key, value: feature.attributes[key]}, node\n
                        );\n
                    }\n
                }\n
                \n
                // add feature id filter\n
                this.writeNode("ogc:Filter", new OpenLayers.Filter.FeatureId({\n
                    fids: [feature.fid]\n
                }), node);\n
        \n
                return node;\n
            },\n
            "Property": function(obj) {\n
                var node = this.createElementNSPlus("wfs:Property");\n
                this.writeNode("Name", obj.name, node);\n
                if(obj.value !== null) {\n
                    this.writeNode("Value", obj.value, node);\n
                }\n
                return node;\n
            },\n
            "Name": function(name) {\n
                return this.createElementNSPlus("wfs:Name", {value: name});\n
            },\n
            "Value": function(obj) {\n
                var node;\n
                if(obj instanceof OpenLayers.Geometry) {\n
                    node = this.createElementNSPlus("wfs:Value");\n
                    var geom = this.writeNode("feature:_geometry", obj).firstChild;\n
                    node.appendChild(geom);\n
                } else {\n
                    node = this.createElementNSPlus("wfs:Value", {value: obj});                \n
                }\n
                return node;\n
            },\n
            "Delete": function(obj) {\n
                var feature = obj.feature;\n
                var options = obj.options;\n
                var node = this.createElementNSPlus("wfs:Delete", {\n
                    attributes: {\n
                        handle: options && options.handle,\n
                        typeName: (this.featureNS ? this.featurePrefix + ":" : "") +\n
                            this.featureType\n
                    }\n
                });\n
                if(this.featureNS) {\n
                    node.setAttribute("xmlns:" + this.featurePrefix, this.featureNS);\n
                }\n
                this.writeNode("ogc:Filter", new OpenLayers.Filter.FeatureId({\n
                    fids: [feature.fid]\n
                }), node);\n
                return node;\n
            }\n
        }\n
    },\n
\n
    /**\n
     * Method: schemaLocationAttr\n
     * Generate the xsi:schemaLocation attribute value.\n
     *\n
     * Returns:\n
     * {String} The xsi:schemaLocation attribute or undefined if none.\n
     */\n
    schemaLocationAttr: function(options) {\n
        options = OpenLayers.Util.extend({\n
            featurePrefix: this.featurePrefix,\n
            schema: this.schema\n
        }, options);\n
        var schemaLocations = OpenLayers.Util.extend({}, this.schemaLocations);\n
        if(options.schema) {\n
            schemaLocations[options.featurePrefix] = options.schema;\n
        }\n
        var parts = [];\n
        var uri;\n
        for(var key in schemaLocations) {\n
            uri = this.namespaces[key];\n
            if(uri) {\n
                parts.push(uri + " " + schemaLocations[key]);\n
            }\n
        }\n
        var value = parts.join(" ") || undefined;\n
        return value;\n
    },\n
    \n
    /**\n
     * Method: setFilterProperty\n
     * Set the property of each spatial filter.\n
     *\n
     * Parameters:\n
     * filter - {<OpenLayers.Filter>}\n
     */\n
    setFilterProperty: function(filter) {\n
        if(filter.filters) {\n
            for(var i=0, len=filter.filters.length; i<len; ++i) {\n
                OpenLayers.Format.WFST.v1.prototype.setFilterProperty.call(this, filter.filters[i]);\n
            }\n
        } else {\n
            if(filter instanceof OpenLayers.Filter.Spatial && !filter.property) {\n
                // got a spatial filter without property, so set it\n
                filter.property = this.geometryName;\n
            }\n
        }\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Format.WFST.v1" \n
\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>16316</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
