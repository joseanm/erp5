<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.78</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Date.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for\n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/SingleFile.js\n
 */\n
\n
/**\n
 * Namespace: OpenLayers.Date\n
 * Contains implementations of Date.parse and date.toISOString that match the\n
 *     ECMAScript 5 specification for parsing RFC 3339 dates.\n
 *     http://tools.ietf.org/html/rfc3339\n
 */\n
OpenLayers.Date = {\n
\n
    /**\n
     * APIMethod: toISOString\n
     * Generates a string representing a date.  The format of the string follows\n
     *     the profile of ISO 8601 for date and time on the Internet (see\n
     *     http://tools.ietf.org/html/rfc3339).  If the toISOString method is\n
     *     available on the Date prototype, that is used.  The toISOString\n
     *     method for Date instances is defined in ECMA-262.\n
     *\n
     * Parameters:\n
     * date - {Date} A date object.\n
     *\n
     * Returns:\n
     * {String} A string representing the date (e.g.\n
     *     "2010-08-07T16:58:23.123Z").  If the date does not have a valid time\n
     *     (i.e. isNaN(date.getTime())) this method returns the string "Invalid\n
     *     Date".  The ECMA standard says the toISOString method should throw\n
     *     RangeError in this case, but Firefox returns a string instead.  For\n
     *     best results, use isNaN(date.getTime()) to determine date validity\n
     *     before generating date strings.\n
     */\n
    toISOString: (function() {\n
        if ("toISOString" in Date.prototype) {\n
            return function(date) {\n
                return date.toISOString();\n
            };\n
        } else {\n
            function pad(num, len) {\n
                var str = num + "";\n
                while (str.length < len) {\n
                    str = "0" + str;\n
                }\n
                return str;\n
            }\n
            return function(date) {\n
                var str;\n
                if (isNaN(date.getTime())) {\n
                    // ECMA-262 says throw RangeError, Firefox returns\n
                    // "Invalid Date"\n
                    str = "Invalid Date";\n
                } else {\n
                    str =\n
                        date.getUTCFullYear() + "-" +\n
                        pad(date.getUTCMonth() + 1, 2) + "-" +\n
                        pad(date.getUTCDate(), 2) + "T" +\n
                        pad(date.getUTCHours(), 2) + ":" +\n
                        pad(date.getUTCMinutes(), 2) + ":" +\n
                        pad(date.getUTCSeconds(), 2) + "." +\n
                        pad(date.getUTCMilliseconds(), 3) + "Z";\n
                }\n
                return str;\n
            };\n
        }\n
\n
    })(),\n
\n
    /**\n
     * APIMethod: parse\n
     * Generate a date object from a string.  The format for the string follows\n
     *     the profile of ISO 8601 for date and time on the Internet (see\n
     *     http://tools.ietf.org/html/rfc3339).  We don\'t call the native\n
     *     Date.parse because of inconsistency between implmentations.  In\n
     *     Chrome, calling Date.parse with a string that doesn\'t contain any\n
     *     indication of the timezone (e.g. "2011"), the date is interpreted\n
     *     in local time.  On Firefox, the assumption is UTC.\n
     *\n
     * Parameters:\n
     * str - {String} A string representing the date (e.g.\n
     *     "2010", "2010-08", "2010-08-07", "2010-08-07T16:58:23.123Z",\n
     *     "2010-08-07T11:58:23.123-06").\n
     *\n
     * Returns:\n
     * {Date} A date object.  If the string could not be parsed, an invalid\n
     *     date is returned (i.e. isNaN(date.getTime())).\n
     */\n
    parse: function(str) {\n
        var date;\n
        var match = str.match(/^(?:(\\d{4})(?:-(\\d{2})(?:-(\\d{2}))?)?)?(?:(?:T(\\d{1,2}):(\\d{2}):(\\d{2}(?:\\.\\d+)?)(Z|(?:[+-]\\d{1,2}(?::(\\d{2}))?)))|Z)?$/);\n
        if (match && (match[1] || match[7])) { // must have at least year or time\n
            var year = parseInt(match[1], 10) || 0;\n
            var month = (parseInt(match[2], 10) - 1) || 0;\n
            var day = parseInt(match[3], 10) || 1;\n
            date = new Date(Date.UTC(year, month, day));\n
            // optional time\n
            var type = match[7];\n
            if (type) {\n
                var hours = parseInt(match[4], 10);\n
                var minutes = parseInt(match[5], 10);\n
                var secFrac = parseFloat(match[6]);\n
                var seconds = secFrac | 0;\n
                var milliseconds = Math.round(1000 * (secFrac - seconds));\n
                date.setUTCHours(hours, minutes, seconds, milliseconds);\n
                // check offset\n
                if (type !== "Z") {\n
                    var hoursOffset = parseInt(type, 10);\n
                    var minutesOffset = parseInt(match[8], 10) || 0;\n
                    var offset = -1000 * (60 * (hoursOffset * 60) + minutesOffset * 60);\n
                    date = new Date(date.getTime() + offset);\n
                }\n
            }\n
        } else {\n
            date = new Date("invalid");\n
        }\n
        return date;\n
    }\n
};\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>5071</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
