<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.8</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Elements.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Renderer.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.ElementsIndexer\n
 * This class takes care of figuring out which order elements should be\n
 *     placed in the DOM based on given indexing methods. \n
 */\n
OpenLayers.ElementsIndexer = OpenLayers.Class({\n
   \n
    /**\n
     * Property: maxZIndex\n
     * {Integer} This is the largest-most z-index value for a node\n
     *     contained within the indexer.\n
     */\n
    maxZIndex: null,\n
    \n
    /**\n
     * Property: order\n
     * {Array<String>} This is an array of node id\'s stored in the\n
     *     order that they should show up on screen. Id\'s higher up in the\n
     *     array (higher array index) represent nodes with higher z-indeces.\n
     */\n
    order: null, \n
    \n
    /**\n
     * Property: indices\n
     * {Object} This is a hash that maps node ids to their z-index value\n
     *     stored in the indexer. This is done to make finding a nodes z-index \n
     *     value O(1).\n
     */\n
    indices: null,\n
    \n
    /**\n
     * Property: compare\n
     * {Function} This is the function used to determine placement of\n
     *     of a new node within the indexer. If null, this defaults to to\n
     *     the Z_ORDER_DRAWING_ORDER comparison method.\n
     */\n
    compare: null,\n
    \n
    /**\n
     * APIMethod: initialize\n
     * Create a new indexer with \n
     * \n
     * Parameters:\n
     * yOrdering - {Boolean} Whether to use y-ordering.\n
     */\n
    initialize: function(yOrdering) {\n
\n
        this.compare = yOrdering ? \n
            OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER_Y_ORDER :\n
            OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER_DRAWING_ORDER;\n
\n
        this.clear();\n
    },\n
    \n
    /**\n
     * APIMethod: insert\n
     * Insert a new node into the indexer. In order to find the correct \n
     *     positioning for the node to be inserted, this method uses a binary \n
     *     search. This makes inserting O(log(n)). \n
     * \n
     * Parameters:\n
     * newNode - {DOMElement} The new node to be inserted.\n
     * \n
     * Returns\n
     * {DOMElement} the node before which we should insert our newNode, or\n
     *     null if newNode can just be appended.\n
     */\n
    insert: function(newNode) {\n
        // If the node is known to the indexer, remove it so we can\n
        // recalculate where it should go.\n
        if (this.exists(newNode)) {\n
            this.remove(newNode);\n
        }\n
        \n
        var nodeId = newNode.id;\n
        \n
        this.determineZIndex(newNode);       \n
\n
        var leftIndex = -1;\n
        var rightIndex = this.order.length;\n
        var middle;\n
\n
        while (rightIndex - leftIndex > 1) {\n
            middle = parseInt((leftIndex + rightIndex) / 2);\n
            \n
            var placement = this.compare(this, newNode,\n
                OpenLayers.Util.getElement(this.order[middle]));\n
            \n
            if (placement > 0) {\n
                leftIndex = middle;\n
            } else {\n
                rightIndex = middle;\n
            } \n
        }\n
        \n
        this.order.splice(rightIndex, 0, nodeId);\n
        this.indices[nodeId] = this.getZIndex(newNode);\n
        \n
        // If the new node should be before another in the index\n
        // order, return the node before which we have to insert the new one;\n
        // else, return null to indicate that the new node can be appended.\n
        return this.getNextElement(rightIndex);\n
    },\n
    \n
    /**\n
     * APIMethod: remove\n
     * \n
     * Parameters:\n
     * node - {DOMElement} The node to be removed.\n
     */\n
    remove: function(node) {\n
        var nodeId = node.id;\n
        var arrayIndex = OpenLayers.Util.indexOf(this.order, nodeId);\n
        if (arrayIndex >= 0) {\n
            // Remove it from the order array, as well as deleting the node\n
            // from the indeces hash.\n
            this.order.splice(arrayIndex, 1);\n
            delete this.indices[nodeId];\n
            \n
            // Reset the maxium z-index based on the last item in the \n
            // order array.\n
            if (this.order.length > 0) {\n
                var lastId = this.order[this.order.length - 1];\n
                this.maxZIndex = this.indices[lastId];\n
            } else {\n
                this.maxZIndex = 0;\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * APIMethod: clear\n
     */\n
    clear: function() {\n
        this.order = [];\n
        this.indices = {};\n
        this.maxZIndex = 0;\n
    },\n
    \n
    /**\n
     * APIMethod: exists\n
     *\n
     * Parameters:\n
     * node - {DOMElement} The node to test for existence.\n
     *\n
     * Returns:\n
     * {Boolean} Whether or not the node exists in the indexer?\n
     */\n
    exists: function(node) {\n
        return (this.indices[node.id] != null);\n
    },\n
\n
    /**\n
     * APIMethod: getZIndex\n
     * Get the z-index value for the current node from the node data itself.\n
     * \n
     * Parameters:\n
     * node - {DOMElement} The node whose z-index to get.\n
     * \n
     * Returns:\n
     * {Integer} The z-index value for the specified node (from the node \n
     *     data itself).\n
     */\n
    getZIndex: function(node) {\n
        return node._style.graphicZIndex;  \n
    },\n
    \n
    /**\n
     * Method: determineZIndex\n
     * Determine the z-index for the current node if there isn\'t one, \n
     *     and set the maximum value if we\'ve found a new maximum.\n
     * \n
     * Parameters:\n
     * node - {DOMElement} \n
     */\n
    determineZIndex: function(node) {\n
        var zIndex = node._style.graphicZIndex;\n
        \n
        // Everything must have a zIndex. If none is specified,\n
        // this means the user *must* (hint: assumption) want this\n
        // node to succomb to drawing order. To enforce drawing order\n
        // over all indexing methods, we\'ll create a new z-index that\'s\n
        // greater than any currently in the indexer.\n
        if (zIndex == null) {\n
            zIndex = this.maxZIndex;\n
            node._style.graphicZIndex = zIndex; \n
        } else if (zIndex > this.maxZIndex) {\n
            this.maxZIndex = zIndex;\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: getNextElement\n
     * Get the next element in the order stack.\n
     * \n
     * Parameters:\n
     * index - {Integer} The index of the current node in this.order.\n
     * \n
     * Returns:\n
     * {DOMElement} the node following the index passed in, or\n
     *     null.\n
     */\n
    getNextElement: function(index) {\n
        var nextIndex = index + 1;\n
        if (nextIndex < this.order.length) {\n
            var nextElement = OpenLayers.Util.getElement(this.order[nextIndex]);\n
            if (nextElement == undefined) {\n
                nextElement = this.getNextElement(nextIndex);\n
            }\n
            return nextElement;\n
        } else {\n
            return null;\n
        } \n
    },\n
    \n
    CLASS_NAME: "OpenLayers.ElementsIndexer"\n
});\n
\n
/**\n
 * Namespace: OpenLayers.ElementsIndexer.IndexingMethods\n
 * These are the compare methods for figuring out where a new node should be \n
 *     placed within the indexer. These methods are very similar to general \n
 *     sorting methods in that they return -1, 0, and 1 to specify the \n
 *     direction in which new nodes fall in the ordering.\n
 */\n
OpenLayers.ElementsIndexer.IndexingMethods = {\n
    \n
    /**\n
     * Method: Z_ORDER\n
     * This compare method is used by other comparison methods.\n
     *     It can be used individually for ordering, but is not recommended,\n
     *     because it doesn\'t subscribe to drawing order.\n
     * \n
     * Parameters:\n
     * indexer - {<OpenLayers.ElementsIndexer>}\n
     * newNode - {DOMElement}\n
     * nextNode - {DOMElement}\n
     * \n
     * Returns:\n
     * {Integer}\n
     */\n
    Z_ORDER: function(indexer, newNode, nextNode) {\n
        var newZIndex = indexer.getZIndex(newNode);\n
\n
        var returnVal = 0;\n
        if (nextNode) {\n
            var nextZIndex = indexer.getZIndex(nextNode);\n
            returnVal = newZIndex - nextZIndex; \n
        }\n
        \n
        return returnVal;\n
    },\n
\n
    /**\n
     * APIMethod: Z_ORDER_DRAWING_ORDER\n
     * This method orders nodes by their z-index, but does so in a way\n
     *     that, if there are other nodes with the same z-index, the newest \n
     *     drawn will be the front most within that z-index. This is the \n
     *     default indexing method.\n
     * \n
     * Parameters:\n
     * indexer - {<OpenLayers.ElementsIndexer>}\n
     * newNode - {DOMElement}\n
     * nextNode - {DOMElement}\n
     * \n
     * Returns:\n
     * {Integer}\n
     */\n
    Z_ORDER_DRAWING_ORDER: function(indexer, newNode, nextNode) {\n
        var returnVal = OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER(\n
            indexer, \n
            newNode, \n
            nextNode\n
        );\n
        \n
        // Make Z_ORDER subscribe to drawing order by pushing it above\n
        // all of the other nodes with the same z-index.\n
        if (nextNode && returnVal == 0) {\n
            returnVal = 1;\n
        }\n
        \n
        return returnVal;\n
    },\n
\n
    /**\n
     * APIMethod: Z_ORDER_Y_ORDER\n
     * This one should really be called Z_ORDER_Y_ORDER_DRAWING_ORDER, as it\n
     *     best describes which ordering methods have precedence (though, the \n
     *     name would be too long). This method orders nodes by their z-index, \n
     *     but does so in a way that, if there are other nodes with the same \n
     *     z-index, the nodes with the lower y position will be "closer" than \n
     *     those with a higher y position. If two nodes have the exact same y \n
     *     position, however, then this method will revert to using drawing  \n
     *     order to decide placement.\n
     * \n
     * Parameters:\n
     * indexer - {<OpenLayers.ElementsIndexer>}\n
     * newNode - {DOMElement}\n
     * nextNode - {DOMElement}\n
     * \n
     * Returns:\n
     * {Integer}\n
     */\n
    Z_ORDER_Y_ORDER: function(indexer, newNode, nextNode) {\n
        var returnVal = OpenLayers.ElementsIndexer.IndexingMethods.Z_ORDER(\n
            indexer, \n
            newNode, \n
            nextNode\n
        );\n
        \n
        if (nextNode && returnVal === 0) {            \n
            var result = nextNode._boundsBottom - newNode._boundsBottom;\n
            returnVal = (result === 0) ? 1 : result;\n
        }\n
        \n
        return returnVal;       \n
    }\n
};\n
\n
/**\n
 * Class: OpenLayers.Renderer.Elements\n
 * This is another virtual class in that it should never be instantiated by \n
 *  itself as a Renderer. It exists because there is *tons* of shared \n
 *  functionality between different vector libraries which use nodes/elements\n
 *  as a base for rendering vectors. \n
 * \n
 * The highlevel bits of code that are implemented here are the adding and \n
 *  removing of geometries, which is essentially the same for any \n
 *  element-based renderer. The details of creating each node and drawing the\n
 *  paths are of course different, but the machinery is the same. \n
 * \n
 * Inherits:\n
 *  - <OpenLayers.Renderer>\n
 */\n
OpenLayers.Renderer.Elements = OpenLayers.Class(OpenLayers.Renderer, {\n
\n
    /**\n
     * Property: rendererRoot\n
     * {DOMElement}\n
     */\n
    rendererRoot: null,\n
    \n
    /**\n
     * Property: root\n
     * {DOMElement}\n
     */\n
    root: null,\n
    \n
    /**\n
     * Property: vectorRoot\n
     * {DOMElement}\n
     */\n
    vectorRoot: null,\n
\n
    /**\n
     * Property: textRoot\n
     * {DOMElement}\n
     */\n
    textRoot: null,\n
\n
    /**\n
     * Property: xmlns\n
     * {String}\n
     */    \n
    xmlns: null,\n
    \n
    /**\n
     * Property: xOffset\n
     * {Number} Offset to apply to the renderer viewport translation in x\n
     * direction. If the renderer extent\'s center is on the right of the\n
     * dateline (i.e. exceeds the world bounds), we shift the viewport to the\n
     * left by one world width. This avoids that features disappear from the\n
     * map viewport. Because our dateline handling logic in other places\n
     * ensures that extents crossing the dateline always have a center\n
     * exceeding the world bounds on the left, we need this offset to make sure\n
     * that the same is true for the renderer extent in pixel space as well.\n
     */\n
    xOffset: 0,\n
    \n
    /**\n
     * Property: rightOfDateLine\n
     * {Boolean} Keeps track of the location of the map extent relative to the\n
     * date line. The <setExtent> method compares this value (which is the one\n
     * from the previous <setExtent> call) with the current position of the map\n
     * extent relative to the date line and updates the xOffset when the extent\n
     * has moved from one side of the date line to the other.\n
     */\n
    \n
    /**\n
     * Property: Indexer\n
     * {<OpenLayers.ElementIndexer>} An instance of OpenLayers.ElementsIndexer \n
     *     created upon initialization if the zIndexing or yOrdering options\n
     *     passed to this renderer\'s constructor are set to true.\n
     */\n
    indexer: null, \n
    \n
    /**\n
     * Constant: BACKGROUND_ID_SUFFIX\n
     * {String}\n
     */\n
    BACKGROUND_ID_SUFFIX: "_background",\n
    \n
    /**\n
     * Constant: LABEL_ID_SUFFIX\n
     * {String}\n
     */\n
    LABEL_ID_SUFFIX: "_label",\n
    \n
    /**\n
     * Constant: LABEL_OUTLINE_SUFFIX\n
     * {String}\n
     */\n
    LABEL_OUTLINE_SUFFIX: "_outline",\n
\n
    /**\n
     * Constructor: OpenLayers.Renderer.Elements\n
     * \n
     * Parameters:\n
     * containerID - {String}\n
     * options - {Object} options for this renderer. \n
     *\n
     * Supported options are:\n
     *     yOrdering - {Boolean} Whether to use y-ordering\n
     *     zIndexing - {Boolean} Whether to use z-indexing. Will be ignored\n
     *         if yOrdering is set to true.\n
     */\n
    initialize: function(containerID, options) {\n
        OpenLayers.Renderer.prototype.initialize.apply(this, arguments);\n
\n
        this.rendererRoot = this.createRenderRoot();\n
        this.root = this.createRoot("_root");\n
        this.vectorRoot = this.createRoot("_vroot");\n
        this.textRoot = this.createRoot("_troot");\n
        \n
        this.root.appendChild(this.vectorRoot);\n
        this.root.appendChild(this.textRoot);\n
        \n
        this.rendererRoot.appendChild(this.root);\n
        this.container.appendChild(this.rendererRoot);\n
        \n
        if(options && (options.zIndexing || options.yOrdering)) {\n
            this.indexer = new OpenLayers.ElementsIndexer(options.yOrdering);\n
        }\n
    },\n
    \n
    /**\n
     * Method: destroy\n
     */\n
    destroy: function() {\n
\n
        this.clear(); \n
\n
        this.rendererRoot = null;\n
        this.root = null;\n
        this.xmlns = null;\n
\n
        OpenLayers.Renderer.prototype.destroy.apply(this, arguments);\n
    },\n
    \n
    /**\n
     * Method: clear\n
     * Remove all the elements from the root\n
     */    \n
    clear: function() {\n
        var child;\n
        var root = this.vectorRoot;\n
        if (root) {\n
            while (child = root.firstChild) {\n
                root.removeChild(child);\n
            }\n
        }\n
        root = this.textRoot;\n
        if (root) {\n
            while (child = root.firstChild) {\n
                root.removeChild(child);\n
            }\n
        }\n
        if (this.indexer) {\n
            this.indexer.clear();\n
        }\n
    },\n
    \n
    /**\n
     * Method: setExtent\n
     * Set the visible part of the layer.\n
     *\n
     * Parameters:\n
     * extent - {<OpenLayers.Bounds>}\n
     * resolutionChanged - {Boolean}\n
     *\n
     * Returns:\n
     * {Boolean} true to notify the layer that the new extent does not exceed\n
     *     the coordinate range, and the features will not need to be redrawn.\n
     *     False otherwise.\n
     */\n
    setExtent: function(extent, resolutionChanged) {\n
        var coordSysUnchanged = OpenLayers.Renderer.prototype.setExtent.apply(this, arguments);\n
        var resolution = this.getResolution();\n
        if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {\n
            var rightOfDateLine,\n
                ratio = extent.getWidth() / this.map.getExtent().getWidth(),\n
                extent = extent.scale(1 / ratio),\n
                world = this.map.getMaxExtent();\n
            if (world.right > extent.left && world.right < extent.right) {\n
                rightOfDateLine = true;\n
            } else if (world.left > extent.left && world.left < extent.right) {\n
                rightOfDateLine = false;\n
            }\n
            if (rightOfDateLine !== this.rightOfDateLine || resolutionChanged) {\n
                coordSysUnchanged = false;\n
                this.xOffset = rightOfDateLine === true ?\n
                    world.getWidth() / resolution : 0;\n
            }\n
            this.rightOfDateLine = rightOfDateLine;\n
        }\n
        return coordSysUnchanged;\n
    },\n
\n
    /** \n
     * Method: getNodeType\n
     * This function is in charge of asking the specific renderer which type\n
     *     of node to create for the given geometry and style. All geometries\n
     *     in an Elements-based renderer consist of one node and some\n
     *     attributes. We have the nodeFactory() function which creates a node\n
     *     for us, but it takes a \'type\' as input, and that is precisely what\n
     *     this function tells us.  \n
     *  \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * style - {Object}\n
     * \n
     * Returns:\n
     * {String} The corresponding node type for the specified geometry\n
     */\n
    getNodeType: function(geometry, style) { },\n
\n
    /** \n
     * Method: drawGeometry \n
     * Draw the geometry, creating new nodes, setting paths, setting style,\n
     *     setting featureId on the node.  This method should only be called\n
     *     by the renderer itself.\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * style - {Object}\n
     * featureId - {String}\n
     * \n
     * Returns:\n
     * {Boolean} true if the geometry has been drawn completely; null if\n
     *     incomplete; false otherwise\n
     */\n
    drawGeometry: function(geometry, style, featureId) {\n
        var className = geometry.CLASS_NAME;\n
        var rendered = true;\n
        if ((className == "OpenLayers.Geometry.Collection") ||\n
            (className == "OpenLayers.Geometry.MultiPoint") ||\n
            (className == "OpenLayers.Geometry.MultiLineString") ||\n
            (className == "OpenLayers.Geometry.MultiPolygon")) {\n
            for (var i = 0, len=geometry.components.length; i<len; i++) {\n
                rendered = this.drawGeometry(\n
                    geometry.components[i], style, featureId) && rendered;\n
            }\n
            return rendered;\n
        }\n
\n
        rendered = false;\n
        var removeBackground = false;\n
        if (style.display != "none") {\n
            if (style.backgroundGraphic) {\n
                this.redrawBackgroundNode(geometry.id, geometry, style,\n
                    featureId);\n
            } else {\n
                removeBackground = true;\n
            }\n
            rendered = this.redrawNode(geometry.id, geometry, style,\n
                featureId);\n
        }\n
        if (rendered == false) {\n
            var node = document.getElementById(geometry.id);\n
            if (node) {\n
                if (node._style.backgroundGraphic) {\n
                    removeBackground = true;\n
                }\n
                node.parentNode.removeChild(node);\n
            }\n
        }\n
        if (removeBackground) {\n
            var node = document.getElementById(\n
                geometry.id + this.BACKGROUND_ID_SUFFIX);\n
            if (node) {\n
                node.parentNode.removeChild(node);\n
            }\n
        }\n
        return rendered;\n
    },\n
    \n
    /**\n
     * Method: redrawNode\n
     * \n
     * Parameters:\n
     * id - {String}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * style - {Object}\n
     * featureId - {String}\n
     * \n
     * Returns:\n
     * {Boolean} true if the complete geometry could be drawn, null if parts of\n
     *     the geometry could not be drawn, false otherwise\n
     */\n
    redrawNode: function(id, geometry, style, featureId) {\n
        style = this.applyDefaultSymbolizer(style);\n
        // Get the node if it\'s already on the map.\n
        var node = this.nodeFactory(id, this.getNodeType(geometry, style));\n
        \n
        // Set the data for the node, then draw it.\n
        node._featureId = featureId;\n
        node._boundsBottom = geometry.getBounds().bottom;\n
        node._geometryClass = geometry.CLASS_NAME;\n
        node._style = style;\n
\n
        var drawResult = this.drawGeometryNode(node, geometry, style);\n
        if(drawResult === false) {\n
            return false;\n
        }\n
         \n
        node = drawResult.node;\n
        \n
        // Insert the node into the indexer so it can show us where to\n
        // place it. Note that this operation is O(log(n)). If there\'s a\n
        // performance problem (when dragging, for instance) this is\n
        // likely where it would be.\n
        if (this.indexer) {\n
            var insert = this.indexer.insert(node);\n
            if (insert) {\n
                this.vectorRoot.insertBefore(node, insert);\n
            } else {\n
                this.vectorRoot.appendChild(node);\n
            }\n
        } else {\n
            // if there\'s no indexer, simply append the node to root,\n
            // but only if the node is a new one\n
            if (node.parentNode !== this.vectorRoot){ \n
                this.vectorRoot.appendChild(node);\n
            }\n
        }\n
        \n
        this.postDraw(node);\n
        \n
        return drawResult.complete;\n
    },\n
    \n
    /**\n
     * Method: redrawBackgroundNode\n
     * Redraws the node using special \'background\' style properties. Basically\n
     *     just calls redrawNode(), but instead of directly using the \n
     *     \'externalGraphic\', \'graphicXOffset\', \'graphicYOffset\', and \n
     *     \'graphicZIndex\' properties directly from the specified \'style\' \n
     *     parameter, we create a new style object and set those properties \n
     *     from the corresponding \'background\'-prefixed properties from \n
     *     specified \'style\' parameter.\n
     * \n
     * Parameters:\n
     * id - {String}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * style - {Object}\n
     * featureId - {String}\n
     * \n
     * Returns:\n
     * {Boolean} true if the complete geometry could be drawn, null if parts of\n
     *     the geometry could not be drawn, false otherwise\n
     */\n
    redrawBackgroundNode: function(id, geometry, style, featureId) {\n
        var backgroundStyle = OpenLayers.Util.extend({}, style);\n
        \n
        // Set regular style attributes to apply to the background styles.\n
        backgroundStyle.externalGraphic = backgroundStyle.backgroundGraphic;\n
        backgroundStyle.graphicXOffset = backgroundStyle.backgroundXOffset;\n
        backgroundStyle.graphicYOffset = backgroundStyle.backgroundYOffset;\n
        backgroundStyle.graphicZIndex = backgroundStyle.backgroundGraphicZIndex;\n
        backgroundStyle.graphicWidth = backgroundStyle.backgroundWidth || backgroundStyle.graphicWidth;\n
        backgroundStyle.graphicHeight = backgroundStyle.backgroundHeight || backgroundStyle.graphicHeight;\n
        \n
        // Erase background styles.\n
        backgroundStyle.backgroundGraphic = null;\n
        backgroundStyle.backgroundXOffset = null;\n
        backgroundStyle.backgroundYOffset = null;\n
        backgroundStyle.backgroundGraphicZIndex = null;\n
        \n
        return this.redrawNode(\n
            id + this.BACKGROUND_ID_SUFFIX, \n
            geometry, \n
            backgroundStyle, \n
            null\n
        );\n
    },\n
\n
    /**\n
     * Method: drawGeometryNode\n
     * Given a node, draw a geometry on the specified layer.\n
     *     node and geometry are required arguments, style is optional.\n
     *     This method is only called by the render itself.\n
     *\n
     * Parameters:\n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * style - {Object}\n
     * \n
     * Returns:\n
     * {Object} a hash with properties "node" (the drawn node) and "complete"\n
     *     (null if parts of the geometry could not be drawn, false if nothing\n
     *     could be drawn)\n
     */\n
    drawGeometryNode: function(node, geometry, style) {\n
        style = style || node._style;\n
\n
        var options = {\n
            \'isFilled\': style.fill === undefined ?\n
                true :\n
                style.fill,\n
            \'isStroked\': style.stroke === undefined ?\n
                !!style.strokeWidth :\n
                style.stroke\n
        };\n
        var drawn;\n
        switch (geometry.CLASS_NAME) {\n
            case "OpenLayers.Geometry.Point":\n
                if(style.graphic === false) {\n
                    options.isFilled = false;\n
                    options.isStroked = false;\n
                }\n
                drawn = this.drawPoint(node, geometry);\n
                break;\n
            case "OpenLayers.Geometry.LineString":\n
                options.isFilled = false;\n
                drawn = this.drawLineString(node, geometry);\n
                break;\n
            case "OpenLayers.Geometry.LinearRing":\n
                drawn = this.drawLinearRing(node, geometry);\n
                break;\n
            case "OpenLayers.Geometry.Polygon":\n
                drawn = this.drawPolygon(node, geometry);\n
                break;\n
            case "OpenLayers.Geometry.Rectangle":\n
                drawn = this.drawRectangle(node, geometry);\n
                break;\n
            default:\n
                break;\n
        }\n
\n
        node._options = options; \n
\n
        //set style\n
        //TBD simplify this\n
        if (drawn != false) {\n
            return {\n
                node: this.setStyle(node, style, options, geometry),\n
                complete: drawn\n
            };\n
        } else {\n
            return false;\n
        }\n
    },\n
    \n
    /**\n
     * Method: postDraw\n
     * Things that have do be done after the geometry node is appended\n
     *     to its parent node. To be overridden by subclasses.\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     */\n
    postDraw: function(node) {},\n
    \n
    /**\n
     * Method: drawPoint\n
     * Virtual function for drawing Point Geometry. \n
     *     Should be implemented by subclasses.\n
     *     This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or false if the renderer could not draw the point\n
     */ \n
    drawPoint: function(node, geometry) {},\n
\n
    /**\n
     * Method: drawLineString\n
     * Virtual function for drawing LineString Geometry. \n
     *     Should be implemented by subclasses.\n
     *     This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or null if the renderer could not draw all components of\n
     *     the linestring, or false if nothing could be drawn\n
     */ \n
    drawLineString: function(node, geometry) {},\n
\n
    /**\n
     * Method: drawLinearRing\n
     * Virtual function for drawing LinearRing Geometry. \n
     *     Should be implemented by subclasses.\n
     *     This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or null if the renderer could not draw all components\n
     *     of the linear ring, or false if nothing could be drawn\n
     */ \n
    drawLinearRing: function(node, geometry) {},\n
\n
    /**\n
     * Method: drawPolygon\n
     * Virtual function for drawing Polygon Geometry. \n
     *    Should be implemented by subclasses.\n
     *    This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or null if the renderer could not draw all components\n
     *     of the polygon, or false if nothing could be drawn\n
     */ \n
    drawPolygon: function(node, geometry) {},\n
\n
    /**\n
     * Method: drawRectangle\n
     * Virtual function for drawing Rectangle Geometry. \n
     *     Should be implemented by subclasses.\n
     *     This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or false if the renderer could not draw the rectangle\n
     */ \n
    drawRectangle: function(node, geometry) {},\n
\n
    /**\n
     * Method: drawCircle\n
     * Virtual function for drawing Circle Geometry. \n
     *     Should be implemented by subclasses.\n
     *     This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or false if the renderer could not draw the circle\n
     */ \n
    drawCircle: function(node, geometry) {},\n
\n
    /**\n
     * Method: removeText\n
     * Removes a label\n
     * \n
     * Parameters:\n
     * featureId - {String}\n
     */\n
    removeText: function(featureId) {\n
        var label = document.getElementById(featureId + this.LABEL_ID_SUFFIX);\n
        if (label) {\n
            this.textRoot.removeChild(label);\n
        }\n
        var outline = document.getElementById(featureId + this.LABEL_OUTLINE_SUFFIX);\n
        if (outline) {\n
            this.textRoot.removeChild(outline);\n
        }\n
    },\n
\n
    /**\n
     * Method: getFeatureIdFromEvent\n
     * \n
     * Parameters:\n
     * evt - {Object} An <OpenLayers.Event> object\n
     *\n
     * Returns:\n
     * {String} A feature id or undefined.\n
     */\n
    getFeatureIdFromEvent: function(evt) {\n
        var target = evt.target;\n
        var useElement = target && target.correspondingUseElement;\n
        var node = useElement ? useElement : (target || evt.srcElement);\n
        return node._featureId;\n
    },\n
\n
    /** \n
     * Method: eraseGeometry\n
     * Erase a geometry from the renderer. In the case of a multi-geometry, \n
     *     we cycle through and recurse on ourselves. Otherwise, we look for a \n
     *     node with the geometry.id, destroy its geometry, and remove it from\n
     *     the DOM.\n
     * \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * featureId - {String}\n
     */\n
    eraseGeometry: function(geometry, featureId) {\n
        if ((geometry.CLASS_NAME == "OpenLayers.Geometry.MultiPoint") ||\n
            (geometry.CLASS_NAME == "OpenLayers.Geometry.MultiLineString") ||\n
            (geometry.CLASS_NAME == "OpenLayers.Geometry.MultiPolygon") ||\n
            (geometry.CLASS_NAME == "OpenLayers.Geometry.Collection")) {\n
            for (var i=0, len=geometry.components.length; i<len; i++) {\n
                this.eraseGeometry(geometry.components[i], featureId);\n
            }\n
        } else {    \n
            var element = OpenLayers.Util.getElement(geometry.id);\n
            if (element && element.parentNode) {\n
                if (element.geometry) {\n
                    element.geometry.destroy();\n
                    element.geometry = null;\n
                }\n
                element.parentNode.removeChild(element);\n
\n
                if (this.indexer) {\n
                    this.indexer.remove(element);\n
                }\n
                \n
                if (element._style.backgroundGraphic) {\n
                    var backgroundId = geometry.id + this.BACKGROUND_ID_SUFFIX;\n
                    var bElem = OpenLayers.Util.getElement(backgroundId);\n
                    if (bElem && bElem.parentNode) {\n
                        // No need to destroy the geometry since the element and the background\n
                        // node share the same geometry.\n
                        bElem.parentNode.removeChild(bElem);\n
                    }\n
                }\n
            }\n
        }\n
    },\n
\n
    /** \n
     * Method: nodeFactory\n
     * Create new node of the specified type, with the (optional) specified id.\n
     * \n
     * If node already exists with same ID and a different type, we remove it\n
     *     and then call ourselves again to recreate it.\n
     * \n
     * Parameters:\n
     * id - {String}\n
     * type - {String} type Kind of node to draw.\n
     * \n
     * Returns:\n
     * {DOMElement} A new node of the given type and id.\n
     */\n
    nodeFactory: function(id, type) {\n
        var node = OpenLayers.Util.getElement(id);\n
        if (node) {\n
            if (!this.nodeTypeCompare(node, type)) {\n
                node.parentNode.removeChild(node);\n
                node = this.nodeFactory(id, type);\n
            }\n
        } else {\n
            node = this.createNode(type, id);\n
        }\n
        return node;\n
    },\n
    \n
    /** \n
     * Method: nodeTypeCompare\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     * type - {String} Kind of node\n
     * \n
     * Returns:\n
     * {Boolean} Whether or not the specified node is of the specified type\n
     *     This function must be overridden by subclasses.\n
     */\n
    nodeTypeCompare: function(node, type) {},\n
    \n
    /** \n
     * Method: createNode\n
     * \n
     * Parameters:\n
     * type - {String} Kind of node to draw.\n
     * id - {String} Id for node.\n
     * \n
     * Returns:\n
     * {DOMElement} A new node of the given type and id.\n
     *     This function must be overridden by subclasses.\n
     */\n
    createNode: function(type, id) {},\n
\n
    /**\n
     * Method: moveRoot\n
     * moves this renderer\'s root to a different renderer.\n
     * \n
     * Parameters:\n
     * renderer - {<OpenLayers.Renderer>} target renderer for the moved root\n
     */\n
    moveRoot: function(renderer) {\n
        var root = this.root;\n
        if(renderer.root.parentNode == this.rendererRoot) {\n
            root = renderer.root;\n
        }\n
        root.parentNode.removeChild(root);\n
        renderer.rendererRoot.appendChild(root);\n
    },\n
    \n
    /**\n
     * Method: getRenderLayerId\n
     * Gets the layer that this renderer\'s output appears on. If moveRoot was\n
     * used, this will be different from the id of the layer containing the\n
     * features rendered by this renderer.\n
     * \n
     * Returns:\n
     * {String} the id of the output layer.\n
     */\n
    getRenderLayerId: function() {\n
        return this.root.parentNode.parentNode.id;\n
    },\n
    \n
    /**\n
     * Method: isComplexSymbol\n
     * Determines if a symbol cannot be rendered using drawCircle\n
     * \n
     * Parameters:\n
     * graphicName - {String}\n
     * \n
     * Returns\n
     * {Boolean} true if the symbol is complex, false if not\n
     */\n
    isComplexSymbol: function(graphicName) {\n
        return (graphicName != "circle") && !!graphicName;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Renderer.Elements"\n
});\n
\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>34381</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
