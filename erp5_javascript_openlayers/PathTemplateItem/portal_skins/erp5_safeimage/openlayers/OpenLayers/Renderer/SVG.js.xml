<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.8</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>SVG.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Renderer/Elements.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Renderer.SVG\n
 * \n
 * Inherits:\n
 *  - <OpenLayers.Renderer.Elements>\n
 */\n
OpenLayers.Renderer.SVG = OpenLayers.Class(OpenLayers.Renderer.Elements, {\n
\n
    /** \n
     * Property: xmlns\n
     * {String}\n
     */\n
    xmlns: "http://www.w3.org/2000/svg",\n
    \n
    /**\n
     * Property: xlinkns\n
     * {String}\n
     */\n
    xlinkns: "http://www.w3.org/1999/xlink",\n
\n
    /**\n
     * Constant: MAX_PIXEL\n
     * {Integer} Firefox has a limitation where values larger or smaller than  \n
     *           about 15000 in an SVG document lock the browser up. This \n
     *           works around it.\n
     */\n
    MAX_PIXEL: 15000,\n
\n
    /**\n
     * Property: translationParameters\n
     * {Object} Hash with "x" and "y" properties\n
     */\n
    translationParameters: null,\n
    \n
    /**\n
     * Property: symbolMetrics\n
     * {Object} Cache for symbol metrics according to their svg coordinate\n
     *     space. This is an object keyed by the symbol\'s id, and values are\n
     *     an array of [width, centerX, centerY].\n
     */\n
    symbolMetrics: null,\n
    \n
    /**\n
     * Constructor: OpenLayers.Renderer.SVG\n
     * \n
     * Parameters:\n
     * containerID - {String}\n
     */\n
    initialize: function(containerID) {\n
        if (!this.supported()) { \n
            return; \n
        }\n
        OpenLayers.Renderer.Elements.prototype.initialize.apply(this, \n
                                                                arguments);\n
        this.translationParameters = {x: 0, y: 0};\n
        \n
        this.symbolMetrics = {};\n
    },\n
\n
    /**\n
     * APIMethod: supported\n
     * \n
     * Returns:\n
     * {Boolean} Whether or not the browser supports the SVG renderer\n
     */\n
    supported: function() {\n
        var svgFeature = "http://www.w3.org/TR/SVG11/feature#";\n
        return (document.implementation && \n
           (document.implementation.hasFeature("org.w3c.svg", "1.0") || \n
            document.implementation.hasFeature(svgFeature + "SVG", "1.1") || \n
            document.implementation.hasFeature(svgFeature + "BasicStructure", "1.1") ));\n
    },    \n
\n
    /**\n
     * Method: inValidRange\n
     * See #669 for more information\n
     *\n
     * Parameters:\n
     * x      - {Integer}\n
     * y      - {Integer}\n
     * xyOnly - {Boolean} whether or not to just check for x and y, which means\n
     *     to not take the current translation parameters into account if true.\n
     * \n
     * Returns:\n
     * {Boolean} Whether or not the \'x\' and \'y\' coordinates are in the  \n
     *           valid range.\n
     */ \n
    inValidRange: function(x, y, xyOnly) {\n
        var left = x + (xyOnly ? 0 : this.translationParameters.x);\n
        var top = y + (xyOnly ? 0 : this.translationParameters.y);\n
        return (left >= -this.MAX_PIXEL && left <= this.MAX_PIXEL &&\n
                top >= -this.MAX_PIXEL && top <= this.MAX_PIXEL);\n
    },\n
\n
    /**\n
     * Method: setExtent\n
     * \n
     * Parameters:\n
     * extent - {<OpenLayers.Bounds>}\n
     * resolutionChanged - {Boolean}\n
     * \n
     * Returns:\n
     * {Boolean} true to notify the layer that the new extent does not exceed\n
     *     the coordinate range, and the features will not need to be redrawn.\n
     *     False otherwise.\n
     */\n
    setExtent: function(extent, resolutionChanged) {\n
        var coordSysUnchanged = OpenLayers.Renderer.Elements.prototype.setExtent.apply(this, arguments);\n
        \n
        var resolution = this.getResolution(),\n
            left = -extent.left / resolution,\n
            top = extent.top / resolution;\n
\n
        // If the resolution has changed, start over changing the corner, because\n
        // the features will redraw.\n
        if (resolutionChanged) {\n
            this.left = left;\n
            this.top = top;\n
            // Set the viewbox\n
            var extentString = "0 0 " + this.size.w + " " + this.size.h;\n
\n
            this.rendererRoot.setAttributeNS(null, "viewBox", extentString);\n
            this.translate(this.xOffset, 0);\n
            return true;\n
        } else {\n
            var inRange = this.translate(left - this.left + this.xOffset, top - this.top);\n
            if (!inRange) {\n
                // recenter the coordinate system\n
                this.setExtent(extent, true);\n
            }\n
            return coordSysUnchanged && inRange;\n
        }\n
    },\n
    \n
    /**\n
     * Method: translate\n
     * Transforms the SVG coordinate system\n
     * \n
     * Parameters:\n
     * x - {Float}\n
     * y - {Float}\n
     * \n
     * Returns:\n
     * {Boolean} true if the translation parameters are in the valid coordinates\n
     *     range, false otherwise.\n
     */\n
    translate: function(x, y) {\n
        if (!this.inValidRange(x, y, true)) {\n
            return false;\n
        } else {\n
            var transformString = "";\n
            if (x || y) {\n
                transformString = "translate(" + x + "," + y + ")";\n
            }\n
            this.root.setAttributeNS(null, "transform", transformString);\n
            this.translationParameters = {x: x, y: y};\n
            return true;\n
        }\n
    },\n
\n
    /**\n
     * Method: setSize\n
     * Sets the size of the drawing surface.\n
     * \n
     * Parameters:\n
     * size - {<OpenLayers.Size>} The size of the drawing surface\n
     */\n
    setSize: function(size) {\n
        OpenLayers.Renderer.prototype.setSize.apply(this, arguments);\n
        \n
        this.rendererRoot.setAttributeNS(null, "width", this.size.w);\n
        this.rendererRoot.setAttributeNS(null, "height", this.size.h);\n
    },\n
\n
    /** \n
     * Method: getNodeType \n
     * \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * style - {Object}\n
     * \n
     * Returns:\n
     * {String} The corresponding node type for the specified geometry\n
     */\n
    getNodeType: function(geometry, style) {\n
        var nodeType = null;\n
        switch (geometry.CLASS_NAME) {\n
            case "OpenLayers.Geometry.Point":\n
                if (style.externalGraphic) {\n
                    nodeType = "image";\n
                } else if (this.isComplexSymbol(style.graphicName)) {\n
                    nodeType = "svg";\n
                } else {\n
                    nodeType = "circle";\n
                }\n
                break;\n
            case "OpenLayers.Geometry.Rectangle":\n
                nodeType = "rect";\n
                break;\n
            case "OpenLayers.Geometry.LineString":\n
                nodeType = "polyline";\n
                break;\n
            case "OpenLayers.Geometry.LinearRing":\n
                nodeType = "polygon";\n
                break;\n
            case "OpenLayers.Geometry.Polygon":\n
            case "OpenLayers.Geometry.Curve":\n
                nodeType = "path";\n
                break;\n
            default:\n
                break;\n
        }\n
        return nodeType;\n
    },\n
\n
    /** \n
     * Method: setStyle\n
     * Use to set all the style attributes to a SVG node.\n
     * \n
     * Takes care to adjust stroke width and point radius to be\n
     * resolution-relative\n
     *\n
     * Parameters:\n
     * node - {SVGDomElement} An SVG element to decorate\n
     * style - {Object}\n
     * options - {Object} Currently supported options include \n
     *                              \'isFilled\' {Boolean} and\n
     *                              \'isStroked\' {Boolean}\n
     */\n
    setStyle: function(node, style, options) {\n
        style = style  || node._style;\n
        options = options || node._options;\n
        var r = parseFloat(node.getAttributeNS(null, "r"));\n
        var widthFactor = 1;\n
        var pos;\n
        if (node._geometryClass == "OpenLayers.Geometry.Point" && r) {\n
            node.style.visibility = "";\n
            if (style.graphic === false) {\n
                node.style.visibility = "hidden";\n
            } else if (style.externalGraphic) {\n
                pos = this.getPosition(node);\n
                \n
                if (style.graphicTitle) {\n
                    node.setAttributeNS(null, "title", style.graphicTitle);\n
                    //Standards-conformant SVG\n
                    // Prevent duplicate nodes. See issue https://github.com/openlayers/openlayers/issues/92 \n
                    var titleNode = node.getElementsByTagName("title");\n
                    if (titleNode.length > 0) {\n
                        titleNode[0].firstChild.textContent = style.graphicTitle;\n
                    } else {\n
                        var label = this.nodeFactory(null, "title");\n
                        label.textContent = style.graphicTitle;\n
                        node.appendChild(label);\n
                    }\n
                }\n
                if (style.graphicWidth && style.graphicHeight) {\n
                  node.setAttributeNS(null, "preserveAspectRatio", "none");\n
                }\n
                var width = style.graphicWidth || style.graphicHeight;\n
                var height = style.graphicHeight || style.graphicWidth;\n
                width = width ? width : style.pointRadius*2;\n
                height = height ? height : style.pointRadius*2;\n
                var xOffset = (style.graphicXOffset != undefined) ?\n
                    style.graphicXOffset : -(0.5 * width);\n
                var yOffset = (style.graphicYOffset != undefined) ?\n
                    style.graphicYOffset : -(0.5 * height);\n
\n
                var opacity = style.graphicOpacity || style.fillOpacity;\n
                \n
                node.setAttributeNS(null, "x", (pos.x + xOffset).toFixed());\n
                node.setAttributeNS(null, "y", (pos.y + yOffset).toFixed());\n
                node.setAttributeNS(null, "width", width);\n
                node.setAttributeNS(null, "height", height);\n
                node.setAttributeNS(this.xlinkns, "href", style.externalGraphic);\n
                node.setAttributeNS(null, "style", "opacity: "+opacity);\n
                node.onclick = OpenLayers.Renderer.SVG.preventDefault;\n
            } else if (this.isComplexSymbol(style.graphicName)) {\n
                // the symbol viewBox is three times as large as the symbol\n
                var offset = style.pointRadius * 3;\n
                var size = offset * 2;\n
                var src = this.importSymbol(style.graphicName);\n
                pos = this.getPosition(node);\n
                widthFactor = this.symbolMetrics[src.id][0] * 3 / size;\n
                \n
                // remove the node from the dom before we modify it. This\n
                // prevents various rendering issues in Safari and FF\n
                var parent = node.parentNode;\n
                var nextSibling = node.nextSibling;\n
                if(parent) {\n
                    parent.removeChild(node);\n
                }\n
                \n
                // The more appropriate way to implement this would be use/defs,\n
                // but due to various issues in several browsers, it is safer to\n
                // copy the symbols instead of referencing them. \n
                // See e.g. ticket http://trac.osgeo.org/openlayers/ticket/2985 \n
                // and this email thread\n
                // http://osgeo-org.1803224.n2.nabble.com/Select-Control-Ctrl-click-on-Feature-with-a-graphicName-opens-new-browser-window-tc5846039.html\n
                node.firstChild && node.removeChild(node.firstChild);\n
                node.appendChild(src.firstChild.cloneNode(true));\n
                node.setAttributeNS(null, "viewBox", src.getAttributeNS(null, "viewBox"));\n
                \n
                node.setAttributeNS(null, "width", size);\n
                node.setAttributeNS(null, "height", size);\n
                node.setAttributeNS(null, "x", pos.x - offset);\n
                node.setAttributeNS(null, "y", pos.y - offset);\n
                \n
                // now that the node has all its new properties, insert it\n
                // back into the dom where it was\n
                if(nextSibling) {\n
                    parent.insertBefore(node, nextSibling);\n
                } else if(parent) {\n
                    parent.appendChild(node);\n
                }\n
            } else {\n
                node.setAttributeNS(null, "r", style.pointRadius);\n
            }\n
\n
            var rotation = style.rotation;\n
            \n
            if ((rotation !== undefined || node._rotation !== undefined) && pos) {\n
                node._rotation = rotation;\n
                rotation |= 0;\n
                if (node.nodeName !== "svg") { \n
                    node.setAttributeNS(null, "transform", \n
                        "rotate(" + rotation + " " + pos.x + " " + \n
                        pos.y + ")"); \n
                } else {\n
                    var metrics = this.symbolMetrics[src.id];\n
                    node.firstChild.setAttributeNS(null, "transform", "rotate(" \n
                        + rotation + " " \n
                        + metrics[1] + " "\n
                        + metrics[2] + ")");\n
                }\n
            }\n
        }\n
        \n
        if (options.isFilled) {\n
            node.setAttributeNS(null, "fill", style.fillColor);\n
            node.setAttributeNS(null, "fill-opacity", style.fillOpacity);\n
        } else {\n
            node.setAttributeNS(null, "fill", "none");\n
        }\n
\n
        if (options.isStroked) {\n
            node.setAttributeNS(null, "stroke", style.strokeColor);\n
            node.setAttributeNS(null, "stroke-opacity", style.strokeOpacity);\n
            node.setAttributeNS(null, "stroke-width", style.strokeWidth * widthFactor);\n
            node.setAttributeNS(null, "stroke-linecap", style.strokeLinecap || "round");\n
            // Hard-coded linejoin for now, to make it look the same as in VML.\n
            // There is no strokeLinejoin property yet for symbolizers.\n
            node.setAttributeNS(null, "stroke-linejoin", "round");\n
            style.strokeDashstyle && node.setAttributeNS(null,\n
                "stroke-dasharray", this.dashStyle(style, widthFactor));\n
        } else {\n
            node.setAttributeNS(null, "stroke", "none");\n
        }\n
        \n
        if (style.pointerEvents) {\n
            node.setAttributeNS(null, "pointer-events", style.pointerEvents);\n
        }\n
                \n
        if (style.cursor != null) {\n
            node.setAttributeNS(null, "cursor", style.cursor);\n
        }\n
        \n
        return node;\n
    },\n
\n
    /** \n
     * Method: dashStyle\n
     * \n
     * Parameters:\n
     * style - {Object}\n
     * widthFactor - {Number}\n
     * \n
     * Returns:\n
     * {String} A SVG compliant \'stroke-dasharray\' value\n
     */\n
    dashStyle: function(style, widthFactor) {\n
        var w = style.strokeWidth * widthFactor;\n
        var str = style.strokeDashstyle;\n
        switch (str) {\n
            case \'solid\':\n
                return \'none\';\n
            case \'dot\':\n
                return [1, 4 * w].join();\n
            case \'dash\':\n
                return [4 * w, 4 * w].join();\n
            case \'dashdot\':\n
                return [4 * w, 4 * w, 1, 4 * w].join();\n
            case \'longdash\':\n
                return [8 * w, 4 * w].join();\n
            case \'longdashdot\':\n
                return [8 * w, 4 * w, 1, 4 * w].join();\n
            default:\n
                return OpenLayers.String.trim(str).replace(/\\s+/g, ",");\n
        }\n
    },\n
    \n
    /** \n
     * Method: createNode\n
     * \n
     * Parameters:\n
     * type - {String} Kind of node to draw\n
     * id - {String} Id for node\n
     * \n
     * Returns:\n
     * {DOMElement} A new node of the given type and id\n
     */\n
    createNode: function(type, id) {\n
        var node = document.createElementNS(this.xmlns, type);\n
        if (id) {\n
            node.setAttributeNS(null, "id", id);\n
        }\n
        return node;    \n
    },\n
    \n
    /** \n
     * Method: nodeTypeCompare\n
     * \n
     * Parameters:\n
     * node - {SVGDomElement} An SVG element\n
     * type - {String} Kind of node\n
     * \n
     * Returns:\n
     * {Boolean} Whether or not the specified node is of the specified type\n
     */\n
    nodeTypeCompare: function(node, type) {\n
        return (type == node.nodeName);\n
    },\n
   \n
    /**\n
     * Method: createRenderRoot\n
     * \n
     * Returns:\n
     * {DOMElement} The specific render engine\'s root element\n
     */\n
    createRenderRoot: function() {\n
        var svg = this.nodeFactory(this.container.id + "_svgRoot", "svg");\n
        svg.style.display = "block";\n
        return svg;\n
    },\n
\n
    /**\n
     * Method: createRoot\n
     * \n
     * Parameters:\n
     * suffix - {String} suffix to append to the id\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    createRoot: function(suffix) {\n
        return this.nodeFactory(this.container.id + suffix, "g");\n
    },\n
\n
    /**\n
     * Method: createDefs\n
     *\n
     * Returns:\n
     * {DOMElement} The element to which we\'ll add the symbol definitions\n
     */\n
    createDefs: function() {\n
        var defs = this.nodeFactory(this.container.id + "_defs", "defs");\n
        this.rendererRoot.appendChild(defs);\n
        return defs;\n
    },\n
\n
    /**************************************\n
     *                                    *\n
     *     GEOMETRY DRAWING FUNCTIONS     *\n
     *                                    *\n
     **************************************/\n
\n
    /**\n
     * Method: drawPoint\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or false if the renderer could not draw the point\n
     */ \n
    drawPoint: function(node, geometry) {\n
        return this.drawCircle(node, geometry, 1);\n
    },\n
\n
    /**\n
     * Method: drawCircle\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * radius - {Float}\n
     * \n
     * Returns:\n
     * {DOMElement} or false if the renderer could not draw the circle\n
     */\n
    drawCircle: function(node, geometry, radius) {\n
        var resolution = this.getResolution();\n
        var x = ((geometry.x - this.featureDx) / resolution + this.left);\n
        var y = (this.top - geometry.y / resolution);\n
\n
        if (this.inValidRange(x, y)) { \n
            node.setAttributeNS(null, "cx", x);\n
            node.setAttributeNS(null, "cy", y);\n
            node.setAttributeNS(null, "r", radius);\n
            return node;\n
        } else {\n
            return false;\n
        }    \n
            \n
    },\n
    \n
    /**\n
     * Method: drawLineString\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or null if the renderer could not draw all components of\n
     *     the linestring, or false if nothing could be drawn\n
     */ \n
    drawLineString: function(node, geometry) {\n
        var componentsResult = this.getComponentsString(geometry.components);\n
        if (componentsResult.path) {\n
            node.setAttributeNS(null, "points", componentsResult.path);\n
            return (componentsResult.complete ? node : null);  \n
        } else {\n
            return false;\n
        }\n
    },\n
    \n
    /**\n
     * Method: drawLinearRing\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or null if the renderer could not draw all components\n
     *     of the linear ring, or false if nothing could be drawn\n
     */ \n
    drawLinearRing: function(node, geometry) {\n
        var componentsResult = this.getComponentsString(geometry.components);\n
        if (componentsResult.path) {\n
            node.setAttributeNS(null, "points", componentsResult.path);\n
            return (componentsResult.complete ? node : null);  \n
        } else {\n
            return false;\n
        }\n
    },\n
    \n
    /**\n
     * Method: drawPolygon\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or null if the renderer could not draw all components\n
     *     of the polygon, or false if nothing could be drawn\n
     */ \n
    drawPolygon: function(node, geometry) {\n
        var d = "";\n
        var draw = true;\n
        var complete = true;\n
        var linearRingResult, path;\n
        for (var j=0, len=geometry.components.length; j<len; j++) {\n
            d += " M";\n
            linearRingResult = this.getComponentsString(\n
                geometry.components[j].components, " ");\n
            path = linearRingResult.path;\n
            if (path) {\n
                d += " " + path;\n
                complete = linearRingResult.complete && complete;\n
            } else {\n
                draw = false;\n
            }\n
        }\n
        d += " z";\n
        if (draw) {\n
            node.setAttributeNS(null, "d", d);\n
            node.setAttributeNS(null, "fill-rule", "evenodd");\n
            return complete ? node : null;\n
        } else {\n
            return false;\n
        }    \n
    },\n
    \n
    /**\n
     * Method: drawRectangle\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or false if the renderer could not draw the rectangle\n
     */ \n
    drawRectangle: function(node, geometry) {\n
        var resolution = this.getResolution();\n
        var x = ((geometry.x - this.featureDx) / resolution + this.left);\n
        var y = (this.top - geometry.y / resolution);\n
\n
        if (this.inValidRange(x, y)) { \n
            node.setAttributeNS(null, "x", x);\n
            node.setAttributeNS(null, "y", y);\n
            node.setAttributeNS(null, "width", geometry.width / resolution);\n
            node.setAttributeNS(null, "height", geometry.height / resolution);\n
            return node;\n
        } else {\n
            return false;\n
        }\n
    },\n
    \n
    /**\n
     * Method: drawText\n
     * This method is only called by the renderer itself.\n
     *\n
     * Parameters:\n
     * featureId - {String}\n
     * style -\n
     * location - {<OpenLayers.Geometry.Point>}\n
     */\n
    drawText: function(featureId, style, location) {\n
        var drawOutline = (!!style.labelOutlineWidth);\n
        // First draw text in halo color and size and overlay the\n
        // normal text afterwards\n
        if (drawOutline) {\n
            var outlineStyle = OpenLayers.Util.extend({}, style);\n
            outlineStyle.fontColor = outlineStyle.labelOutlineColor;\n
            outlineStyle.fontStrokeColor = outlineStyle.labelOutlineColor;\n
            outlineStyle.fontStrokeWidth = style.labelOutlineWidth;\n
            delete outlineStyle.labelOutlineWidth;\n
            this.drawText(featureId, outlineStyle, location);\n
        }\n
\n
        var resolution = this.getResolution();\n
\n
        var x = ((location.x - this.featureDx) / resolution + this.left);\n
        var y = (location.y / resolution - this.top);\n
\n
        var suffix = (drawOutline)?this.LABEL_OUTLINE_SUFFIX:this.LABEL_ID_SUFFIX;\n
        var label = this.nodeFactory(featureId + suffix, "text");\n
\n
        label.setAttributeNS(null, "x", x);\n
        label.setAttributeNS(null, "y", -y);\n
\n
        if (style.fontColor) {\n
            label.setAttributeNS(null, "fill", style.fontColor);\n
        }\n
        if (style.fontStrokeColor) {\n
            label.setAttributeNS(null, "stroke", style.fontStrokeColor);\n
        }\n
        if (style.fontStrokeWidth) {\n
            label.setAttributeNS(null, "stroke-width", style.fontStrokeWidth);\n
        }\n
        if (style.fontOpacity) {\n
            label.setAttributeNS(null, "opacity", style.fontOpacity);\n
        }\n
        if (style.fontFamily) {\n
            label.setAttributeNS(null, "font-family", style.fontFamily);\n
        }\n
        if (style.fontSize) {\n
            label.setAttributeNS(null, "font-size", style.fontSize);\n
        }\n
        if (style.fontWeight) {\n
            label.setAttributeNS(null, "font-weight", style.fontWeight);\n
        }\n
        if (style.fontStyle) {\n
            label.setAttributeNS(null, "font-style", style.fontStyle);\n
        }\n
        if (style.labelSelect === true) {\n
            label.setAttributeNS(null, "pointer-events", "visible");\n
            label._featureId = featureId;\n
        } else {\n
            label.setAttributeNS(null, "pointer-events", "none");\n
        }\n
        var align = style.labelAlign || OpenLayers.Renderer.defaultSymbolizer.labelAlign;\n
        label.setAttributeNS(null, "text-anchor",\n
            OpenLayers.Renderer.SVG.LABEL_ALIGN[align[0]] || "middle");\n
\n
        if (OpenLayers.IS_GECKO === true) {\n
            label.setAttributeNS(null, "dominant-baseline",\n
                OpenLayers.Renderer.SVG.LABEL_ALIGN[align[1]] || "central");\n
        }\n
\n
        var labelRows = style.label.split(\'\\n\');\n
        var numRows = labelRows.length;\n
        while (label.childNodes.length > numRows) {\n
            label.removeChild(label.lastChild);\n
        }\n
        for (var i = 0; i < numRows; i++) {\n
            var tspan = this.nodeFactory(featureId + suffix + "_tspan_" + i, "tspan");\n
            if (style.labelSelect === true) {\n
                tspan._featureId = featureId;\n
                tspan._geometry = location;\n
                tspan._geometryClass = location.CLASS_NAME;\n
            }\n
            if (OpenLayers.IS_GECKO === false) {\n
                tspan.setAttributeNS(null, "baseline-shift",\n
                    OpenLayers.Renderer.SVG.LABEL_VSHIFT[align[1]] || "-35%");\n
            }\n
            tspan.setAttribute("x", x);\n
            if (i == 0) {\n
                var vfactor = OpenLayers.Renderer.SVG.LABEL_VFACTOR[align[1]];\n
                if (vfactor == null) {\n
                     vfactor = -.5;\n
                }\n
                tspan.setAttribute("dy", (vfactor*(numRows-1)) + "em");\n
            } else {\n
                tspan.setAttribute("dy", "1em");\n
            }\n
            tspan.textContent = (labelRows[i] === \'\') ? \' \' : labelRows[i];\n
            if (!tspan.parentNode) {\n
                label.appendChild(tspan);\n
            }\n
        }\n
\n
        if (!label.parentNode) {\n
            this.textRoot.appendChild(label);\n
        }\n
    },\n
    \n
    /** \n
     * Method: getComponentString\n
     * \n
     * Parameters:\n
     * components - {Array(<OpenLayers.Geometry.Point>)} Array of points\n
     * separator - {String} character between coordinate pairs. Defaults to ","\n
     * \n
     * Returns:\n
     * {Object} hash with properties "path" (the string created from the\n
     *     components and "complete" (false if the renderer was unable to\n
     *     draw all components)\n
     */\n
    getComponentsString: function(components, separator) {\n
        var renderCmp = [];\n
        var complete = true;\n
        var len = components.length;\n
        var strings = [];\n
        var str, component;\n
        for(var i=0; i<len; i++) {\n
            component = components[i];\n
            renderCmp.push(component);\n
            str = this.getShortString(component);\n
            if (str) {\n
                strings.push(str);\n
            } else {\n
                // The current component is outside the valid range. Let\'s\n
                // see if the previous or next component is inside the range.\n
                // If so, add the coordinate of the intersection with the\n
                // valid range bounds.\n
                if (i > 0) {\n
                    if (this.getShortString(components[i - 1])) {\n
                        strings.push(this.clipLine(components[i],\n
                            components[i-1]));\n
                    }\n
                }\n
                if (i < len - 1) {\n
                    if (this.getShortString(components[i + 1])) {\n
                        strings.push(this.clipLine(components[i],\n
                            components[i+1]));\n
                    }\n
                }\n
                complete = false;\n
            }\n
        }\n
\n
        return {\n
            path: strings.join(separator || ","),\n
            complete: complete\n
        };\n
    },\n
    \n
    /**\n
     * Method: clipLine\n
     * Given two points (one inside the valid range, and one outside),\n
     * clips the line betweeen the two points so that the new points are both\n
     * inside the valid range.\n
     * \n
     * Parameters:\n
     * badComponent - {<OpenLayers.Geometry.Point>} original geometry of the\n
     *     invalid point\n
     * goodComponent - {<OpenLayers.Geometry.Point>} original geometry of the\n
     *     valid point\n
     * Returns\n
     * {String} the SVG coordinate pair of the clipped point (like\n
     *     getShortString), or an empty string if both passed componets are at\n
     *     the same point.\n
     */\n
    clipLine: function(badComponent, goodComponent) {\n
        if (goodComponent.equals(badComponent)) {\n
            return "";\n
        }\n
        var resolution = this.getResolution();\n
        var maxX = this.MAX_PIXEL - this.translationParameters.x;\n
        var maxY = this.MAX_PIXEL - this.translationParameters.y;\n
        var x1 = (goodComponent.x - this.featureDx) / resolution + this.left;\n
        var y1 = this.top - goodComponent.y / resolution;\n
        var x2 = (badComponent.x - this.featureDx) / resolution + this.left;\n
        var y2 = this.top - badComponent.y / resolution;\n
        var k;\n
        if (x2 < -maxX || x2 > maxX) {\n
            k = (y2 - y1) / (x2 - x1);\n
            x2 = x2 < 0 ? -maxX : maxX;\n
            y2 = y1 + (x2 - x1) * k;\n
        }\n
        if (y2 < -maxY || y2 > maxY) {\n
            k = (x2 - x1) / (y2 - y1);\n
            y2 = y2 < 0 ? -maxY : maxY;\n
            x2 = x1 + (y2 - y1) * k;\n
        }\n
        return x2 + "," + y2;\n
    },\n
\n
    /** \n
     * Method: getShortString\n
     * \n
     * Parameters:\n
     * point - {<OpenLayers.Geometry.Point>}\n
     * \n
     * Returns:\n
     * {String} or false if point is outside the valid range\n
     */\n
    getShortString: function(point) {\n
        var resolution = this.getResolution();\n
        var x = ((point.x - this.featureDx) / resolution + this.left);\n
        var y = (this.top - point.y / resolution);\n
\n
        if (this.inValidRange(x, y)) { \n
            return x + "," + y;\n
        } else {\n
            return false;\n
        }\n
    },\n
    \n
    /**\n
     * Method: getPosition\n
     * Finds the position of an svg node.\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     * \n
     * Returns:\n
     * {Object} hash with x and y properties, representing the coordinates\n
     *     within the svg coordinate system\n
     */\n
    getPosition: function(node) {\n
        return({\n
            x: parseFloat(node.getAttributeNS(null, "cx")),\n
            y: parseFloat(node.getAttributeNS(null, "cy"))\n
        });\n
    },\n
\n
    /**\n
     * Method: importSymbol\n
     * add a new symbol definition from the rendererer\'s symbol hash\n
     * \n
     * Parameters:\n
     * graphicName - {String} name of the symbol to import\n
     * \n
     * Returns:\n
     * {DOMElement} - the imported symbol\n
     */      \n
    importSymbol: function (graphicName)  {\n
        if (!this.defs) {\n
            // create svg defs tag\n
            this.defs = this.createDefs();\n
        }\n
        var id = this.container.id + "-" + graphicName;\n
        \n
        // check if symbol already exists in the defs\n
        var existing = document.getElementById(id);\n
        if (existing != null) {\n
            return existing;\n
        }\n
        \n
        var symbol = OpenLayers.Renderer.symbol[graphicName];\n
        if (!symbol) {\n
            throw new Error(graphicName + \' is not a valid symbol name\');\n
        }\n
\n
        var symbolNode = this.nodeFactory(id, "symbol");\n
        var node = this.nodeFactory(null, "polygon");\n
        symbolNode.appendChild(node);\n
        var symbolExtent = new OpenLayers.Bounds(\n
                                    Number.MAX_VALUE, Number.MAX_VALUE, 0, 0);\n
\n
        var points = [];\n
        var x,y;\n
        for (var i=0; i<symbol.length; i=i+2) {\n
            x = symbol[i];\n
            y = symbol[i+1];\n
            symbolExtent.left = Math.min(symbolExtent.left, x);\n
            symbolExtent.bottom = Math.min(symbolExtent.bottom, y);\n
            symbolExtent.right = Math.max(symbolExtent.right, x);\n
            symbolExtent.top = Math.max(symbolExtent.top, y);\n
            points.push(x, ",", y);\n
        }\n
        \n
        node.setAttributeNS(null, "points", points.join(" "));\n
        \n
        var width = symbolExtent.getWidth();\n
        var height = symbolExtent.getHeight();\n
        // create a viewBox three times as large as the symbol itself,\n
        // to allow for strokeWidth being displayed correctly at the corners.\n
        var viewBox = [symbolExtent.left - width,\n
                        symbolExtent.bottom - height, width * 3, height * 3];\n
        symbolNode.setAttributeNS(null, "viewBox", viewBox.join(" "));\n
        this.symbolMetrics[id] = [\n
            Math.max(width, height),\n
            symbolExtent.getCenterLonLat().lon,\n
            symbolExtent.getCenterLonLat().lat\n
        ];\n
        \n
        this.defs.appendChild(symbolNode);\n
        return symbolNode;\n
    },\n
    \n
    /**\n
     * Method: getFeatureIdFromEvent\n
     * \n
     * Parameters:\n
     * evt - {Object} An <OpenLayers.Event> object\n
     *\n
     * Returns:\n
     * {String} A feature id or undefined.\n
     */\n
    getFeatureIdFromEvent: function(evt) {\n
        var featureId = OpenLayers.Renderer.Elements.prototype.getFeatureIdFromEvent.apply(this, arguments);\n
        if(!featureId) {\n
            var target = evt.target;\n
            featureId = target.parentNode && target != this.rendererRoot ?\n
                target.parentNode._featureId : undefined;\n
        }\n
        return featureId;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Renderer.SVG"\n
});\n
\n
/**\n
 * Constant: OpenLayers.Renderer.SVG.LABEL_ALIGN\n
 * {Object}\n
 */\n
OpenLayers.Renderer.SVG.LABEL_ALIGN = {\n
    "l": "start",\n
    "r": "end",\n
    "b": "bottom",\n
    "t": "hanging"\n
};\n
\n
/**\n
 * Constant: OpenLayers.Renderer.SVG.LABEL_VSHIFT\n
 * {Object}\n
 */\n
OpenLayers.Renderer.SVG.LABEL_VSHIFT = {\n
    // according to\n
    // http://www.w3.org/Graphics/SVG/Test/20061213/htmlObjectHarness/full-text-align-02-b.html\n
    // a baseline-shift of -70% shifts the text exactly from the\n
    // bottom to the top of the baseline, so -35% moves the text to\n
    // the center of the baseline.\n
    "t": "-70%",\n
    "b": "0"    \n
};\n
\n
/**\n
 * Constant: OpenLayers.Renderer.SVG.LABEL_VFACTOR\n
 * {Object}\n
 */\n
OpenLayers.Renderer.SVG.LABEL_VFACTOR = {\n
    "t": 0,\n
    "b": -1\n
};\n
\n
/**\n
 * Function: OpenLayers.Renderer.SVG.preventDefault\n
 * Used to prevent default events (especially opening images in a new tab on\n
 * ctrl-click) from being executed for externalGraphic symbols\n
 */\n
OpenLayers.Renderer.SVG.preventDefault = function(e) {\n
    e.preventDefault && e.preventDefault();\n
};\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>34784</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
