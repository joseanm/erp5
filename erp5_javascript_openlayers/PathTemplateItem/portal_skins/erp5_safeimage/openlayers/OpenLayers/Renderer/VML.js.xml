<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.8</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>VML.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Renderer/Elements.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Renderer.VML\n
 * Render vector features in browsers with VML capability.  Construct a new\n
 * VML renderer with the <OpenLayers.Renderer.VML> constructor.\n
 * \n
 * Note that for all calculations in this class, we use (num | 0) to truncate a \n
 * float value to an integer. This is done because it seems that VML doesn\'t \n
 * support float values.\n
 *\n
 * Inherits from:\n
 *  - <OpenLayers.Renderer.Elements>\n
 */\n
OpenLayers.Renderer.VML = OpenLayers.Class(OpenLayers.Renderer.Elements, {\n
\n
    /**\n
     * Property: xmlns\n
     * {String} XML Namespace URN\n
     */\n
    xmlns: "urn:schemas-microsoft-com:vml",\n
    \n
    /**\n
     * Property: symbolCache\n
     * {DOMElement} node holding symbols. This hash is keyed by symbol name,\n
     *     and each value is a hash with a "path" and an "extent" property.\n
     */\n
    symbolCache: {},\n
\n
    /**\n
     * Property: offset\n
     * {Object} Hash with "x" and "y" properties\n
     */\n
    offset: null,\n
    \n
    /**\n
     * Constructor: OpenLayers.Renderer.VML\n
     * Create a new VML renderer.\n
     *\n
     * Parameters:\n
     * containerID - {String} The id for the element that contains the renderer\n
     */\n
    initialize: function(containerID) {\n
        if (!this.supported()) { \n
            return; \n
        }\n
        if (!document.namespaces.olv) {\n
            document.namespaces.add("olv", this.xmlns);\n
            var style = document.createStyleSheet();\n
            var shapes = [\'shape\',\'rect\', \'oval\', \'fill\', \'stroke\', \'imagedata\', \'group\',\'textbox\']; \n
            for (var i = 0, len = shapes.length; i < len; i++) {\n
\n
                style.addRule(\'olv\\\\:\' + shapes[i], "behavior: url(#default#VML); " +\n
                              "position: absolute; display: inline-block;");\n
            }                  \n
        }\n
        \n
        OpenLayers.Renderer.Elements.prototype.initialize.apply(this, \n
                                                                arguments);\n
    },\n
\n
    /**\n
     * APIMethod: supported\n
     * Determine whether a browser supports this renderer.\n
     *\n
     * Returns:\n
     * {Boolean} The browser supports the VML renderer\n
     */\n
    supported: function() {\n
        return !!(document.namespaces);\n
    },    \n
\n
    /**\n
     * Method: setExtent\n
     * Set the renderer\'s extent\n
     *\n
     * Parameters:\n
     * extent - {<OpenLayers.Bounds>}\n
     * resolutionChanged - {Boolean}\n
     * \n
     * Returns:\n
     * {Boolean} true to notify the layer that the new extent does not exceed\n
     *     the coordinate range, and the features will not need to be redrawn.\n
     */\n
    setExtent: function(extent, resolutionChanged) {\n
        var coordSysUnchanged = OpenLayers.Renderer.Elements.prototype.setExtent.apply(this, arguments);\n
        var resolution = this.getResolution();\n
    \n
        var left = (extent.left/resolution) | 0;\n
        var top = (extent.top/resolution - this.size.h) | 0;\n
        if (resolutionChanged || !this.offset) {\n
            this.offset = {x: left, y: top};\n
            left = 0;\n
            top = 0;\n
        } else {\n
            left = left - this.offset.x;\n
            top = top - this.offset.y;\n
        }\n
\n
        \n
        var org = (left - this.xOffset) + " " + top;\n
        this.root.coordorigin = org;\n
        var roots = [this.root, this.vectorRoot, this.textRoot];\n
        var root;\n
        for(var i=0, len=roots.length; i<len; ++i) {\n
            root = roots[i];\n
\n
            var size = this.size.w + " " + this.size.h;\n
            root.coordsize = size;\n
            \n
        }\n
        // flip the VML display Y axis upside down so it \n
        // matches the display Y axis of the map\n
        this.root.style.flip = "y";\n
        \n
        return coordSysUnchanged;\n
    },\n
\n
\n
    /**\n
     * Method: setSize\n
     * Set the size of the drawing surface\n
     *\n
     * Parameters:\n
     * size - {<OpenLayers.Size>} the size of the drawing surface\n
     */\n
    setSize: function(size) {\n
        OpenLayers.Renderer.prototype.setSize.apply(this, arguments);\n
        \n
        // setting width and height on all roots to avoid flicker which we\n
        // would get with 100% width and height on child roots\n
        var roots = [\n
            this.rendererRoot,\n
            this.root,\n
            this.vectorRoot,\n
            this.textRoot\n
        ];\n
        var w = this.size.w + "px";\n
        var h = this.size.h + "px";\n
        var root;\n
        for(var i=0, len=roots.length; i<len; ++i) {\n
            root = roots[i];\n
            root.style.width = w;\n
            root.style.height = h;\n
        }\n
    },\n
\n
    /**\n
     * Method: getNodeType\n
     * Get the node type for a geometry and style\n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * style - {Object}\n
     *\n
     * Returns:\n
     * {String} The corresponding node type for the specified geometry\n
     */\n
    getNodeType: function(geometry, style) {\n
        var nodeType = null;\n
        switch (geometry.CLASS_NAME) {\n
            case "OpenLayers.Geometry.Point":\n
                if (style.externalGraphic) {\n
                    nodeType = "olv:rect";\n
                } else if (this.isComplexSymbol(style.graphicName)) {\n
                    nodeType = "olv:shape";\n
                } else {\n
                    nodeType = "olv:oval";\n
                }\n
                break;\n
            case "OpenLayers.Geometry.Rectangle":\n
                nodeType = "olv:rect";\n
                break;\n
            case "OpenLayers.Geometry.LineString":\n
            case "OpenLayers.Geometry.LinearRing":\n
            case "OpenLayers.Geometry.Polygon":\n
            case "OpenLayers.Geometry.Curve":\n
                nodeType = "olv:shape";\n
                break;\n
            default:\n
                break;\n
        }\n
        return nodeType;\n
    },\n
\n
    /**\n
     * Method: setStyle\n
     * Use to set all the style attributes to a VML node.\n
     *\n
     * Parameters:\n
     * node - {DOMElement} An VML element to decorate\n
     * style - {Object}\n
     * options - {Object} Currently supported options include \n
     *                              \'isFilled\' {Boolean} and\n
     *                              \'isStroked\' {Boolean}\n
     * geometry - {<OpenLayers.Geometry>}\n
     */\n
    setStyle: function(node, style, options, geometry) {\n
        style = style  || node._style;\n
        options = options || node._options;\n
        var fillColor = style.fillColor;\n
\n
        if (node._geometryClass === "OpenLayers.Geometry.Point") {\n
            if (style.externalGraphic) {\n
                options.isFilled = true;\n
                if (style.graphicTitle) {\n
                    node.title=style.graphicTitle;\n
                } \n
                var width = style.graphicWidth || style.graphicHeight;\n
                var height = style.graphicHeight || style.graphicWidth;\n
                width = width ? width : style.pointRadius*2;\n
                height = height ? height : style.pointRadius*2;\n
\n
                var resolution = this.getResolution();\n
                var xOffset = (style.graphicXOffset != undefined) ?\n
                    style.graphicXOffset : -(0.5 * width);\n
                var yOffset = (style.graphicYOffset != undefined) ?\n
                    style.graphicYOffset : -(0.5 * height);\n
                \n
                node.style.left = ((((geometry.x - this.featureDx)/resolution - this.offset.x)+xOffset) | 0) + "px";\n
                node.style.top = (((geometry.y/resolution - this.offset.y)-(yOffset+height)) | 0) + "px";\n
                node.style.width = width + "px";\n
                node.style.height = height + "px";\n
                node.style.flip = "y";\n
                \n
                // modify fillColor and options for stroke styling below\n
                fillColor = "none";\n
                options.isStroked = false;\n
            } else if (this.isComplexSymbol(style.graphicName)) {\n
                var cache = this.importSymbol(style.graphicName);\n
                node.path = cache.path;\n
                node.coordorigin = cache.left + "," + cache.bottom;\n
                var size = cache.size;\n
                node.coordsize = size + "," + size;        \n
                this.drawCircle(node, geometry, style.pointRadius);\n
                node.style.flip = "y";\n
            } else {\n
                this.drawCircle(node, geometry, style.pointRadius);\n
            }\n
        }\n
\n
        // fill \n
        if (options.isFilled) { \n
            node.fillcolor = fillColor; \n
        } else { \n
            node.filled = "false"; \n
        }\n
        var fills = node.getElementsByTagName("fill");\n
        var fill = (fills.length == 0) ? null : fills[0];\n
        if (!options.isFilled) {\n
            if (fill) {\n
                node.removeChild(fill);\n
            }\n
        } else {\n
            if (!fill) {\n
                fill = this.createNode(\'olv:fill\', node.id + "_fill");\n
            }\n
            fill.opacity = style.fillOpacity;\n
\n
            if (node._geometryClass === "OpenLayers.Geometry.Point" &&\n
                    style.externalGraphic) {\n
\n
                // override fillOpacity\n
                if (style.graphicOpacity) {\n
                    fill.opacity = style.graphicOpacity;\n
                }\n
                \n
                fill.src = style.externalGraphic;\n
                fill.type = "frame";\n
                \n
                if (!(style.graphicWidth && style.graphicHeight)) {\n
                  fill.aspect = "atmost";\n
                }                \n
            }\n
            if (fill.parentNode != node) {\n
                node.appendChild(fill);\n
            }\n
        }\n
\n
        // additional rendering for rotated graphics or symbols\n
        var rotation = style.rotation;\n
        if ((rotation !== undefined || node._rotation !== undefined)) {\n
            node._rotation = rotation;\n
            if (style.externalGraphic) {\n
                this.graphicRotate(node, xOffset, yOffset, style);\n
                // make the fill fully transparent, because we now have\n
                // the graphic as imagedata element. We cannot just remove\n
                // the fill, because this is part of the hack described\n
                // in graphicRotate\n
                fill.opacity = 0;\n
            } else if(node._geometryClass === "OpenLayers.Geometry.Point") {\n
                node.style.rotation = rotation || 0;\n
            }\n
        }\n
\n
        // stroke \n
        var strokes = node.getElementsByTagName("stroke");\n
        var stroke = (strokes.length == 0) ? null : strokes[0];\n
        if (!options.isStroked) {\n
            node.stroked = false;\n
            if (stroke) {\n
                stroke.on = false;\n
            }\n
        } else {\n
            if (!stroke) {\n
                stroke = this.createNode(\'olv:stroke\', node.id + "_stroke");\n
                node.appendChild(stroke);\n
            }\n
            stroke.on = true;\n
            stroke.color = style.strokeColor; \n
            stroke.weight = style.strokeWidth + "px"; \n
            stroke.opacity = style.strokeOpacity;\n
            stroke.endcap = style.strokeLinecap == \'butt\' ? \'flat\' :\n
                (style.strokeLinecap || \'round\');\n
            if (style.strokeDashstyle) {\n
                stroke.dashstyle = this.dashStyle(style);\n
            }\n
        }\n
        \n
        if (style.cursor != "inherit" && style.cursor != null) {\n
            node.style.cursor = style.cursor;\n
        }\n
        return node;\n
    },\n
\n
    /**\n
     * Method: graphicRotate\n
     * If a point is to be styled with externalGraphic and rotation, VML fills\n
     * cannot be used to display the graphic, because rotation of graphic\n
     * fills is not supported by the VML implementation of Internet Explorer.\n
     * This method creates a olv:imagedata element inside the VML node,\n
     * DXImageTransform.Matrix and BasicImage filters for rotation and\n
     * opacity, and a 3-step hack to remove rendering artefacts from the\n
     * graphic and preserve the ability of graphics to trigger events.\n
     * Finally, OpenLayers methods are used to determine the correct\n
     * insertion point of the rotated image, because DXImageTransform.Matrix\n
     * does the rotation without the ability to specify a rotation center\n
     * point.\n
     * \n
     * Parameters:\n
     * node    - {DOMElement}\n
     * xOffset - {Number} rotation center relative to image, x coordinate\n
     * yOffset - {Number} rotation center relative to image, y coordinate\n
     * style   - {Object}\n
     */\n
    graphicRotate: function(node, xOffset, yOffset, style) {\n
        var style = style || node._style;\n
        var rotation = style.rotation || 0;\n
        \n
        var aspectRatio, size;\n
        if (!(style.graphicWidth && style.graphicHeight)) {\n
            // load the image to determine its size\n
            var img = new Image();\n
            img.onreadystatechange = OpenLayers.Function.bind(function() {\n
                if(img.readyState == "complete" ||\n
                        img.readyState == "interactive") {\n
                    aspectRatio = img.width / img.height;\n
                    size = Math.max(style.pointRadius * 2, \n
                        style.graphicWidth || 0,\n
                        style.graphicHeight || 0);\n
                    xOffset = xOffset * aspectRatio;\n
                    style.graphicWidth = size * aspectRatio;\n
                    style.graphicHeight = size;\n
                    this.graphicRotate(node, xOffset, yOffset, style);\n
                }\n
            }, this);\n
            img.src = style.externalGraphic;\n
            \n
            // will be called again by the onreadystate handler\n
            return;\n
        } else {\n
            size = Math.max(style.graphicWidth, style.graphicHeight);\n
            aspectRatio = style.graphicWidth / style.graphicHeight;\n
        }\n
        \n
        var width = Math.round(style.graphicWidth || size * aspectRatio);\n
        var height = Math.round(style.graphicHeight || size);\n
        node.style.width = width + "px";\n
        node.style.height = height + "px";\n
        \n
        // Three steps are required to remove artefacts for images with\n
        // transparent backgrounds (resulting from using DXImageTransform\n
        // filters on svg objects), while preserving awareness for browser\n
        // events on images:\n
        // - Use the fill as usual (like for unrotated images) to handle\n
        //   events\n
        // - specify an imagedata element with the same src as the fill\n
        // - style the imagedata element with an AlphaImageLoader filter\n
        //   with empty src\n
        var image = document.getElementById(node.id + "_image");\n
        if (!image) {\n
            image = this.createNode("olv:imagedata", node.id + "_image");\n
            node.appendChild(image);\n
        }\n
        image.style.width = width + "px";\n
        image.style.height = height + "px";\n
        image.src = style.externalGraphic;\n
        image.style.filter =\n
            "progid:DXImageTransform.Microsoft.AlphaImageLoader(" + \n
            "src=\'\', sizingMethod=\'scale\')";\n
\n
        var rot = rotation * Math.PI / 180;\n
        var sintheta = Math.sin(rot);\n
        var costheta = Math.cos(rot);\n
\n
        // do the rotation on the image\n
        var filter =\n
            "progid:DXImageTransform.Microsoft.Matrix(M11=" + costheta +\n
            ",M12=" + (-sintheta) + ",M21=" + sintheta + ",M22=" + costheta +\n
            ",SizingMethod=\'auto expand\')\\n";\n
\n
        // set the opacity (needed for the imagedata)\n
        var opacity = style.graphicOpacity || style.fillOpacity;\n
        if (opacity && opacity != 1) {\n
            filter += \n
                "progid:DXImageTransform.Microsoft.BasicImage(opacity=" + \n
                opacity+")\\n";\n
        }\n
        node.style.filter = filter;\n
\n
        // do the rotation again on a box, so we know the insertion point\n
        var centerPoint = new OpenLayers.Geometry.Point(-xOffset, -yOffset);\n
        var imgBox = new OpenLayers.Bounds(0, 0, width, height).toGeometry();\n
        imgBox.rotate(style.rotation, centerPoint);\n
        var imgBounds = imgBox.getBounds();\n
\n
        node.style.left = Math.round(\n
            parseInt(node.style.left) + imgBounds.left) + "px";\n
        node.style.top = Math.round(\n
            parseInt(node.style.top) - imgBounds.bottom) + "px";\n
    },\n
\n
    /**\n
     * Method: postDraw\n
     * Does some node postprocessing to work around browser issues:\n
     * - Some versions of Internet Explorer seem to be unable to set fillcolor\n
     *   and strokecolor to "none" correctly before the fill node is appended\n
     *   to a visible vml node. This method takes care of that and sets\n
     *   fillcolor and strokecolor again if needed.\n
     * - In some cases, a node won\'t become visible after being drawn. Setting\n
     *   style.visibility to "visible" works around that.\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     */\n
    postDraw: function(node) {\n
        node.style.visibility = "visible";\n
        var fillColor = node._style.fillColor;\n
        var strokeColor = node._style.strokeColor;\n
        if (fillColor == "none" &&\n
                node.fillcolor != fillColor) {\n
            node.fillcolor = fillColor;\n
        }\n
        if (strokeColor == "none" &&\n
                node.strokecolor != strokeColor) {\n
            node.strokecolor = strokeColor;\n
        }\n
    },\n
\n
\n
    /**\n
     * Method: setNodeDimension\n
     * Get the geometry\'s bounds, convert it to our vml coordinate system, \n
     * then set the node\'s position, size, and local coordinate system.\n
     *   \n
     * Parameters:\n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     */\n
    setNodeDimension: function(node, geometry) {\n
\n
        var bbox = geometry.getBounds();\n
        if(bbox) {\n
            var resolution = this.getResolution();\n
        \n
            var scaledBox = \n
                new OpenLayers.Bounds(((bbox.left - this.featureDx)/resolution - this.offset.x) | 0,\n
                                      (bbox.bottom/resolution - this.offset.y) | 0,\n
                                      ((bbox.right - this.featureDx)/resolution - this.offset.x) | 0,\n
                                      (bbox.top/resolution - this.offset.y) | 0);\n
            \n
            // Set the internal coordinate system to draw the path\n
            node.style.left = scaledBox.left + "px";\n
            node.style.top = scaledBox.top + "px";\n
            node.style.width = scaledBox.getWidth() + "px";\n
            node.style.height = scaledBox.getHeight() + "px";\n
    \n
            node.coordorigin = scaledBox.left + " " + scaledBox.top;\n
            node.coordsize = scaledBox.getWidth()+ " " + scaledBox.getHeight();\n
        }\n
    },\n
    \n
    /** \n
     * Method: dashStyle\n
     * \n
     * Parameters:\n
     * style - {Object}\n
     * \n
     * Returns:\n
     * {String} A VML compliant \'stroke-dasharray\' value\n
     */\n
    dashStyle: function(style) {\n
        var dash = style.strokeDashstyle;\n
        switch (dash) {\n
            case \'solid\':\n
            case \'dot\':\n
            case \'dash\':\n
            case \'dashdot\':\n
            case \'longdash\':\n
            case \'longdashdot\':\n
                return dash;\n
            default:\n
                // very basic guessing of dash style patterns\n
                var parts = dash.split(/[ ,]/);\n
                if (parts.length == 2) {\n
                    if (1*parts[0] >= 2*parts[1]) {\n
                        return "longdash";\n
                    }\n
                    return (parts[0] == 1 || parts[1] == 1) ? "dot" : "dash";\n
                } else if (parts.length == 4) {\n
                    return (1*parts[0] >= 2*parts[1]) ? "longdashdot" :\n
                        "dashdot";\n
                }\n
                return "solid";\n
        }\n
    },\n
\n
    /**\n
     * Method: createNode\n
     * Create a new node\n
     *\n
     * Parameters:\n
     * type - {String} Kind of node to draw\n
     * id - {String} Id for node\n
     *\n
     * Returns:\n
     * {DOMElement} A new node of the given type and id\n
     */\n
    createNode: function(type, id) {\n
        var node = document.createElement(type);\n
        if (id) {\n
            node.id = id;\n
        }\n
        \n
        // IE hack to make elements unselectable, to prevent \'blue flash\'\n
        // while dragging vectors; #1410\n
        node.unselectable = \'on\';\n
        node.onselectstart = OpenLayers.Function.False;\n
        \n
        return node;    \n
    },\n
    \n
    /**\n
     * Method: nodeTypeCompare\n
     * Determine whether a node is of a given type\n
     *\n
     * Parameters:\n
     * node - {DOMElement} An VML element\n
     * type - {String} Kind of node\n
     *\n
     * Returns:\n
     * {Boolean} Whether or not the specified node is of the specified type\n
     */\n
    nodeTypeCompare: function(node, type) {\n
\n
        //split type\n
        var subType = type;\n
        var splitIndex = subType.indexOf(":");\n
        if (splitIndex != -1) {\n
            subType = subType.substr(splitIndex+1);\n
        }\n
\n
        //split nodeName\n
        var nodeName = node.nodeName;\n
        splitIndex = nodeName.indexOf(":");\n
        if (splitIndex != -1) {\n
            nodeName = nodeName.substr(splitIndex+1);\n
        }\n
\n
        return (subType == nodeName);\n
    },\n
\n
    /**\n
     * Method: createRenderRoot\n
     * Create the renderer root\n
     *\n
     * Returns:\n
     * {DOMElement} The specific render engine\'s root element\n
     */\n
    createRenderRoot: function() {\n
        return this.nodeFactory(this.container.id + "_vmlRoot", "div");\n
    },\n
\n
    /**\n
     * Method: createRoot\n
     * Create the main root element\n
     * \n
     * Parameters:\n
     * suffix - {String} suffix to append to the id\n
     *\n
     * Returns:\n
     * {DOMElement}\n
     */\n
    createRoot: function(suffix) {\n
        return this.nodeFactory(this.container.id + suffix, "olv:group");\n
    },\n
    \n
    /**************************************\n
     *                                    *\n
     *     GEOMETRY DRAWING FUNCTIONS     *\n
     *                                    *\n
     **************************************/\n
    \n
    /**\n
     * Method: drawPoint\n
     * Render a point\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement} or false if the point could not be drawn\n
     */\n
    drawPoint: function(node, geometry) {\n
        return this.drawCircle(node, geometry, 1);\n
    },\n
\n
    /**\n
     * Method: drawCircle\n
     * Render a circle.\n
     * Size and Center a circle given geometry (x,y center) and radius\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * radius - {float}\n
     * \n
     * Returns:\n
     * {DOMElement} or false if the circle could not ne drawn\n
     */\n
    drawCircle: function(node, geometry, radius) {\n
        if(!isNaN(geometry.x)&& !isNaN(geometry.y)) {\n
            var resolution = this.getResolution();\n
\n
            node.style.left = ((((geometry.x - this.featureDx) /resolution - this.offset.x) | 0) - radius) + "px";\n
            node.style.top = (((geometry.y /resolution - this.offset.y) | 0) - radius) + "px";\n
    \n
            var diameter = radius * 2;\n
            \n
            node.style.width = diameter + "px";\n
            node.style.height = diameter + "px";\n
            return node;\n
        }\n
        return false;\n
    },\n
\n
\n
    /**\n
     * Method: drawLineString\n
     * Render a linestring.\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    drawLineString: function(node, geometry) {\n
        return this.drawLine(node, geometry, false);\n
    },\n
\n
    /**\n
     * Method: drawLinearRing\n
     * Render a linearring\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    drawLinearRing: function(node, geometry) {\n
        return this.drawLine(node, geometry, true);\n
    },\n
\n
    /**\n
     * Method: DrawLine\n
     * Render a line.\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * closeLine - {Boolean} Close the line? (make it a ring?)\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    drawLine: function(node, geometry, closeLine) {\n
\n
        this.setNodeDimension(node, geometry);\n
\n
        var resolution = this.getResolution();\n
        var numComponents = geometry.components.length;\n
        var parts = new Array(numComponents);\n
\n
        var comp, x, y;\n
        for (var i = 0; i < numComponents; i++) {\n
            comp = geometry.components[i];\n
            x = ((comp.x - this.featureDx)/resolution - this.offset.x) | 0;\n
            y = (comp.y/resolution - this.offset.y) | 0;\n
            parts[i] = " " + x + "," + y + " l ";\n
        }\n
        var end = (closeLine) ? " x e" : " e";\n
        node.path = "m" + parts.join("") + end;\n
        return node;\n
    },\n
\n
    /**\n
     * Method: drawPolygon\n
     * Render a polygon\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    drawPolygon: function(node, geometry) {\n
        this.setNodeDimension(node, geometry);\n
\n
        var resolution = this.getResolution();\n
    \n
        var path = [];\n
        var j, jj, points, area, first, second, i, ii, comp, pathComp, x, y;\n
        for (j=0, jj=geometry.components.length; j<jj; j++) {\n
            path.push("m");\n
            points = geometry.components[j].components;\n
            // we only close paths of interior rings with area\n
            area = (j === 0);\n
            first = null;\n
            second = null;\n
            for (i=0, ii=points.length; i<ii; i++) {\n
                comp = points[i];\n
                x = ((comp.x - this.featureDx) / resolution - this.offset.x) | 0;\n
                y = (comp.y / resolution - this.offset.y) | 0;\n
                pathComp = " " + x + "," + y;\n
                path.push(pathComp);\n
                if (i==0) {\n
                    path.push(" l");\n
                }\n
                if (!area) {\n
                    // IE improperly renders sub-paths that have no area.\n
                    // Instead of checking the area of every ring, we confirm\n
                    // the ring has at least three distinct points.  This does\n
                    // not catch all non-zero area cases, but it greatly improves\n
                    // interior ring digitizing and is a minor performance hit\n
                    // when rendering rings with many points.\n
                    if (!first) {\n
                        first = pathComp;\n
                    } else if (first != pathComp) {\n
                        if (!second) {\n
                            second = pathComp;\n
                        } else if (second != pathComp) {\n
                            // stop looking\n
                            area = true;\n
                        }\n
                    }\n
                }\n
            }\n
            path.push(area ? " x " : " ");\n
        }\n
        path.push("e");\n
        node.path = path.join("");\n
        return node;\n
    },\n
\n
    /**\n
     * Method: drawRectangle\n
     * Render a rectangle\n
     * \n
     * Parameters:\n
     * node - {DOMElement}\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {DOMElement}\n
     */\n
    drawRectangle: function(node, geometry) {\n
        var resolution = this.getResolution();\n
    \n
        node.style.left = (((geometry.x - this.featureDx)/resolution - this.offset.x) | 0) + "px";\n
        node.style.top = ((geometry.y/resolution - this.offset.y) | 0) + "px";\n
        node.style.width = ((geometry.width/resolution) | 0) + "px";\n
        node.style.height = ((geometry.height/resolution) | 0) + "px";\n
        \n
        return node;\n
    },\n
    \n
    /**\n
     * Method: drawText\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * featureId - {String}\n
     * style -\n
     * location - {<OpenLayers.Geometry.Point>}\n
     */\n
    drawText: function(featureId, style, location) {\n
        var label = this.nodeFactory(featureId + this.LABEL_ID_SUFFIX, "olv:rect");\n
        var textbox = this.nodeFactory(featureId + this.LABEL_ID_SUFFIX + "_textbox", "olv:textbox");\n
        \n
        var resolution = this.getResolution();\n
        label.style.left = (((location.x - this.featureDx)/resolution - this.offset.x) | 0) + "px";\n
        label.style.top = ((location.y/resolution - this.offset.y) | 0) + "px";\n
        label.style.flip = "y";\n
\n
        textbox.innerText = style.label;\n
\n
        if (style.cursor != "inherit" && style.cursor != null) {\n
            textbox.style.cursor = style.cursor;\n
        }\n
        if (style.fontColor) {\n
            textbox.style.color = style.fontColor;\n
        }\n
        if (style.fontOpacity) {\n
            textbox.style.filter = \'alpha(opacity=\' + (style.fontOpacity * 100) + \')\';\n
        }\n
        if (style.fontFamily) {\n
            textbox.style.fontFamily = style.fontFamily;\n
        }\n
        if (style.fontSize) {\n
            textbox.style.fontSize = style.fontSize;\n
        }\n
        if (style.fontWeight) {\n
            textbox.style.fontWeight = style.fontWeight;\n
        }\n
        if (style.fontStyle) {\n
            textbox.style.fontStyle = style.fontStyle;\n
        }\n
        if(style.labelSelect === true) {\n
            label._featureId = featureId;\n
            textbox._featureId = featureId;\n
            textbox._geometry = location;\n
            textbox._geometryClass = location.CLASS_NAME;\n
        }\n
        textbox.style.whiteSpace = "nowrap";\n
        // fun with IE: IE7 in standards compliant mode does not display any\n
        // text with a left inset of 0. So we set this to 1px and subtract one\n
        // pixel later when we set label.style.left\n
        textbox.inset = "1px,0px,0px,0px";\n
\n
        if(!label.parentNode) {\n
            label.appendChild(textbox);\n
            this.textRoot.appendChild(label);\n
        }\n
\n
        var align = style.labelAlign || "cm";\n
        if (align.length == 1) {\n
            align += "m";\n
        }\n
        var xshift = textbox.clientWidth *\n
            (OpenLayers.Renderer.VML.LABEL_SHIFT[align.substr(0,1)]);\n
        var yshift = textbox.clientHeight *\n
            (OpenLayers.Renderer.VML.LABEL_SHIFT[align.substr(1,1)]);\n
        label.style.left = parseInt(label.style.left)-xshift-1+"px";\n
        label.style.top = parseInt(label.style.top)+yshift+"px";\n
        \n
    },\n
    \n
    /**\n
     * Method: moveRoot\n
     * moves this renderer\'s root to a different renderer.\n
     * \n
     * Parameters:\n
     * renderer - {<OpenLayers.Renderer>} target renderer for the moved root\n
     * root - {DOMElement} optional root node. To be used when this renderer\n
     *     holds roots from multiple layers to tell this method which one to\n
     *     detach\n
     * \n
     * Returns:\n
     * {Boolean} true if successful, false otherwise\n
     */\n
    moveRoot: function(renderer) {\n
        var layer = this.map.getLayer(renderer.container.id);\n
        if(layer instanceof OpenLayers.Layer.Vector.RootContainer) {\n
            layer = this.map.getLayer(this.container.id);\n
        }\n
        layer && layer.renderer.clear();\n
        OpenLayers.Renderer.Elements.prototype.moveRoot.apply(this, arguments);\n
        layer && layer.redraw();\n
    },\n
    \n
    /**\n
     * Method: importSymbol\n
     * add a new symbol definition from the rendererer\'s symbol hash\n
     * \n
     * Parameters:\n
     * graphicName - {String} name of the symbol to import\n
     * \n
     * Returns:\n
     * {Object} - hash of {DOMElement} "symbol" and {Number} "size"\n
     */      \n
    importSymbol: function (graphicName)  {\n
        var id = this.container.id + "-" + graphicName;\n
        \n
        // check if symbol already exists in the cache\n
        var cache = this.symbolCache[id];\n
        if (cache) {\n
            return cache;\n
        }\n
        \n
        var symbol = OpenLayers.Renderer.symbol[graphicName];\n
        if (!symbol) {\n
            throw new Error(graphicName + \' is not a valid symbol name\');\n
        }\n
\n
        var symbolExtent = new OpenLayers.Bounds(\n
                                    Number.MAX_VALUE, Number.MAX_VALUE, 0, 0);\n
        \n
        var pathitems = ["m"];\n
        for (var i=0; i<symbol.length; i=i+2) {\n
            var x = symbol[i];\n
            var y = symbol[i+1];\n
            symbolExtent.left = Math.min(symbolExtent.left, x);\n
            symbolExtent.bottom = Math.min(symbolExtent.bottom, y);\n
            symbolExtent.right = Math.max(symbolExtent.right, x);\n
            symbolExtent.top = Math.max(symbolExtent.top, y);\n
\n
            pathitems.push(x);\n
            pathitems.push(y);\n
            if (i == 0) {\n
                pathitems.push("l");\n
            }\n
        }\n
        pathitems.push("x e");\n
        var path = pathitems.join(" ");\n
\n
        var diff = (symbolExtent.getWidth() - symbolExtent.getHeight()) / 2;\n
        if(diff > 0) {\n
            symbolExtent.bottom = symbolExtent.bottom - diff;\n
            symbolExtent.top = symbolExtent.top + diff;\n
        } else {\n
            symbolExtent.left = symbolExtent.left + diff;\n
            symbolExtent.right = symbolExtent.right - diff;\n
        }\n
        \n
        cache = {\n
            path: path,\n
            size: symbolExtent.getWidth(), // equals getHeight() now\n
            left: symbolExtent.left,\n
            bottom: symbolExtent.bottom\n
        };\n
        this.symbolCache[id] = cache;\n
        \n
        return cache;\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Renderer.VML"\n
});\n
\n
/**\n
 * Constant: OpenLayers.Renderer.VML.LABEL_SHIFT\n
 * {Object}\n
 */\n
OpenLayers.Renderer.VML.LABEL_SHIFT = {\n
    "l": 0,\n
    "c": .5,\n
    "r": 1,\n
    "t": 0,\n
    "m": .5,\n
    "b": 1\n
};\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>33790</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
