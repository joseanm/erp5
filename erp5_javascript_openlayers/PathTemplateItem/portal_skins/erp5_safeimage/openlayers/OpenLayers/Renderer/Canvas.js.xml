<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.8</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Canvas.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/Renderer.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Renderer.Canvas \n
 * A renderer based on the 2D \'canvas\' drawing element.\n
 * \n
 * Inherits:\n
 *  - <OpenLayers.Renderer>\n
 */\n
OpenLayers.Renderer.Canvas = OpenLayers.Class(OpenLayers.Renderer, {\n
    \n
    /**\n
     * APIProperty: hitDetection\n
     * {Boolean} Allow for hit detection of features.  Default is true.\n
     */\n
    hitDetection: true,\n
    \n
    /**\n
     * Property: hitOverflow\n
     * {Number} The method for converting feature identifiers to color values\n
     *     supports 16777215 sequential values.  Two features cannot be \n
     *     predictably detected if their identifiers differ by more than this\n
     *     value.  The hitOverflow allows for bigger numbers (but the \n
     *     difference in values is still limited).\n
     */\n
    hitOverflow: 0,\n
\n
    /**\n
     * Property: canvas\n
     * {Canvas} The canvas context object.\n
     */\n
    canvas: null, \n
    \n
    /**\n
     * Property: features\n
     * {Object} Internal object of feature/style pairs for use in redrawing the layer.\n
     */\n
    features: null,\n
    \n
    /**\n
     * Property: pendingRedraw\n
     * {Boolean} The renderer needs a redraw call to render features added while\n
     *     the renderer was locked.\n
     */\n
    pendingRedraw: false,\n
    \n
    /**\n
     * Property: cachedSymbolBounds\n
     * {Object} Internal cache of calculated symbol extents.\n
     */\n
    cachedSymbolBounds: {},\n
    \n
    /**\n
     * Constructor: OpenLayers.Renderer.Canvas\n
     *\n
     * Parameters:\n
     * containerID - {<String>}\n
     * options - {Object} Optional properties to be set on the renderer.\n
     */\n
    initialize: function(containerID, options) {\n
        OpenLayers.Renderer.prototype.initialize.apply(this, arguments);\n
        this.root = document.createElement("canvas");\n
        this.container.appendChild(this.root);\n
        this.canvas = this.root.getContext("2d");\n
        this.features = {};\n
        if (this.hitDetection) {\n
            this.hitCanvas = document.createElement("canvas");\n
            this.hitContext = this.hitCanvas.getContext("2d");\n
        }\n
    },\n
    \n
    /**\n
     * Method: setExtent\n
     * Set the visible part of the layer.\n
     *\n
     * Parameters:\n
     * extent - {<OpenLayers.Bounds>}\n
     * resolutionChanged - {Boolean}\n
     *\n
     * Returns:\n
     * {Boolean} true to notify the layer that the new extent does not exceed\n
     *     the coordinate range, and the features will not need to be redrawn.\n
     *     False otherwise.\n
     */\n
    setExtent: function() {\n
        OpenLayers.Renderer.prototype.setExtent.apply(this, arguments);\n
        // always redraw features\n
        return false;\n
    },\n
    \n
    /** \n
     * Method: eraseGeometry\n
     * Erase a geometry from the renderer. Because the Canvas renderer has\n
     *     \'memory\' of the features that it has drawn, we have to remove the\n
     *     feature so it doesn\'t redraw.   \n
     * \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * featureId - {String}\n
     */\n
    eraseGeometry: function(geometry, featureId) {\n
        this.eraseFeatures(this.features[featureId][0]);\n
    },\n
\n
    /**\n
     * APIMethod: supported\n
     * \n
     * Returns:\n
     * {Boolean} Whether or not the browser supports the renderer class\n
     */\n
    supported: function() {\n
        return OpenLayers.CANVAS_SUPPORTED;\n
    },    \n
    \n
    /**\n
     * Method: setSize\n
     * Sets the size of the drawing surface.\n
     *\n
     * Once the size is updated, redraw the canvas.\n
     *\n
     * Parameters:\n
     * size - {<OpenLayers.Size>} \n
     */\n
    setSize: function(size) {\n
        this.size = size.clone();\n
        var root = this.root;\n
        root.style.width = size.w + "px";\n
        root.style.height = size.h + "px";\n
        root.width = size.w;\n
        root.height = size.h;\n
        this.resolution = null;\n
        if (this.hitDetection) {\n
            var hitCanvas = this.hitCanvas;\n
            hitCanvas.style.width = size.w + "px";\n
            hitCanvas.style.height = size.h + "px";\n
            hitCanvas.width = size.w;\n
            hitCanvas.height = size.h;\n
        }\n
    },\n
    \n
    /**\n
     * Method: drawFeature\n
     * Draw the feature. Stores the feature in the features list,\n
     * then redraws the layer. \n
     *\n
     * Parameters:\n
     * feature - {<OpenLayers.Feature.Vector>} \n
     * style - {<Object>} \n
     *\n
     * Returns:\n
     * {Boolean} The feature has been drawn completely.  If the feature has no\n
     *     geometry, undefined will be returned.  If the feature is not rendered\n
     *     for other reasons, false will be returned.\n
     */\n
    drawFeature: function(feature, style) {\n
        var rendered;\n
        if (feature.geometry) {\n
            style = this.applyDefaultSymbolizer(style || feature.style);\n
            // don\'t render if display none or feature outside extent\n
            var bounds = feature.geometry.getBounds();\n
\n
            var worldBounds;\n
            if (this.map.baseLayer && this.map.baseLayer.wrapDateLine) {\n
                worldBounds = this.map.getMaxExtent();\n
            }\n
\n
            var intersects = bounds && bounds.intersectsBounds(this.extent, {worldBounds: worldBounds});\n
\n
            rendered = (style.display !== "none") && !!bounds && intersects;\n
            if (rendered) {\n
                // keep track of what we have rendered for redraw\n
                this.features[feature.id] = [feature, style];\n
            }\n
            else {\n
                // remove from features tracked for redraw\n
                delete(this.features[feature.id]);\n
            }\n
            this.pendingRedraw = true;\n
        }\n
        if (this.pendingRedraw && !this.locked) {\n
            this.redraw();\n
            this.pendingRedraw = false;\n
        }\n
        return rendered;\n
    },\n
\n
    /** \n
     * Method: drawGeometry\n
     * Used when looping (in redraw) over the features; draws\n
     * the canvas. \n
     *\n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>} \n
     * style - {Object} \n
     */\n
    drawGeometry: function(geometry, style, featureId) {\n
        var className = geometry.CLASS_NAME;\n
        if ((className == "OpenLayers.Geometry.Collection") ||\n
            (className == "OpenLayers.Geometry.MultiPoint") ||\n
            (className == "OpenLayers.Geometry.MultiLineString") ||\n
            (className == "OpenLayers.Geometry.MultiPolygon")) {\n
            for (var i = 0; i < geometry.components.length; i++) {\n
                this.drawGeometry(geometry.components[i], style, featureId);\n
            }\n
            return;\n
        }\n
        switch (geometry.CLASS_NAME) {\n
            case "OpenLayers.Geometry.Point":\n
                this.drawPoint(geometry, style, featureId);\n
                break;\n
            case "OpenLayers.Geometry.LineString":\n
                this.drawLineString(geometry, style, featureId);\n
                break;\n
            case "OpenLayers.Geometry.LinearRing":\n
                this.drawLinearRing(geometry, style, featureId);\n
                break;\n
            case "OpenLayers.Geometry.Polygon":\n
                this.drawPolygon(geometry, style, featureId);\n
                break;\n
            default:\n
                break;\n
        }\n
    },\n
\n
    /**\n
     * Method: drawExternalGraphic\n
     * Called to draw External graphics. \n
     * \n
     * Parameters: \n
     * geometry - {<OpenLayers.Geometry>}\n
     * style    - {Object}\n
     * featureId - {String}\n
     */ \n
    drawExternalGraphic: function(geometry, style, featureId) {\n
        var img = new Image();\n
\n
        if (style.graphicTitle) {\n
            img.title = style.graphicTitle;           \n
        }\n
\n
        var width = style.graphicWidth || style.graphicHeight;\n
        var height = style.graphicHeight || style.graphicWidth;\n
        width = width ? width : style.pointRadius * 2;\n
        height = height ? height : style.pointRadius * 2;\n
        var xOffset = (style.graphicXOffset != undefined) ?\n
           style.graphicXOffset : -(0.5 * width);\n
        var yOffset = (style.graphicYOffset != undefined) ?\n
           style.graphicYOffset : -(0.5 * height);\n
\n
        var opacity = style.graphicOpacity || style.fillOpacity;\n
        \n
        var onLoad = function() {\n
            if(!this.features[featureId]) {\n
                return;\n
            }\n
            var pt = this.getLocalXY(geometry);\n
            var p0 = pt[0];\n
            var p1 = pt[1];\n
            if(!isNaN(p0) && !isNaN(p1)) {\n
                var x = (p0 + xOffset) | 0;\n
                var y = (p1 + yOffset) | 0;\n
                var canvas = this.canvas;\n
                canvas.globalAlpha = opacity;\n
                var factor = OpenLayers.Renderer.Canvas.drawImageScaleFactor ||\n
                    (OpenLayers.Renderer.Canvas.drawImageScaleFactor =\n
                        /android 2.1/.test(navigator.userAgent.toLowerCase()) ?\n
                            // 320 is the screen width of the G1 phone, for\n
                            // which drawImage works out of the box.\n
                            320 / window.screen.width : 1\n
                    );\n
                canvas.drawImage(\n
                    img, x*factor, y*factor, width*factor, height*factor\n
                );\n
                if (this.hitDetection) {\n
                    this.setHitContextStyle("fill", featureId);\n
                    this.hitContext.fillRect(x, y, width, height);\n
                }\n
            }\n
        };\n
\n
        img.onload = OpenLayers.Function.bind(onLoad, this);\n
        img.src = style.externalGraphic;\n
    },\n
\n
    /**\n
     * Method: drawNamedSymbol\n
     * Called to draw Well Known Graphic Symbol Name. \n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * geometry - {<OpenLayers.Geometry>}\n
     * style    - {Object}\n
     * featureId - {String}\n
     */ \n
    drawNamedSymbol: function(geometry, style, featureId) {\n
        var x, y, cx, cy, i, symbolBounds, scaling, angle;\n
        var unscaledStrokeWidth;\n
        var deg2rad = Math.PI / 180.0;\n
        \n
        var symbol = OpenLayers.Renderer.symbol[style.graphicName];\n
         \n
        if (!symbol) {\n
            throw new Error(style.graphicName + \' is not a valid symbol name\');\n
        }\n
        \n
        if (!symbol.length || symbol.length < 2) return;\n
        \n
        var pt = this.getLocalXY(geometry);\n
        var p0 = pt[0];\n
        var p1 = pt[1];\n
       \n
        if (isNaN(p0) || isNaN(p1)) return;\n
        \n
        // Use rounded line caps\n
        this.canvas.lineCap = "round";\n
        this.canvas.lineJoin = "round";\n
        \n
        if (this.hitDetection) {\n
            this.hitContext.lineCap = "round";\n
            this.hitContext.lineJoin = "round";\n
        }\n
        \n
        // Scale and rotate symbols, using precalculated bounds whenever possible.\n
        if (style.graphicName in this.cachedSymbolBounds) {\n
            symbolBounds = this.cachedSymbolBounds[style.graphicName];\n
        } else {\n
            symbolBounds = new OpenLayers.Bounds();\n
            for(i = 0; i < symbol.length; i+=2) {\n
                symbolBounds.extend(new OpenLayers.LonLat(symbol[i], symbol[i+1]));\n
            }\n
            this.cachedSymbolBounds[style.graphicName] = symbolBounds;\n
        }\n
        \n
        // Push symbol scaling, translation and rotation onto the transformation stack in reverse order.\n
        // Don\'t forget to apply all canvas transformations to the hitContext canvas as well(!)\n
        this.canvas.save();\n
        if (this.hitDetection) { this.hitContext.save(); }\n
        \n
        // Step 3: place symbol at the desired location\n
        this.canvas.translate(p0,p1);\n
        if (this.hitDetection) { this.hitContext.translate(p0,p1); }\n
        \n
        // Step 2a. rotate the symbol if necessary\n
        angle = deg2rad * style.rotation; // will be NaN when style.rotation is undefined.\n
        if (!isNaN(angle)) {\n
            this.canvas.rotate(angle);\n
            if (this.hitDetection) { this.hitContext.rotate(angle); }\n
        }\n
                \n
        // // Step 2: scale symbol such that pointRadius equals half the maximum symbol dimension.\n
        scaling = 2.0 * style.pointRadius / Math.max(symbolBounds.getWidth(), symbolBounds.getHeight());\n
        this.canvas.scale(scaling,scaling);\n
        if (this.hitDetection) { this.hitContext.scale(scaling,scaling); }\n
        \n
        // Step 1: center the symbol at the origin        \n
        cx = symbolBounds.getCenterLonLat().lon;\n
        cy = symbolBounds.getCenterLonLat().lat;\n
        this.canvas.translate(-cx,-cy);\n
        if (this.hitDetection) { this.hitContext.translate(-cx,-cy); }        \n
\n
        // Don\'t forget to scale stroke widths, because they are affected by canvas scale transformations as well(!)\n
        // Alternative: scale symbol coordinates manually, so stroke width scaling is not needed anymore.\n
        unscaledStrokeWidth = style.strokeWidth;\n
        style.strokeWidth = unscaledStrokeWidth / scaling;\n
            \n
        if (style.fill !== false) {\n
            this.setCanvasStyle("fill", style);\n
            this.canvas.beginPath();\n
            for (i=0; i<symbol.length; i=i+2) {\n
                x = symbol[i];\n
                y = symbol[i+1];\n
                if (i == 0) this.canvas.moveTo(x,y);\n
                this.canvas.lineTo(x,y);\n
            }\n
            this.canvas.closePath();\n
            this.canvas.fill();\n
\n
            if (this.hitDetection) {\n
                this.setHitContextStyle("fill", featureId, style);\n
                this.hitContext.beginPath();\n
                for (i=0; i<symbol.length; i=i+2) {\n
                    x = symbol[i];\n
                    y = symbol[i+1];\n
                    if (i == 0) this.canvas.moveTo(x,y);\n
                    this.hitContext.lineTo(x,y);\n
                }\n
                this.hitContext.closePath();\n
                this.hitContext.fill();\n
            }\n
        }  \n
        \n
        if (style.stroke !== false) {\n
            this.setCanvasStyle("stroke", style);\n
            this.canvas.beginPath();\n
            for (i=0; i<symbol.length; i=i+2) {\n
                x = symbol[i];\n
                y = symbol[i+1];\n
                if (i == 0) this.canvas.moveTo(x,y);\n
                this.canvas.lineTo(x,y);\n
            }\n
            this.canvas.closePath();\n
            this.canvas.stroke();\n
            \n
            \n
            if (this.hitDetection) {\n
                this.setHitContextStyle("stroke", featureId, style, scaling);\n
                this.hitContext.beginPath();\n
                for (i=0; i<symbol.length; i=i+2) {\n
                    x = symbol[i];\n
                    y = symbol[i+1];\n
                    if (i == 0) this.hitContext.moveTo(x,y);\n
                    this.hitContext.lineTo(x,y);\n
                }\n
                this.hitContext.closePath();\n
                this.hitContext.stroke();\n
            }\n
            \n
        }\n
        \n
        style.strokeWidth = unscaledStrokeWidth;\n
        this.canvas.restore();\n
        if (this.hitDetection) { this.hitContext.restore(); }\n
        this.setCanvasStyle("reset");  \n
    },\n
\n
    /**\n
     * Method: setCanvasStyle\n
     * Prepare the canvas for drawing by setting various global settings.\n
     *\n
     * Parameters:\n
     * type - {String} one of \'stroke\', \'fill\', or \'reset\'\n
     * style - {Object} Symbolizer hash\n
     */\n
    setCanvasStyle: function(type, style) {\n
        if (type === "fill") {     \n
            this.canvas.globalAlpha = style[\'fillOpacity\'];\n
            this.canvas.fillStyle = style[\'fillColor\'];\n
        } else if (type === "stroke") {  \n
            this.canvas.globalAlpha = style[\'strokeOpacity\'];\n
            this.canvas.strokeStyle = style[\'strokeColor\'];\n
            this.canvas.lineWidth = style[\'strokeWidth\'];\n
        } else {\n
            this.canvas.globalAlpha = 0;\n
            this.canvas.lineWidth = 1;\n
        }\n
    },\n
    \n
    /**\n
     * Method: featureIdToHex\n
     * Convert a feature ID string into an RGB hex string.\n
     *\n
     * Parameters:\n
     * featureId - {String} Feature id\n
     *\n
     * Returns:\n
     * {String} RGB hex string.\n
     */\n
    featureIdToHex: function(featureId) {\n
        var id = Number(featureId.split("_").pop()) + 1; // zero for no feature\n
        if (id >= 16777216) {\n
            this.hitOverflow = id - 16777215;\n
            id = id % 16777216 + 1;\n
        }\n
        var hex = "000000" + id.toString(16);\n
        var len = hex.length;\n
        hex = "#" + hex.substring(len-6, len);\n
        return hex;\n
    },\n
    \n
    /**\n
     * Method: setHitContextStyle\n
     * Prepare the hit canvas for drawing by setting various global settings.\n
     *\n
     * Parameters:\n
     * type - {String} one of \'stroke\', \'fill\', or \'reset\'\n
     * featureId - {String} The feature id.\n
     * symbolizer - {<OpenLayers.Symbolizer>} The symbolizer.\n
     */\n
    setHitContextStyle: function(type, featureId, symbolizer, strokeScaling) {\n
        var hex = this.featureIdToHex(featureId);\n
        if (type == "fill") {\n
            this.hitContext.globalAlpha = 1.0;\n
            this.hitContext.fillStyle = hex;\n
        } else if (type == "stroke") {  \n
            this.hitContext.globalAlpha = 1.0;\n
            this.hitContext.strokeStyle = hex;\n
            // bump up stroke width to deal with antialiasing. If strokeScaling is defined, we\'re rendering a symbol \n
            // on a transformed canvas, so the antialias width bump has to scale as well.\n
            if (typeof strokeScaling === "undefined") {\n
                this.hitContext.lineWidth = symbolizer.strokeWidth + 2;\n
            } else {\n
                if (!isNaN(strokeScaling)) { this.hitContext.lineWidth = symbolizer.strokeWidth + 2.0 / strokeScaling; }\n
            }\n
        } else {\n
            this.hitContext.globalAlpha = 0;\n
            this.hitContext.lineWidth = 1;\n
        }\n
    },\n
\n
    /**\n
     * Method: drawPoint\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * geometry - {<OpenLayers.Geometry>}\n
     * style    - {Object}\n
     * featureId - {String}\n
     */ \n
    drawPoint: function(geometry, style, featureId) {\n
        if(style.graphic !== false) {\n
            if(style.externalGraphic) {\n
                this.drawExternalGraphic(geometry, style, featureId);\n
            } else if (style.graphicName && (style.graphicName != "circle")) {\n
                this.drawNamedSymbol(geometry, style, featureId);\n
            } else {\n
                var pt = this.getLocalXY(geometry);\n
                var p0 = pt[0];\n
                var p1 = pt[1];\n
                if(!isNaN(p0) && !isNaN(p1)) {\n
                    var twoPi = Math.PI*2;\n
                    var radius = style.pointRadius;\n
                    if(style.fill !== false) {\n
                        this.setCanvasStyle("fill", style);\n
                        this.canvas.beginPath();\n
                        this.canvas.arc(p0, p1, radius, 0, twoPi, true);\n
                        this.canvas.fill();\n
                        if (this.hitDetection) {\n
                            this.setHitContextStyle("fill", featureId, style);\n
                            this.hitContext.beginPath();\n
                            this.hitContext.arc(p0, p1, radius, 0, twoPi, true);\n
                            this.hitContext.fill();\n
                        }\n
                    }\n
\n
                    if(style.stroke !== false) {\n
                        this.setCanvasStyle("stroke", style);\n
                        this.canvas.beginPath();\n
                        this.canvas.arc(p0, p1, radius, 0, twoPi, true);\n
                        this.canvas.stroke();\n
                        if (this.hitDetection) {\n
                            this.setHitContextStyle("stroke", featureId, style);\n
                            this.hitContext.beginPath();\n
                            this.hitContext.arc(p0, p1, radius, 0, twoPi, true);\n
                            this.hitContext.stroke();\n
                        }\n
                        this.setCanvasStyle("reset");\n
                    }\n
                }\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: drawLineString\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * geometry - {<OpenLayers.Geometry>}\n
     * style    - {Object}\n
     * featureId - {String}\n
     */ \n
    drawLineString: function(geometry, style, featureId) {\n
        style = OpenLayers.Util.applyDefaults({fill: false}, style);\n
        this.drawLinearRing(geometry, style, featureId);\n
    },    \n
    \n
    /**\n
     * Method: drawLinearRing\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * geometry - {<OpenLayers.Geometry>}\n
     * style    - {Object}\n
     * featureId - {String}\n
     */ \n
    drawLinearRing: function(geometry, style, featureId) {\n
        if (style.fill !== false) {\n
            this.setCanvasStyle("fill", style);\n
            this.renderPath(this.canvas, geometry, style, featureId, "fill");\n
            if (this.hitDetection) {\n
                this.setHitContextStyle("fill", featureId, style);\n
                this.renderPath(this.hitContext, geometry, style, featureId, "fill");\n
            }\n
        }\n
        if (style.stroke !== false) {\n
            this.setCanvasStyle("stroke", style);\n
            this.renderPath(this.canvas, geometry, style, featureId, "stroke");\n
            if (this.hitDetection) {\n
                this.setHitContextStyle("stroke", featureId, style);\n
                this.renderPath(this.hitContext, geometry, style, featureId, "stroke");\n
            }\n
        }\n
        this.setCanvasStyle("reset");\n
    },\n
    \n
    /**\n
     * Method: renderPath\n
     * Render a path with stroke and optional fill.\n
     */\n
    renderPath: function(context, geometry, style, featureId, type) {\n
        var components = geometry.components;\n
        var len = components.length;\n
        context.beginPath();\n
        var start = this.getLocalXY(components[0]);\n
        var x = start[0];\n
        var y = start[1];\n
        if (!isNaN(x) && !isNaN(y)) {\n
            context.moveTo(start[0], start[1]);\n
            for (var i=1; i<len; ++i) {\n
                var pt = this.getLocalXY(components[i]);\n
                context.lineTo(pt[0], pt[1]);\n
            }\n
            if (type === "fill") {\n
                context.fill();\n
            } else {\n
                context.stroke();\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: drawPolygon\n
     * This method is only called by the renderer itself.\n
     * \n
     * Parameters: \n
     * geometry - {<OpenLayers.Geometry>}\n
     * style    - {Object}\n
     * featureId - {String}\n
     */ \n
    drawPolygon: function(geometry, style, featureId) {\n
        var components = geometry.components;\n
        var len = components.length;\n
        this.drawLinearRing(components[0], style, featureId);\n
        // erase inner rings\n
        for (var i=1; i<len; ++i) {\n
            /** \n
             * Note that this is overly agressive.  Here we punch holes through \n
             * all previously rendered features on the same canvas.  A better \n
             * solution for polygons with interior rings would be to draw the \n
             * polygon on a sketch canvas first.  We could erase all holes \n
             * there and then copy the drawing to the layer canvas. \n
             * TODO: http://trac.osgeo.org/openlayers/ticket/3130 \n
             */\n
            this.canvas.globalCompositeOperation = "destination-out";\n
            if (this.hitDetection) {\n
                this.hitContext.globalCompositeOperation = "destination-out";\n
            }\n
            this.drawLinearRing(\n
                components[i], \n
                OpenLayers.Util.applyDefaults({stroke: false, fillOpacity: 1.0}, style),\n
                featureId\n
            );\n
            this.canvas.globalCompositeOperation = "source-over";\n
            if (this.hitDetection) {\n
                this.hitContext.globalCompositeOperation = "source-over";\n
            }\n
            this.drawLinearRing(\n
                components[i], \n
                OpenLayers.Util.applyDefaults({fill: false}, style),\n
                featureId\n
            );\n
        }\n
    },\n
    \n
    /**\n
     * Method: drawText\n
     * This method is only called by the renderer itself.\n
     *\n
     * Parameters:\n
     * location - {<OpenLayers.Point>}\n
     * style    - {Object}\n
     */\n
    drawText: function(location, style) {\n
        var pt = this.getLocalXY(location);\n
\n
        this.setCanvasStyle("reset");\n
        this.canvas.fillStyle = style.fontColor;\n
        this.canvas.globalAlpha = style.fontOpacity || 1.0;\n
        var fontStyle = [style.fontStyle ? style.fontStyle : "normal",\n
                         "normal", // "font-variant" not supported\n
                         style.fontWeight ? style.fontWeight : "normal",\n
                         style.fontSize ? style.fontSize : "1em",\n
                         style.fontFamily ? style.fontFamily : "sans-serif"].join(" ");\n
        var labelRows = style.label.split(\'\\n\');\n
        var numRows = labelRows.length;\n
        if (this.canvas.fillText) {\n
            // HTML5\n
            this.canvas.font = fontStyle;\n
            this.canvas.textAlign =\n
                OpenLayers.Renderer.Canvas.LABEL_ALIGN[style.labelAlign[0]] ||\n
                "center";\n
            this.canvas.textBaseline =\n
                OpenLayers.Renderer.Canvas.LABEL_ALIGN[style.labelAlign[1]] ||\n
                "middle";\n
            var vfactor =\n
                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];\n
            if (vfactor == null) {\n
                vfactor = -.5;\n
            }\n
            var lineHeight =\n
                this.canvas.measureText(\'Mg\').height ||\n
                this.canvas.measureText(\'xx\').width;\n
            pt[1] += lineHeight*vfactor*(numRows-1);\n
            for (var i = 0; i < numRows; i++) {\n
                if (style.labelOutlineWidth) {\n
                    this.canvas.save();\n
                    this.canvas.strokeStyle = style.labelOutlineColor;\n
                    this.canvas.lineWidth = style.labelOutlineWidth;\n
                    this.canvas.strokeText(labelRows[i], pt[0], pt[1] + (lineHeight*i) + 1);\n
                    this.canvas.restore();\n
                }\n
                this.canvas.fillText(labelRows[i], pt[0], pt[1] + (lineHeight*i));\n
            }\n
        } else if (this.canvas.mozDrawText) {\n
            // Mozilla pre-Gecko1.9.1 (<FF3.1)\n
            this.canvas.mozTextStyle = fontStyle;\n
            // No built-in text alignment, so we measure and adjust the position\n
            var hfactor =\n
                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[0]];\n
            if (hfactor == null) {\n
                hfactor = -.5;\n
            }\n
            var vfactor =\n
                OpenLayers.Renderer.Canvas.LABEL_FACTOR[style.labelAlign[1]];\n
            if (vfactor == null) {\n
                vfactor = -.5;\n
            }\n
            var lineHeight = this.canvas.mozMeasureText(\'xx\');\n
            pt[1] += lineHeight*(1 + (vfactor*numRows));\n
            for (var i = 0; i < numRows; i++) {\n
                var x = pt[0] + (hfactor*this.canvas.mozMeasureText(labelRows[i]));\n
                var y = pt[1] + (i*lineHeight);\n
                this.canvas.translate(x, y);\n
                this.canvas.mozDrawText(labelRows[i]);\n
                this.canvas.translate(-x, -y);\n
            }\n
        }\n
        this.setCanvasStyle("reset");\n
    },\n
    \n
    /**\n
     * Method: getLocalXY\n
     * transform geographic xy into pixel xy\n
     *\n
     * Parameters: \n
     * point - {<OpenLayers.Geometry.Point>}\n
     */\n
    getLocalXY: function(point) {\n
        var resolution = this.getResolution();\n
        var extent = this.extent;\n
        var x = ((point.x - this.featureDx) / resolution + (-extent.left / resolution));\n
        var y = ((extent.top / resolution) - point.y / resolution);\n
        return [x, y];\n
    },\n
\n
    /**\n
     * Method: clear\n
     * Clear all vectors from the renderer.\n
     */    \n
    clear: function() {\n
        var height = this.root.height;\n
        var width = this.root.width;\n
        this.canvas.clearRect(0, 0, width, height);\n
        this.features = {};\n
        if (this.hitDetection) {\n
            this.hitContext.clearRect(0, 0, width, height);\n
        }\n
    },\n
\n
    /**\n
     * Method: getFeatureIdFromEvent\n
     * Returns a feature id from an event on the renderer.  \n
     * \n
     * Parameters:\n
     * evt - {<OpenLayers.Event>} \n
     *\n
     * Returns:\n
     * {<OpenLayers.Feature.Vector} A feature or undefined.  This method returns a \n
     *     feature instead of a feature id to avoid an unnecessary lookup on the\n
     *     layer.\n
     */\n
    getFeatureIdFromEvent: function(evt) {\n
        var featureId, feature;\n
        \n
        if (this.hitDetection && this.root.style.display !== "none") {\n
            // this dragging check should go in the feature handler\n
            if (!this.map.dragging) {\n
                var xy = evt.xy;\n
                var x = xy.x | 0;\n
                var y = xy.y | 0;\n
                var data = this.hitContext.getImageData(x, y, 1, 1).data;\n
                if (data[3] === 255) { // antialiased\n
                    var id = data[2] + (256 * (data[1] + (256 * data[0])));\n
                    if (id) {\n
                        featureId = "OpenLayers.Feature.Vector_" + (id - 1 + this.hitOverflow);\n
                        try {\n
                            feature = this.features[featureId][0];\n
                        } catch(err) {\n
                            // Because of antialiasing on the canvas, when the hit location is at a point where the edge of\n
                            // one symbol intersects the interior of another symbol, a wrong hit color (and therefore id) results.\n
                            // todo: set Antialiasing = \'off\' on the hitContext as soon as browsers allow it.\n
                        }\n
                    }\n
                }\n
            }\n
        }\n
        return feature;\n
    },\n
    \n
    /**\n
     * Method: eraseFeatures \n
     * This is called by the layer to erase features; removes the feature from\n
     *     the list, then redraws the layer.\n
     * \n
     * Parameters:\n
     * features - {Array(<OpenLayers.Feature.Vector>)} \n
     */\n
    eraseFeatures: function(features) {\n
        if(!(OpenLayers.Util.isArray(features))) {\n
            features = [features];\n
        }\n
        for(var i=0; i<features.length; ++i) {\n
            delete this.features[features[i].id];\n
        }\n
        this.redraw();\n
    },\n
\n
    /**\n
     * Method: redraw\n
     * The real \'meat\' of the function: any time things have changed,\n
     *     redraw() can be called to loop over all the data and (you guessed\n
     *     it) redraw it.  Unlike Elements-based Renderers, we can\'t interact\n
     *     with things once they\'re drawn, to remove them, for example, so\n
     *     instead we have to just clear everything and draw from scratch.\n
     */\n
    redraw: function() {\n
        if (!this.locked) {\n
            var height = this.root.height;\n
            var width = this.root.width;\n
            this.canvas.clearRect(0, 0, width, height);\n
            if (this.hitDetection) {\n
                this.hitContext.clearRect(0, 0, width, height);\n
            }\n
            var labelMap = [];\n
            var feature, geometry, style;\n
            var worldBounds = (this.map.baseLayer && this.map.baseLayer.wrapDateLine) && this.map.getMaxExtent();\n
            for (var id in this.features) {\n
                if (!this.features.hasOwnProperty(id)) { continue; }\n
                feature = this.features[id][0];\n
                geometry = feature.geometry;\n
                this.calculateFeatureDx(geometry.getBounds(), worldBounds);\n
                style = this.features[id][1];\n
                this.drawGeometry(geometry, style, feature.id);\n
                if(style.label) {\n
                    labelMap.push([feature, style]);\n
                }\n
            }\n
            var item;\n
            for (var i=0, len=labelMap.length; i<len; ++i) {\n
                item = labelMap[i];\n
                this.drawText(item[0].geometry.getCentroid(), item[1]);\n
            }\n
        }    \n
    },\n
\n
    CLASS_NAME: "OpenLayers.Renderer.Canvas"\n
});\n
\n
/**\n
 * Constant: OpenLayers.Renderer.Canvas.LABEL_ALIGN\n
 * {Object}\n
 */\n
OpenLayers.Renderer.Canvas.LABEL_ALIGN = {\n
    "l": "left",\n
    "r": "right",\n
    "t": "top",\n
    "b": "bottom"\n
};\n
\n
/**\n
 * Constant: OpenLayers.Renderer.Canvas.LABEL_FACTOR\n
 * {Object}\n
 */\n
OpenLayers.Renderer.Canvas.LABEL_FACTOR = {\n
    "l": 0,\n
    "r": -1,\n
    "t": 0,\n
    "b": -1\n
};\n
\n
/**\n
 * Constant: OpenLayers.Renderer.Canvas.drawImageScaleFactor\n
 * {Number} Scale factor to apply to the canvas drawImage arguments. This\n
 *     is always 1 except for Android 2.1 devices, to work around\n
 *     http://code.google.com/p/android/issues/detail?id=5141.\n
 */\n
OpenLayers.Renderer.Canvas.drawImageScaleFactor = null;\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>33022</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
