<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.76</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Layer.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/BaseTypes/Class.js\n
 * @requires OpenLayers/Map.js\n
 * @requires OpenLayers/Projection.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Layer\n
 */\n
OpenLayers.Layer = OpenLayers.Class({\n
\n
    /**\n
     * APIProperty: id\n
     * {String}\n
     */\n
    id: null,\n
\n
    /** \n
     * APIProperty: name\n
     * {String}\n
     */\n
    name: null,\n
\n
    /** \n
     * APIProperty: div\n
     * {DOMElement}\n
     */\n
    div: null,\n
\n
    /**\n
     * APIProperty: opacity\n
     * {Float} The layer\'s opacity. Float number between 0.0 and 1.0. Default\n
     * is 1.\n
     */\n
    opacity: 1,\n
\n
    /**\n
     * APIProperty: alwaysInRange\n
     * {Boolean} If a layer\'s display should not be scale-based, this should \n
     *     be set to true. This will cause the layer, as an overlay, to always \n
     *     be \'active\', by always returning true from the calculateInRange() \n
     *     function. \n
     * \n
     *     If not explicitly specified for a layer, its value will be \n
     *     determined on startup in initResolutions() based on whether or not \n
     *     any scale-specific properties have been set as options on the \n
     *     layer. If no scale-specific options have been set on the layer, we \n
     *     assume that it should always be in range.\n
     * \n
     *     See #987 for more info.\n
     */\n
    alwaysInRange: null,   \n
\n
    /**\n
     * Constant: RESOLUTION_PROPERTIES\n
     * {Array} The properties that are used for calculating resolutions\n
     *     information.\n
     */\n
    RESOLUTION_PROPERTIES: [\n
        \'scales\', \'resolutions\',\n
        \'maxScale\', \'minScale\',\n
        \'maxResolution\', \'minResolution\',\n
        \'numZoomLevels\', \'maxZoomLevel\'\n
    ],\n
\n
    /**\n
     * APIProperty: events\n
     * {<OpenLayers.Events>}\n
     *\n
     * Register a listener for a particular event with the following syntax:\n
     * (code)\n
     * layer.events.register(type, obj, listener);\n
     * (end)\n
     *\n
     * Listeners will be called with a reference to an event object.  The\n
     *     properties of this event depends on exactly what happened.\n
     *\n
     * All event objects have at least the following properties:\n
     * object - {Object} A reference to layer.events.object.\n
     * element - {DOMElement} A reference to layer.events.element.\n
     *\n
     * Supported map event types:\n
     * loadstart - Triggered when layer loading starts.\n
     * loadend - Triggered when layer loading ends.\n
     * visibilitychanged - Triggered when layer visibility is changed.\n
     * move - Triggered when layer moves (triggered with every mousemove\n
     *     during a drag).\n
     * moveend - Triggered when layer is done moving, object passed as\n
     *     argument has a zoomChanged boolean property which tells that the\n
     *     zoom has changed.\n
     * added - Triggered after the layer is added to a map.  Listeners will\n
     *     receive an object with a *map* property referencing the map and a\n
     *     *layer* property referencing the layer.\n
     * removed - Triggered after the layer is removed from the map.  Listeners\n
     *     will receive an object with a *map* property referencing the map and\n
     *     a *layer* property referencing the layer.\n
     */\n
    events: null,\n
\n
    /**\n
     * APIProperty: map\n
     * {<OpenLayers.Map>} This variable is set when the layer is added to \n
     *     the map, via the accessor function setMap().\n
     */\n
    map: null,\n
    \n
    /**\n
     * APIProperty: isBaseLayer\n
     * {Boolean} Whether or not the layer is a base layer. This should be set \n
     *     individually by all subclasses. Default is false\n
     */\n
    isBaseLayer: false,\n
 \n
    /**\n
     * Property: alpha\n
     * {Boolean} The layer\'s images have an alpha channel.  Default is false. \n
     */\n
    alpha: false,\n
\n
    /** \n
     * APIProperty: displayInLayerSwitcher\n
     * {Boolean} Display the layer\'s name in the layer switcher.  Default is\n
     *     true.\n
     */\n
    displayInLayerSwitcher: true,\n
\n
    /**\n
     * APIProperty: visibility\n
     * {Boolean} The layer should be displayed in the map.  Default is true.\n
     */\n
    visibility: true,\n
\n
    /**\n
     * APIProperty: attribution\n
     * {String} Attribution string, displayed when an \n
     *     <OpenLayers.Control.Attribution> has been added to the map.\n
     */\n
    attribution: null, \n
\n
    /** \n
     * Property: inRange\n
     * {Boolean} The current map resolution is within the layer\'s min/max \n
     *     range. This is set in <OpenLayers.Map.setCenter> whenever the zoom \n
     *     changes.\n
     */\n
    inRange: false,\n
    \n
    /**\n
     * Propery: imageSize\n
     * {<OpenLayers.Size>} For layers with a gutter, the image is larger than \n
     *     the tile by twice the gutter in each dimension.\n
     */\n
    imageSize: null,\n
    \n
  // OPTIONS\n
\n
    /** \n
     * Property: options\n
     * {Object} An optional object whose properties will be set on the layer.\n
     *     Any of the layer properties can be set as a property of the options\n
     *     object and sent to the constructor when the layer is created.\n
     */\n
    options: null,\n
\n
    /**\n
     * APIProperty: eventListeners\n
     * {Object} If set as an option at construction, the eventListeners\n
     *     object will be registered with <OpenLayers.Events.on>.  Object\n
     *     structure must be a listeners object as shown in the example for\n
     *     the events.on method.\n
     */\n
    eventListeners: null,\n
\n
    /**\n
     * APIProperty: gutter\n
     * {Integer} Determines the width (in pixels) of the gutter around image\n
     *     tiles to ignore.  By setting this property to a non-zero value,\n
     *     images will be requested that are wider and taller than the tile\n
     *     size by a value of 2 x gutter.  This allows artifacts of rendering\n
     *     at tile edges to be ignored.  Set a gutter value that is equal to\n
     *     half the size of the widest symbol that needs to be displayed.\n
     *     Defaults to zero.  Non-tiled layers always have zero gutter.\n
     */ \n
    gutter: 0, \n
\n
    /**\n
     * APIProperty: projection\n
     * {<OpenLayers.Projection>} or {<String>} Specifies the projection of the layer.\n
     *     Can be set in the layer options. If not specified in the layer options,\n
     *     it is set to the default projection specified in the map,\n
     *     when the layer is added to the map.\n
     *     Projection along with default maxExtent and resolutions\n
     *     are set automatically with commercial baselayers in EPSG:3857,\n
     *     such as Google, Bing and OpenStreetMap, and do not need to be specified.\n
     *     Otherwise, if specifying projection, also set maxExtent,\n
     *     maxResolution or resolutions as appropriate.\n
     *     When using vector layers with strategies, layer projection should be set\n
     *     to the projection of the source data if that is different from the map default.\n
     * \n
     *     Can be either a string or an <OpenLayers.Projection> object;\n
     *     if a string is passed, will be converted to an object when\n
     *     the layer is added to the map.\n
     * \n
     */\n
    projection: null,    \n
    \n
    /**\n
     * APIProperty: units\n
     * {String} The layer map units.  Defaults to null.  Possible values\n
     *     are \'degrees\' (or \'dd\'), \'m\', \'ft\', \'km\', \'mi\', \'inches\'.\n
     *     Normally taken from the projection.\n
     *     Only required if both map and layers do not define a projection,\n
     *     or if they define a projection which does not define units.\n
     */\n
    units: null,\n
\n
    /**\n
     * APIProperty: scales\n
     * {Array}  An array of map scales in descending order.  The values in the\n
     *     array correspond to the map scale denominator.  Note that these\n
     *     values only make sense if the display (monitor) resolution of the\n
     *     client is correctly guessed by whomever is configuring the\n
     *     application.  In addition, the units property must also be set.\n
     *     Use <resolutions> instead wherever possible.\n
     */\n
    scales: null,\n
\n
    /**\n
     * APIProperty: resolutions\n
     * {Array} A list of map resolutions (map units per pixel) in descending\n
     *     order.  If this is not set in the layer constructor, it will be set\n
     *     based on other resolution related properties (maxExtent,\n
     *     maxResolution, maxScale, etc.).\n
     */\n
    resolutions: null,\n
    \n
    /**\n
     * APIProperty: maxExtent\n
     * {<OpenLayers.Bounds>|Array} If provided as an array, the array\n
     *     should consist of four values (left, bottom, right, top).\n
     *     The maximum extent for the layer.  Defaults to null.\n
     * \n
     *     The center of these bounds will not stray outside\n
     *     of the viewport extent during panning.  In addition, if\n
     *     <displayOutsideMaxExtent> is set to false, data will not be\n
     *     requested that falls completely outside of these bounds.\n
     */\n
    maxExtent: null,\n
    \n
    /**\n
     * APIProperty: minExtent\n
     * {<OpenLayers.Bounds>|Array} If provided as an array, the array\n
     *     should consist of four values (left, bottom, right, top).\n
     *     The minimum extent for the layer.  Defaults to null.\n
     */\n
    minExtent: null,\n
    \n
    /**\n
     * APIProperty: maxResolution\n
     * {Float} Default max is 360 deg / 256 px, which corresponds to\n
     *     zoom level 0 on gmaps.  Specify a different value in the layer \n
     *     options if you are not using the default <OpenLayers.Map.tileSize>\n
     *     and displaying the whole world.\n
     */\n
    maxResolution: null,\n
\n
    /**\n
     * APIProperty: minResolution\n
     * {Float}\n
     */\n
    minResolution: null,\n
\n
    /**\n
     * APIProperty: numZoomLevels\n
     * {Integer}\n
     */\n
    numZoomLevels: null,\n
    \n
    /**\n
     * APIProperty: minScale\n
     * {Float}\n
     */\n
    minScale: null,\n
    \n
    /**\n
     * APIProperty: maxScale\n
     * {Float}\n
     */\n
    maxScale: null,\n
\n
    /**\n
     * APIProperty: displayOutsideMaxExtent\n
     * {Boolean} Request map tiles that are completely outside of the max \n
     *     extent for this layer. Defaults to false.\n
     */\n
    displayOutsideMaxExtent: false,\n
\n
    /**\n
     * APIProperty: wrapDateLine\n
     * {Boolean} Wraps the world at the international dateline, so the map can\n
     * be panned infinitely in longitudinal direction. Only use this on the\n
     * base layer, and only if the layer\'s maxExtent equals the world bounds.\n
     * #487 for more info.   \n
     */\n
    wrapDateLine: false,\n
    \n
    /**\n
     * Property: metadata\n
     * {Object} This object can be used to store additional information on a\n
     *     layer object.\n
     */\n
    metadata: null,\n
    \n
    /**\n
     * Constructor: OpenLayers.Layer\n
     *\n
     * Parameters:\n
     * name - {String} The layer name\n
     * options - {Object} Hashtable of extra options to tag onto the layer\n
     */\n
    initialize: function(name, options) {\n
\n
        this.metadata = {};\n
        \n
        this.addOptions(options);\n
\n
        this.name = name;\n
        \n
        if (this.id == null) {\n
\n
            this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");\n
\n
            this.div = OpenLayers.Util.createDiv(this.id);\n
            this.div.style.width = "100%";\n
            this.div.style.height = "100%";\n
            this.div.dir = "ltr";\n
\n
            this.events = new OpenLayers.Events(this, this.div);\n
            if(this.eventListeners instanceof Object) {\n
                this.events.on(this.eventListeners);\n
            }\n
\n
        }\n
    },\n
    \n
    /**\n
     * Method: destroy\n
     * Destroy is a destructor: this is to alleviate cyclic references which\n
     *     the Javascript garbage cleaner can not take care of on its own.\n
     *\n
     * Parameters:\n
     * setNewBaseLayer - {Boolean} Set a new base layer when this layer has\n
     *     been destroyed.  Default is true.\n
     */\n
    destroy: function(setNewBaseLayer) {\n
        if (setNewBaseLayer == null) {\n
            setNewBaseLayer = true;\n
        }\n
        if (this.map != null) {\n
            this.map.removeLayer(this, setNewBaseLayer);\n
        }\n
        this.projection = null;\n
        this.map = null;\n
        this.name = null;\n
        this.div = null;\n
        this.options = null;\n
\n
        if (this.events) {\n
            if(this.eventListeners) {\n
                this.events.un(this.eventListeners);\n
            }\n
            this.events.destroy();\n
        }\n
        this.eventListeners = null;\n
        this.events = null;\n
    },\n
    \n
   /**\n
    * Method: clone\n
    *\n
    * Parameters:\n
    * obj - {<OpenLayers.Layer>} The layer to be cloned\n
    *\n
    * Returns:\n
    * {<OpenLayers.Layer>} An exact clone of this <OpenLayers.Layer>\n
    */\n
    clone: function (obj) {\n
        \n
        if (obj == null) {\n
            obj = new OpenLayers.Layer(this.name, this.getOptions());\n
        }\n
        \n
        // catch any randomly tagged-on properties\n
        OpenLayers.Util.applyDefaults(obj, this);\n
        \n
        // a cloned layer should never have its map property set\n
        //  because it has not been added to a map yet. \n
        obj.map = null;\n
        \n
        return obj;\n
    },\n
    \n
    /**\n
     * Method: getOptions\n
     * Extracts an object from the layer with the properties that were set as\n
     *     options, but updates them with the values currently set on the\n
     *     instance.\n
     * \n
     * Returns:\n
     * {Object} the <options> of the layer, representing the current state.\n
     */\n
    getOptions: function() {\n
        var options = {};\n
        for(var o in this.options) {\n
            options[o] = this[o];\n
        }\n
        return options;\n
    },\n
    \n
    /** \n
     * APIMethod: setName\n
     * Sets the new layer name for this layer.  Can trigger a changelayer event\n
     *     on the map.\n
     *\n
     * Parameters:\n
     * newName - {String} The new name.\n
     */\n
    setName: function(newName) {\n
        if (newName != this.name) {\n
            this.name = newName;\n
            if (this.map != null) {\n
                this.map.events.triggerEvent("changelayer", {\n
                    layer: this,\n
                    property: "name"\n
                });\n
            }\n
        }\n
    },    \n
    \n
   /**\n
    * APIMethod: addOptions\n
    * \n
    * Parameters:\n
    * newOptions - {Object}\n
    * reinitialize - {Boolean} If set to true, and if resolution options of the\n
    *     current baseLayer were changed, the map will be recentered to make\n
    *     sure that it is displayed with a valid resolution, and a\n
    *     changebaselayer event will be triggered.\n
    */\n
    addOptions: function (newOptions, reinitialize) {\n
\n
        if (this.options == null) {\n
            this.options = {};\n
        }\n
        \n
        if (newOptions) {\n
            // make sure this.projection references a projection object\n
            if(typeof newOptions.projection == "string") {\n
                newOptions.projection = new OpenLayers.Projection(newOptions.projection);\n
            }\n
            if (newOptions.projection) {\n
                // get maxResolution, units and maxExtent from projection defaults if\n
                // they are not defined already\n
                OpenLayers.Util.applyDefaults(newOptions,\n
                    OpenLayers.Projection.defaults[newOptions.projection.getCode()]);\n
            }\n
            // allow array for extents\n
            if (newOptions.maxExtent && !(newOptions.maxExtent instanceof OpenLayers.Bounds)) {\n
                newOptions.maxExtent = new OpenLayers.Bounds(newOptions.maxExtent);\n
            }\n
            if (newOptions.minExtent && !(newOptions.minExtent instanceof OpenLayers.Bounds)) {\n
                newOptions.minExtent = new OpenLayers.Bounds(newOptions.minExtent);\n
            }\n
        }\n
\n
        // update our copy for clone\n
        OpenLayers.Util.extend(this.options, newOptions);\n
\n
        // add new options to this\n
        OpenLayers.Util.extend(this, newOptions);\n
        \n
        // get the units from the projection, if we have a projection\n
        // and it it has units\n
        if(this.projection && this.projection.getUnits()) {\n
            this.units = this.projection.getUnits();\n
        }\n
\n
        // re-initialize resolutions if necessary, i.e. if any of the\n
        // properties of the "properties" array defined below is set\n
        // in the new options\n
        if(this.map) {\n
            // store current resolution so we can try to restore it later\n
            var resolution = this.map.getResolution();\n
            var properties = this.RESOLUTION_PROPERTIES.concat(\n
                ["projection", "units", "minExtent", "maxExtent"]\n
            );\n
            for(var o in newOptions) {\n
                if(newOptions.hasOwnProperty(o) &&\n
                   OpenLayers.Util.indexOf(properties, o) >= 0) {\n
\n
                    this.initResolutions();\n
                    if (reinitialize && this.map.baseLayer === this) {\n
                        // update map position, and restore previous resolution\n
                        this.map.setCenter(this.map.getCenter(),\n
                            this.map.getZoomForResolution(resolution),\n
                            false, true\n
                        );\n
                        // trigger a changebaselayer event to make sure that\n
                        // all controls (especially\n
                        // OpenLayers.Control.PanZoomBar) get notified of the\n
                        // new options\n
                        this.map.events.triggerEvent("changebaselayer", {\n
                            layer: this\n
                        });\n
                    }\n
                    break;\n
                }\n
            }\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: onMapResize\n
     * This function can be implemented by subclasses\n
     */\n
    onMapResize: function() {\n
        //this function can be implemented by subclasses  \n
    },\n
\n
    /**\n
     * APIMethod: redraw\n
     * Redraws the layer.  Returns true if the layer was redrawn, false if not.\n
     *\n
     * Returns:\n
     * {Boolean} The layer was redrawn.\n
     */\n
    redraw: function() {\n
        var redrawn = false;\n
        if (this.map) {\n
\n
            // min/max Range may have changed\n
            this.inRange = this.calculateInRange();\n
\n
            // map\'s center might not yet be set\n
            var extent = this.getExtent();\n
\n
            if (extent && this.inRange && this.visibility) {\n
                var zoomChanged = true;\n
                this.moveTo(extent, zoomChanged, false);\n
                this.events.triggerEvent("moveend",\n
                    {"zoomChanged": zoomChanged});\n
                redrawn = true;\n
            }\n
        }\n
        return redrawn;\n
    },\n
\n
    /**\n
     * Method: moveTo\n
     * \n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>}\n
     * zoomChanged - {Boolean} Tells when zoom has changed, as layers have to\n
     *     do some init work in that case.\n
     * dragging - {Boolean}\n
     */\n
    moveTo:function(bounds, zoomChanged, dragging) {\n
        var display = this.visibility;\n
        if (!this.isBaseLayer) {\n
            display = display && this.inRange;\n
        }\n
        this.display(display);\n
    },\n
\n
    /**\n
     * Method: moveByPx\n
     * Move the layer based on pixel vector. To be implemented by subclasses.\n
     *\n
     * Parameters:\n
     * dx - {Number} The x coord of the displacement vector.\n
     * dy - {Number} The y coord of the displacement vector.\n
     */\n
    moveByPx: function(dx, dy) {\n
    },\n
\n
    /**\n
     * Method: setMap\n
     * Set the map property for the layer. This is done through an accessor\n
     *     so that subclasses can override this and take special action once \n
     *     they have their map variable set. \n
     * \n
     *     Here we take care to bring over any of the necessary default \n
     *     properties from the map. \n
     * \n
     * Parameters:\n
     * map - {<OpenLayers.Map>}\n
     */\n
    setMap: function(map) {\n
        if (this.map == null) {\n
        \n
            this.map = map;\n
            \n
            // grab some essential layer data from the map if it hasn\'t already\n
            //  been set\n
            this.maxExtent = this.maxExtent || this.map.maxExtent;\n
            this.minExtent = this.minExtent || this.map.minExtent;\n
\n
            this.projection = this.projection || this.map.projection;\n
            if (typeof this.projection == "string") {\n
                this.projection = new OpenLayers.Projection(this.projection);\n
            }\n
\n
            // Check the projection to see if we can get units -- if not, refer\n
            // to properties.\n
            this.units = this.projection.getUnits() ||\n
                         this.units || this.map.units;\n
            \n
            this.initResolutions();\n
            \n
            if (!this.isBaseLayer) {\n
                this.inRange = this.calculateInRange();\n
                var show = ((this.visibility) && (this.inRange));\n
                this.div.style.display = show ? "" : "none";\n
            }\n
            \n
            // deal with gutters\n
            this.setTileSize();\n
        }\n
    },\n
    \n
    /**\n
     * Method: afterAdd\n
     * Called at the end of the map.addLayer sequence.  At this point, the map\n
     *     will have a base layer.  To be overridden by subclasses.\n
     */\n
    afterAdd: function() {\n
    },\n
    \n
    /**\n
     * APIMethod: removeMap\n
     * Just as setMap() allows each layer the possibility to take a \n
     *     personalized action on being added to the map, removeMap() allows\n
     *     each layer to take a personalized action on being removed from it. \n
     *     For now, this will be mostly unused, except for the EventPane layer,\n
     *     which needs this hook so that it can remove the special invisible\n
     *     pane. \n
     * \n
     * Parameters:\n
     * map - {<OpenLayers.Map>}\n
     */\n
    removeMap: function(map) {\n
        //to be overridden by subclasses\n
    },\n
    \n
    /**\n
     * APIMethod: getImageSize\n
     *\n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>} optional tile bounds, can be used\n
     *     by subclasses that have to deal with different tile sizes at the\n
     *     layer extent edges (e.g. Zoomify)\n
     * \n
     * Returns:\n
     * {<OpenLayers.Size>} The size that the image should be, taking into \n
     *     account gutters.\n
     */ \n
    getImageSize: function(bounds) { \n
        return (this.imageSize || this.tileSize); \n
    },    \n
  \n
    /**\n
     * APIMethod: setTileSize\n
     * Set the tile size based on the map size.  This also sets layer.imageSize\n
     *     or use by Tile.Image.\n
     * \n
     * Parameters:\n
     * size - {<OpenLayers.Size>}\n
     */\n
    setTileSize: function(size) {\n
        var tileSize = (size) ? size :\n
                                ((this.tileSize) ? this.tileSize :\n
                                                   this.map.getTileSize());\n
        this.tileSize = tileSize;\n
        if(this.gutter) {\n
          // layers with gutters need non-null tile sizes\n
          //if(tileSize == null) {\n
          //    OpenLayers.console.error("Error in layer.setMap() for " +\n
          //                              this.name + ": layers with " +\n
          //                              "gutters need non-null tile sizes");\n
          //}\n
            this.imageSize = new OpenLayers.Size(tileSize.w + (2*this.gutter), \n
                                                 tileSize.h + (2*this.gutter)); \n
        }\n
    },\n
\n
    /**\n
     * APIMethod: getVisibility\n
     * \n
     * Returns:\n
     * {Boolean} The layer should be displayed (if in range).\n
     */\n
    getVisibility: function() {\n
        return this.visibility;\n
    },\n
\n
    /** \n
     * APIMethod: setVisibility\n
     * Set the visibility flag for the layer and hide/show & redraw \n
     *     accordingly. Fire event unless otherwise specified\n
     * \n
     * Note that visibility is no longer simply whether or not the layer\'s\n
     *     style.display is set to "block". Now we store a \'visibility\' state \n
     *     property on the layer class, this allows us to remember whether or \n
     *     not we *desire* for a layer to be visible. In the case where the \n
     *     map\'s resolution is out of the layer\'s range, this desire may be \n
     *     subverted.\n
     * \n
     * Parameters:\n
     * visibility - {Boolean} Whether or not to display the layer (if in range)\n
     */\n
    setVisibility: function(visibility) {\n
        if (visibility != this.visibility) {\n
            this.visibility = visibility;\n
            this.display(visibility);\n
            this.redraw();\n
            if (this.map != null) {\n
                this.map.events.triggerEvent("changelayer", {\n
                    layer: this,\n
                    property: "visibility"\n
                });\n
            }\n
            this.events.triggerEvent("visibilitychanged");\n
        }\n
    },\n
\n
    /** \n
     * APIMethod: display\n
     * Hide or show the Layer. This is designed to be used internally, and \n
     *     is not generally the way to enable or disable the layer. For that,\n
     *     use the setVisibility function instead..\n
     * \n
     * Parameters:\n
     * display - {Boolean}\n
     */\n
    display: function(display) {\n
        if (display != (this.div.style.display != "none")) {\n
            this.div.style.display = (display && this.calculateInRange()) ? "block" : "none";\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: calculateInRange\n
     * \n
     * Returns:\n
     * {Boolean} The layer is displayable at the current map\'s current\n
     *     resolution. Note that if \'alwaysInRange\' is true for the layer, \n
     *     this function will always return true.\n
     */\n
    calculateInRange: function() {\n
        var inRange = false;\n
\n
        if (this.alwaysInRange) {\n
            inRange = true;\n
        } else {\n
            if (this.map) {\n
                var resolution = this.map.getResolution();\n
                inRange = ( (resolution >= this.minResolution) &&\n
                            (resolution <= this.maxResolution) );\n
            }\n
        }\n
        return inRange;\n
    },\n
\n
    /** \n
     * APIMethod: setIsBaseLayer\n
     * \n
     * Parameters:\n
     * isBaseLayer - {Boolean}\n
     */\n
    setIsBaseLayer: function(isBaseLayer) {\n
        if (isBaseLayer != this.isBaseLayer) {\n
            this.isBaseLayer = isBaseLayer;\n
            if (this.map != null) {\n
                this.map.events.triggerEvent("changebaselayer", {\n
                    layer: this\n
                });\n
            }\n
        }\n
    },\n
\n
  /********************************************************/\n
  /*                                                      */\n
  /*                 Baselayer Functions                  */\n
  /*                                                      */\n
  /********************************************************/\n
  \n
    /** \n
     * Method: initResolutions\n
     * This method\'s responsibility is to set up the \'resolutions\' array \n
     *     for the layer -- this array is what the layer will use to interface\n
     *     between the zoom levels of the map and the resolution display \n
     *     of the layer.\n
     * \n
     * The user has several options that determine how the array is set up.\n
     *  \n
     * For a detailed explanation, see the following wiki from the \n
     *     openlayers.org homepage:\n
     *     http://trac.openlayers.org/wiki/SettingZoomLevels\n
     */\n
    initResolutions: function() {\n
\n
        // ok we want resolutions, here\'s our strategy:\n
        //\n
        // 1. if resolutions are defined in the layer config, use them\n
        // 2. else, if scales are defined in the layer config then derive\n
        //    resolutions from these scales\n
        // 3. else, attempt to calculate resolutions from maxResolution,\n
        //    minResolution, numZoomLevels, maxZoomLevel set in the\n
        //    layer config\n
        // 4. if we still don\'t have resolutions, and if resolutions\n
        //    are defined in the same, use them\n
        // 5. else, if scales are defined in the map then derive\n
        //    resolutions from these scales\n
        // 6. else, attempt to calculate resolutions from maxResolution,\n
        //    minResolution, numZoomLevels, maxZoomLevel set in the\n
        //    map\n
        // 7. hope for the best!\n
\n
        var i, len, p;\n
        var props = {}, alwaysInRange = true;\n
\n
        // get resolution data from layer config\n
        // (we also set alwaysInRange in the layer as appropriate)\n
        for(i=0, len=this.RESOLUTION_PROPERTIES.length; i<len; i++) {\n
            p = this.RESOLUTION_PROPERTIES[i];\n
            props[p] = this.options[p];\n
            if(alwaysInRange && this.options[p]) {\n
                alwaysInRange = false;\n
            }\n
        }\n
        if(this.alwaysInRange == null) {\n
            this.alwaysInRange = alwaysInRange;\n
        }\n
\n
        // if we don\'t have resolutions then attempt to derive them from scales\n
        if(props.resolutions == null) {\n
            props.resolutions = this.resolutionsFromScales(props.scales);\n
        }\n
\n
        // if we still don\'t have resolutions then attempt to calculate them\n
        if(props.resolutions == null) {\n
            props.resolutions = this.calculateResolutions(props);\n
        }\n
\n
        // if we couldn\'t calculate resolutions then we look at we have\n
        // in the map\n
        if(props.resolutions == null) {\n
            for(i=0, len=this.RESOLUTION_PROPERTIES.length; i<len; i++) {\n
                p = this.RESOLUTION_PROPERTIES[i];\n
                props[p] = this.options[p] != null ?\n
                    this.options[p] : this.map[p];\n
            }\n
            if(props.resolutions == null) {\n
                props.resolutions = this.resolutionsFromScales(props.scales);\n
            }\n
            if(props.resolutions == null) {\n
                props.resolutions = this.calculateResolutions(props);\n
            }\n
        }\n
\n
        // ok, we new need to set properties in the instance\n
\n
        // get maxResolution from the config if it\'s defined there\n
        var maxResolution;\n
        if(this.options.maxResolution &&\n
           this.options.maxResolution !== "auto") {\n
            maxResolution = this.options.maxResolution;\n
        }\n
        if(this.options.minScale) {\n
            maxResolution = OpenLayers.Util.getResolutionFromScale(\n
                this.options.minScale, this.units);\n
        }\n
\n
        // get minResolution from the config if it\'s defined there\n
        var minResolution;\n
        if(this.options.minResolution &&\n
           this.options.minResolution !== "auto") {\n
            minResolution = this.options.minResolution;\n
        }\n
        if(this.options.maxScale) {\n
            minResolution = OpenLayers.Util.getResolutionFromScale(\n
                this.options.maxScale, this.units);\n
        }\n
\n
        if(props.resolutions) {\n
\n
            //sort resolutions array descendingly\n
            props.resolutions.sort(function(a, b) {\n
                return (b - a);\n
            });\n
\n
            // if we still don\'t have a maxResolution get it from the\n
            // resolutions array\n
            if(!maxResolution) {\n
                maxResolution = props.resolutions[0];\n
            }\n
\n
            // if we still don\'t have a minResolution get it from the\n
            // resolutions array\n
            if(!minResolution) {\n
                var lastIdx = props.resolutions.length - 1;\n
                minResolution = props.resolutions[lastIdx];\n
            }\n
        }\n
\n
        this.resolutions = props.resolutions;\n
        if(this.resolutions) {\n
            len = this.resolutions.length;\n
            this.scales = new Array(len);\n
            for(i=0; i<len; i++) {\n
                this.scales[i] = OpenLayers.Util.getScaleFromResolution(\n
                    this.resolutions[i], this.units);\n
            }\n
            this.numZoomLevels = len;\n
        }\n
        this.minResolution = minResolution;\n
        if(minResolution) {\n
            this.maxScale = OpenLayers.Util.getScaleFromResolution(\n
                minResolution, this.units);\n
        }\n
        this.maxResolution = maxResolution;\n
        if(maxResolution) {\n
            this.minScale = OpenLayers.Util.getScaleFromResolution(\n
                maxResolution, this.units);\n
        }\n
    },\n
\n
    /**\n
     * Method: resolutionsFromScales\n
     * Derive resolutions from scales.\n
     *\n
     * Parameters:\n
     * scales - {Array(Number)} Scales\n
     *\n
     * Returns\n
     * {Array(Number)} Resolutions\n
     */\n
    resolutionsFromScales: function(scales) {\n
        if(scales == null) {\n
            return;\n
        }\n
        var resolutions, i, len;\n
        len = scales.length;\n
        resolutions = new Array(len);\n
        for(i=0; i<len; i++) {\n
            resolutions[i] = OpenLayers.Util.getResolutionFromScale(\n
                scales[i], this.units);\n
        }\n
        return resolutions;\n
    },\n
\n
    /**\n
     * Method: calculateResolutions\n
     * Calculate resolutions based on the provided properties.\n
     *\n
     * Parameters:\n
     * props - {Object} Properties\n
     *\n
     * Returns:\n
     * {Array({Number})} Array of resolutions.\n
     */\n
    calculateResolutions: function(props) {\n
\n
        var viewSize, wRes, hRes;\n
\n
        // determine maxResolution\n
        var maxResolution = props.maxResolution;\n
        if(props.minScale != null) {\n
            maxResolution =\n
                OpenLayers.Util.getResolutionFromScale(props.minScale,\n
                                                       this.units);\n
        } else if(maxResolution == "auto" && this.maxExtent != null) {\n
            viewSize = this.map.getSize();\n
            wRes = this.maxExtent.getWidth() / viewSize.w;\n
            hRes = this.maxExtent.getHeight() / viewSize.h;\n
            maxResolution = Math.max(wRes, hRes);\n
        }\n
\n
        // determine minResolution\n
        var minResolution = props.minResolution;\n
        if(props.maxScale != null) {\n
            minResolution =\n
                OpenLayers.Util.getResolutionFromScale(props.maxScale,\n
                                                       this.units);\n
        } else if(props.minResolution == "auto" && this.minExtent != null) {\n
            viewSize = this.map.getSize();\n
            wRes = this.minExtent.getWidth() / viewSize.w;\n
            hRes = this.minExtent.getHeight()/ viewSize.h;\n
            minResolution = Math.max(wRes, hRes);\n
        }\n
\n
        if(typeof maxResolution !== "number" &&\n
           typeof minResolution !== "number" &&\n
           this.maxExtent != null) {\n
            // maxResolution for default grid sets assumes that at zoom\n
            // level zero, the whole world fits on one tile.\n
            var tileSize = this.map.getTileSize();\n
            maxResolution = Math.max(\n
                this.maxExtent.getWidth() / tileSize.w,\n
                this.maxExtent.getHeight() / tileSize.h\n
            );\n
        }\n
\n
        // determine numZoomLevels\n
        var maxZoomLevel = props.maxZoomLevel;\n
        var numZoomLevels = props.numZoomLevels;\n
        if(typeof minResolution === "number" &&\n
           typeof maxResolution === "number" && numZoomLevels === undefined) {\n
            var ratio = maxResolution / minResolution;\n
            numZoomLevels = Math.floor(Math.log(ratio) / Math.log(2)) + 1;\n
        } else if(numZoomLevels === undefined && maxZoomLevel != null) {\n
            numZoomLevels = maxZoomLevel + 1;\n
        }\n
\n
        // are we able to calculate resolutions?\n
        if(typeof numZoomLevels !== "number" || numZoomLevels <= 0 ||\n
           (typeof maxResolution !== "number" &&\n
                typeof minResolution !== "number")) {\n
            return;\n
        }\n
\n
        // now we have numZoomLevels and at least one of maxResolution\n
        // or minResolution, we can populate the resolutions array\n
\n
        var resolutions = new Array(numZoomLevels);\n
        var base = 2;\n
        if(typeof minResolution == "number" &&\n
           typeof maxResolution == "number") {\n
            // if maxResolution and minResolution are set, we calculate\n
            // the base for exponential scaling that starts at\n
            // maxResolution and ends at minResolution in numZoomLevels\n
            // steps.\n
            base = Math.pow(\n
                    (maxResolution / minResolution),\n
                (1 / (numZoomLevels - 1))\n
            );\n
        }\n
\n
        var i;\n
        if(typeof maxResolution === "number") {\n
            for(i=0; i<numZoomLevels; i++) {\n
                resolutions[i] = maxResolution / Math.pow(base, i);\n
            }\n
        } else {\n
            for(i=0; i<numZoomLevels; i++) {\n
                resolutions[numZoomLevels - 1 - i] =\n
                    minResolution * Math.pow(base, i);\n
            }\n
        }\n
\n
        return resolutions;\n
    },\n
\n
    /**\n
     * APIMethod: getResolution\n
     * \n
     * Returns:\n
     * {Float} The currently selected resolution of the map, taken from the\n
     *     resolutions array, indexed by current zoom level.\n
     */\n
    getResolution: function() {\n
        var zoom = this.map.getZoom();\n
        return this.getResolutionForZoom(zoom);\n
    },\n
\n
    /** \n
     * APIMethod: getExtent\n
     * \n
     * Returns:\n
     * {<OpenLayers.Bounds>} A Bounds object which represents the lon/lat \n
     *     bounds of the current viewPort.\n
     */\n
    getExtent: function() {\n
        // just use stock map calculateBounds function -- passing no arguments\n
        //  means it will user map\'s current center & resolution\n
        //\n
        return this.map.calculateBounds();\n
    },\n
\n
    /**\n
     * APIMethod: getZoomForExtent\n
     * \n
     * Parameters:\n
     * extent - {<OpenLayers.Bounds>}\n
     * closest - {Boolean} Find the zoom level that most closely fits the \n
     *     specified bounds. Note that this may result in a zoom that does \n
     *     not exactly contain the entire extent.\n
     *     Default is false.\n
     *\n
     * Returns:\n
     * {Integer} The index of the zoomLevel (entry in the resolutions array) \n
     *     for the passed-in extent. We do this by calculating the ideal \n
     *     resolution for the given extent (based on the map size) and then \n
     *     calling getZoomForResolution(), passing along the \'closest\'\n
     *     parameter.\n
     */\n
    getZoomForExtent: function(extent, closest) {\n
        var viewSize = this.map.getSize();\n
        var idealResolution = Math.max( extent.getWidth()  / viewSize.w,\n
                                        extent.getHeight() / viewSize.h );\n
\n
        return this.getZoomForResolution(idealResolution, closest);\n
    },\n
    \n
    /** \n
     * Method: getDataExtent\n
     * Calculates the max extent which includes all of the data for the layer.\n
     *     This function is to be implemented by subclasses.\n
     * \n
     * Returns:\n
     * {<OpenLayers.Bounds>}\n
     */\n
    getDataExtent: function () {\n
        //to be implemented by subclasses\n
    },\n
\n
    /**\n
     * APIMethod: getResolutionForZoom\n
     * \n
     * Parameters:\n
     * zoom - {Float}\n
     * \n
     * Returns:\n
     * {Float} A suitable resolution for the specified zoom.\n
     */\n
    getResolutionForZoom: function(zoom) {\n
        zoom = Math.max(0, Math.min(zoom, this.resolutions.length - 1));\n
        var resolution;\n
        if(this.map.fractionalZoom) {\n
            var low = Math.floor(zoom);\n
            var high = Math.ceil(zoom);\n
            resolution = this.resolutions[low] -\n
                ((zoom-low) * (this.resolutions[low]-this.resolutions[high]));\n
        } else {\n
            resolution = this.resolutions[Math.round(zoom)];\n
        }\n
        return resolution;\n
    },\n
\n
    /**\n
     * APIMethod: getZoomForResolution\n
     * \n
     * Parameters:\n
     * resolution - {Float}\n
     * closest - {Boolean} Find the zoom level that corresponds to the absolute \n
     *     closest resolution, which may result in a zoom whose corresponding\n
     *     resolution is actually smaller than we would have desired (if this\n
     *     is being called from a getZoomForExtent() call, then this means that\n
     *     the returned zoom index might not actually contain the entire \n
     *     extent specified... but it\'ll be close).\n
     *     Default is false.\n
     * \n
     * Returns:\n
     * {Integer} The index of the zoomLevel (entry in the resolutions array) \n
     *     that corresponds to the best fit resolution given the passed in \n
     *     value and the \'closest\' specification.\n
     */\n
    getZoomForResolution: function(resolution, closest) {\n
        var zoom, i, len;\n
        if(this.map.fractionalZoom) {\n
            var lowZoom = 0;\n
            var highZoom = this.resolutions.length - 1;\n
            var highRes = this.resolutions[lowZoom];\n
            var lowRes = this.resolutions[highZoom];\n
            var res;\n
            for(i=0, len=this.resolutions.length; i<len; ++i) {\n
                res = this.resolutions[i];\n
                if(res >= resolution) {\n
                    highRes = res;\n
                    lowZoom = i;\n
                }\n
                if(res <= resolution) {\n
                    lowRes = res;\n
                    highZoom = i;\n
                    break;\n
                }\n
            }\n
            var dRes = highRes - lowRes;\n
            if(dRes > 0) {\n
                zoom = lowZoom + ((highRes - resolution) / dRes);\n
            } else {\n
                zoom = lowZoom;\n
            }\n
        } else {\n
            var diff;\n
            var minDiff = Number.POSITIVE_INFINITY;\n
            for(i=0, len=this.resolutions.length; i<len; i++) {            \n
                if (closest) {\n
                    diff = Math.abs(this.resolutions[i] - resolution);\n
                    if (diff > minDiff) {\n
                        break;\n
                    }\n
                    minDiff = diff;\n
                } else {\n
                    if (this.resolutions[i] < resolution) {\n
                        break;\n
                    }\n
                }\n
            }\n
            zoom = Math.max(0, i-1);\n
        }\n
        return zoom;\n
    },\n
    \n
    /**\n
     * APIMethod: getLonLatFromViewPortPx\n
     * \n
     * Parameters:\n
     * viewPortPx - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or\n
     *                                          an object with a \'x\'\n
     *                                          and \'y\' properties.\n
     *\n
     * Returns:\n
     * {<OpenLayers.LonLat>} An OpenLayers.LonLat which is the passed-in \n
     *     view port <OpenLayers.Pixel>, translated into lon/lat by the layer.\n
     */\n
    getLonLatFromViewPortPx: function (viewPortPx) {\n
        var lonlat = null;\n
        var map = this.map;\n
        if (viewPortPx != null && map.minPx) {\n
            var res = map.getResolution();\n
            var maxExtent = map.getMaxExtent({restricted: true});\n
            var lon = (viewPortPx.x - map.minPx.x) * res + maxExtent.left;\n
            var lat = (map.minPx.y - viewPortPx.y) * res + maxExtent.top;\n
            lonlat = new OpenLayers.LonLat(lon, lat);\n
\n
            if (this.wrapDateLine) {\n
                lonlat = lonlat.wrapDateLine(this.maxExtent);\n
            }\n
        }\n
        return lonlat;\n
    },\n
\n
    /**\n
     * APIMethod: getViewPortPxFromLonLat\n
     * Returns a pixel location given a map location.  This method will return\n
     *     fractional pixel values.\n
     * \n
     * Parameters:\n
     * lonlat - {<OpenLayers.LonLat>|Object} An OpenLayers.LonLat or\n
     *                                       an object with a \'lon\'\n
     *                                       and \'lat\' properties.\n
     *\n
     * Returns: \n
     * {<OpenLayers.Pixel>} An <OpenLayers.Pixel> which is the passed-in \n
     *     lonlat translated into view port pixels.\n
     */\n
    getViewPortPxFromLonLat: function (lonlat, resolution) {\n
        var px = null; \n
        if (lonlat != null) {\n
            resolution = resolution || this.map.getResolution();\n
            var extent = this.map.calculateBounds(null, resolution);\n
            px = new OpenLayers.Pixel(\n
                (1/resolution * (lonlat.lon - extent.left)),\n
                (1/resolution * (extent.top - lonlat.lat))\n
            );    \n
        }\n
        return px;\n
    },\n
    \n
    /**\n
     * APIMethod: setOpacity\n
     * Sets the opacity for the entire layer (all images)\n
     * \n
     * Parameters:\n
     * opacity - {Float}\n
     */\n
    setOpacity: function(opacity) {\n
        if (opacity != this.opacity) {\n
            this.opacity = opacity;\n
            var childNodes = this.div.childNodes;\n
            for(var i = 0, len = childNodes.length; i < len; ++i) {\n
                var element = childNodes[i].firstChild || childNodes[i];\n
                var lastChild = childNodes[i].lastChild;\n
                //TODO de-uglify this\n
                if (lastChild && lastChild.nodeName.toLowerCase() === "iframe") {\n
                    element = lastChild.parentNode;\n
                }\n
                OpenLayers.Util.modifyDOMElement(element, null, null, null, \n
                                                 null, null, null, opacity);\n
            }\n
            if (this.map != null) {\n
                this.map.events.triggerEvent("changelayer", {\n
                    layer: this,\n
                    property: "opacity"\n
                });\n
            }\n
        }\n
    },\n
\n
    /**\n
     * Method: getZIndex\n
     * \n
     * Returns: \n
     * {Integer} the z-index of this layer\n
     */    \n
    getZIndex: function () {\n
        return this.div.style.zIndex;\n
    },\n
\n
    /**\n
     * Method: setZIndex\n
     * \n
     * Parameters: \n
     * zIndex - {Integer}\n
     */    \n
    setZIndex: function (zIndex) {\n
        this.div.style.zIndex = zIndex;\n
    },\n
\n
    /**\n
     * Method: adjustBounds\n
     * This function will take a bounds, and if wrapDateLine option is set\n
     *     on the layer, it will return a bounds which is wrapped around the \n
     *     world. We do not wrap for bounds which *cross* the \n
     *     maxExtent.left/right, only bounds which are entirely to the left \n
     *     or entirely to the right.\n
     * \n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>}\n
     */\n
    adjustBounds: function (bounds) {\n
\n
        if (this.gutter) {\n
            // Adjust the extent of a bounds in map units by the \n
            // layer\'s gutter in pixels.\n
            var mapGutter = this.gutter * this.map.getResolution();\n
            bounds = new OpenLayers.Bounds(bounds.left - mapGutter,\n
                                           bounds.bottom - mapGutter,\n
                                           bounds.right + mapGutter,\n
                                           bounds.top + mapGutter);\n
        }\n
\n
        if (this.wrapDateLine) {\n
            // wrap around the date line, within the limits of rounding error\n
            var wrappingOptions = { \n
                \'rightTolerance\':this.getResolution(),\n
                \'leftTolerance\':this.getResolution()\n
            };    \n
            bounds = bounds.wrapDateLine(this.maxExtent, wrappingOptions);\n
                              \n
        }\n
        return bounds;\n
    },\n
\n
    CLASS_NAME: "OpenLayers.Layer"\n
});\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>46776</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
