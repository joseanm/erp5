<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.77</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Style.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/BaseTypes/Class.js\n
 * @requires OpenLayers/Util.js\n
 * @requires OpenLayers/Feature/Vector.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Style\n
 * This class represents a UserStyle obtained\n
 *     from a SLD, containing styling rules.\n
 */\n
OpenLayers.Style = OpenLayers.Class({\n
\n
    /**\n
     * Property: id\n
     * {String} A unique id for this session.\n
     */\n
    id: null,\n
    \n
    /**\n
     * APIProperty: name\n
     * {String}\n
     */\n
    name: null,\n
    \n
    /**\n
     * Property: title\n
     * {String} Title of this style (set if included in SLD)\n
     */\n
    title: null,\n
    \n
    /**\n
     * Property: description\n
     * {String} Description of this style (set if abstract is included in SLD)\n
     */\n
    description: null,\n
\n
    /**\n
     * APIProperty: layerName\n
     * {<String>} name of the layer that this style belongs to, usually\n
     * according to the NamedLayer attribute of an SLD document.\n
     */\n
    layerName: null,\n
    \n
    /**\n
     * APIProperty: isDefault\n
     * {Boolean}\n
     */\n
    isDefault: false,\n
     \n
    /** \n
     * Property: rules \n
     * {Array(<OpenLayers.Rule>)}\n
     */\n
    rules: null,\n
    \n
    /**\n
     * Property: context\n
     * {Object} An optional object with properties that symbolizers\' property\n
     * values should be evaluated against. If no context is specified,\n
     * feature.attributes will be used\n
     */\n
    context: null,\n
\n
    /**\n
     * Property: defaultStyle\n
     * {Object} hash of style properties to use as default for merging\n
     * rule-based style symbolizers onto. If no rules are defined,\n
     * createSymbolizer will return this style. If <defaultsPerSymbolizer> is set to\n
     * true, the defaultStyle will only be taken into account if there are\n
     * rules defined.\n
     */\n
    defaultStyle: null,\n
    \n
    /**\n
     * Property: defaultsPerSymbolizer\n
     * {Boolean} If set to true, the <defaultStyle> will extend the symbolizer\n
     * of every rule. Properties of the <defaultStyle> will also be used to set\n
     * missing symbolizer properties if the symbolizer has stroke, fill or\n
     * graphic set to true. Default is false.\n
     */\n
    defaultsPerSymbolizer: false,\n
    \n
    /**\n
     * Property: propertyStyles\n
     * {Hash of Boolean} cache of style properties that need to be parsed for\n
     * propertyNames. Property names are keys, values won\'t be used.\n
     */\n
    propertyStyles: null,\n
    \n
\n
    /** \n
     * Constructor: OpenLayers.Style\n
     * Creates a UserStyle.\n
     *\n
     * Parameters:\n
     * style        - {Object} Optional hash of style properties that will be\n
     *                used as default style for this style object. This style\n
     *                applies if no rules are specified. Symbolizers defined in\n
     *                rules will extend this default style.\n
     * options - {Object} An optional object with properties to set on the\n
     *     style.\n
     *\n
     * Valid options:\n
     * rules - {Array(<OpenLayers.Rule>)} List of rules to be added to the\n
     *     style.\n
     * \n
     * Returns:\n
     * {<OpenLayers.Style>}\n
     */\n
    initialize: function(style, options) {\n
\n
        OpenLayers.Util.extend(this, options);\n
        this.rules = [];\n
        if(options && options.rules) {\n
            this.addRules(options.rules);\n
        }\n
\n
        // use the default style from OpenLayers.Feature.Vector if no style\n
        // was given in the constructor\n
        this.setDefaultStyle(style ||\n
                             OpenLayers.Feature.Vector.style["default"]);\n
\n
        this.id = OpenLayers.Util.createUniqueID(this.CLASS_NAME + "_");\n
    },\n
\n
    /** \n
     * APIMethod: destroy\n
     * nullify references to prevent circular references and memory leaks\n
     */\n
    destroy: function() {\n
        for (var i=0, len=this.rules.length; i<len; i++) {\n
            this.rules[i].destroy();\n
            this.rules[i] = null;\n
        }\n
        this.rules = null;\n
        this.defaultStyle = null;\n
    },\n
    \n
    /**\n
     * Method: createSymbolizer\n
     * creates a style by applying all feature-dependent rules to the base\n
     * style.\n
     * \n
     * Parameters:\n
     * feature - {<OpenLayers.Feature>} feature to evaluate rules for\n
     * \n
     * Returns:\n
     * {Object} symbolizer hash\n
     */\n
    createSymbolizer: function(feature) {\n
        var style = this.defaultsPerSymbolizer ? {} : this.createLiterals(\n
            OpenLayers.Util.extend({}, this.defaultStyle), feature);\n
        \n
        var rules = this.rules;\n
\n
        var rule, context;\n
        var elseRules = [];\n
        var appliedRules = false;\n
        for(var i=0, len=rules.length; i<len; i++) {\n
            rule = rules[i];\n
            // does the rule apply?\n
            var applies = rule.evaluate(feature);\n
            \n
            if(applies) {\n
                if(rule instanceof OpenLayers.Rule && rule.elseFilter) {\n
                    elseRules.push(rule);\n
                } else {\n
                    appliedRules = true;\n
                    this.applySymbolizer(rule, style, feature);\n
                }\n
            }\n
        }\n
        \n
        // if no other rules apply, apply the rules with else filters\n
        if(appliedRules == false && elseRules.length > 0) {\n
            appliedRules = true;\n
            for(var i=0, len=elseRules.length; i<len; i++) {\n
                this.applySymbolizer(elseRules[i], style, feature);\n
            }\n
        }\n
\n
        // don\'t display if there were rules but none applied\n
        if(rules.length > 0 && appliedRules == false) {\n
            style.display = "none";\n
        }\n
        \n
        if (style.label != null && typeof style.label !== "string") {\n
            style.label = String(style.label);\n
        }\n
        \n
        return style;\n
    },\n
    \n
    /**\n
     * Method: applySymbolizer\n
     *\n
     * Parameters:\n
     * rule - {<OpenLayers.Rule>}\n
     * style - {Object}\n
     * feature - {<OpenLayer.Feature.Vector>}\n
     *\n
     * Returns:\n
     * {Object} A style with new symbolizer applied.\n
     */\n
    applySymbolizer: function(rule, style, feature) {\n
        var symbolizerPrefix = feature.geometry ?\n
                this.getSymbolizerPrefix(feature.geometry) :\n
                OpenLayers.Style.SYMBOLIZER_PREFIXES[0];\n
\n
        var symbolizer = rule.symbolizer[symbolizerPrefix] || rule.symbolizer;\n
        \n
        if(this.defaultsPerSymbolizer === true) {\n
            var defaults = this.defaultStyle;\n
            OpenLayers.Util.applyDefaults(symbolizer, {\n
                pointRadius: defaults.pointRadius\n
            });\n
            if(symbolizer.stroke === true || symbolizer.graphic === true) {\n
                OpenLayers.Util.applyDefaults(symbolizer, {\n
                    strokeWidth: defaults.strokeWidth,\n
                    strokeColor: defaults.strokeColor,\n
                    strokeOpacity: defaults.strokeOpacity,\n
                    strokeDashstyle: defaults.strokeDashstyle,\n
                    strokeLinecap: defaults.strokeLinecap\n
                });\n
            }\n
            if(symbolizer.fill === true || symbolizer.graphic === true) {\n
                OpenLayers.Util.applyDefaults(symbolizer, {\n
                    fillColor: defaults.fillColor,\n
                    fillOpacity: defaults.fillOpacity\n
                });\n
            }\n
            if(symbolizer.graphic === true) {\n
                OpenLayers.Util.applyDefaults(symbolizer, {\n
                    pointRadius: this.defaultStyle.pointRadius,\n
                    externalGraphic: this.defaultStyle.externalGraphic,\n
                    graphicName: this.defaultStyle.graphicName,\n
                    graphicOpacity: this.defaultStyle.graphicOpacity,\n
                    graphicWidth: this.defaultStyle.graphicWidth,\n
                    graphicHeight: this.defaultStyle.graphicHeight,\n
                    graphicXOffset: this.defaultStyle.graphicXOffset,\n
                    graphicYOffset: this.defaultStyle.graphicYOffset\n
                });\n
            }\n
        }\n
\n
        // merge the style with the current style\n
        return this.createLiterals(\n
                OpenLayers.Util.extend(style, symbolizer), feature);\n
    },\n
    \n
    /**\n
     * Method: createLiterals\n
     * creates literals for all style properties that have an entry in\n
     * <this.propertyStyles>.\n
     * \n
     * Parameters:\n
     * style   - {Object} style to create literals for. Will be modified\n
     *           inline.\n
     * feature - {Object}\n
     * \n
     * Returns:\n
     * {Object} the modified style\n
     */\n
    createLiterals: function(style, feature) {\n
        var context = OpenLayers.Util.extend({}, feature.attributes || feature.data);\n
        OpenLayers.Util.extend(context, this.context);\n
        \n
        for (var i in this.propertyStyles) {\n
            style[i] = OpenLayers.Style.createLiteral(style[i], context, feature, i);\n
        }\n
        return style;\n
    },\n
    \n
    /**\n
     * Method: findPropertyStyles\n
     * Looks into all rules for this style and the defaultStyle to collect\n
     * all the style hash property names containing ${...} strings that have\n
     * to be replaced using the createLiteral method before returning them.\n
     * \n
     * Returns:\n
     * {Object} hash of property names that need createLiteral parsing. The\n
     * name of the property is the key, and the value is true;\n
     */\n
    findPropertyStyles: function() {\n
        var propertyStyles = {};\n
\n
        // check the default style\n
        var style = this.defaultStyle;\n
        this.addPropertyStyles(propertyStyles, style);\n
\n
        // walk through all rules to check for properties in their symbolizer\n
        var rules = this.rules;\n
        var symbolizer, value;\n
        for (var i=0, len=rules.length; i<len; i++) {\n
            symbolizer = rules[i].symbolizer;\n
            for (var key in symbolizer) {\n
                value = symbolizer[key];\n
                if (typeof value == "object") {\n
                    // symbolizer key is "Point", "Line" or "Polygon"\n
                    this.addPropertyStyles(propertyStyles, value);\n
                } else {\n
                    // symbolizer is a hash of style properties\n
                    this.addPropertyStyles(propertyStyles, symbolizer);\n
                    break;\n
                }\n
            }\n
        }\n
        return propertyStyles;\n
    },\n
    \n
    /**\n
     * Method: addPropertyStyles\n
     * \n
     * Parameters:\n
     * propertyStyles - {Object} hash to add new property styles to. Will be\n
     *                  modified inline\n
     * symbolizer     - {Object} search this symbolizer for property styles\n
     * \n
     * Returns:\n
     * {Object} propertyStyles hash\n
     */\n
    addPropertyStyles: function(propertyStyles, symbolizer) {\n
        var property;\n
        for (var key in symbolizer) {\n
            property = symbolizer[key];\n
            if (typeof property == "string" &&\n
                    property.match(/\\$\\{\\w+\\}/)) {\n
                propertyStyles[key] = true;\n
            }\n
        }\n
        return propertyStyles;\n
    },\n
    \n
    /**\n
     * APIMethod: addRules\n
     * Adds rules to this style.\n
     * \n
     * Parameters:\n
     * rules - {Array(<OpenLayers.Rule>)}\n
     */\n
    addRules: function(rules) {\n
        Array.prototype.push.apply(this.rules, rules);\n
        this.propertyStyles = this.findPropertyStyles();\n
    },\n
    \n
    /**\n
     * APIMethod: setDefaultStyle\n
     * Sets the default style for this style object.\n
     * \n
     * Parameters:\n
     * style - {Object} Hash of style properties\n
     */\n
    setDefaultStyle: function(style) {\n
        this.defaultStyle = style; \n
        this.propertyStyles = this.findPropertyStyles();\n
    },\n
        \n
    /**\n
     * Method: getSymbolizerPrefix\n
     * Returns the correct symbolizer prefix according to the\n
     * geometry type of the passed geometry\n
     * \n
     * Parameters:\n
     * geometry - {<OpenLayers.Geometry>}\n
     * \n
     * Returns:\n
     * {String} key of the according symbolizer\n
     */\n
    getSymbolizerPrefix: function(geometry) {\n
        var prefixes = OpenLayers.Style.SYMBOLIZER_PREFIXES;\n
        for (var i=0, len=prefixes.length; i<len; i++) {\n
            if (geometry.CLASS_NAME.indexOf(prefixes[i]) != -1) {\n
                return prefixes[i];\n
            }\n
        }\n
    },\n
    \n
    /**\n
     * APIMethod: clone\n
     * Clones this style.\n
     * \n
     * Returns:\n
     * {<OpenLayers.Style>} Clone of this style.\n
     */\n
    clone: function() {\n
        var options = OpenLayers.Util.extend({}, this);\n
        // clone rules\n
        if(this.rules) {\n
            options.rules = [];\n
            for(var i=0, len=this.rules.length; i<len; ++i) {\n
                options.rules.push(this.rules[i].clone());\n
            }\n
        }\n
        // clone context\n
        options.context = this.context && OpenLayers.Util.extend({}, this.context);\n
        //clone default style\n
        var defaultStyle = OpenLayers.Util.extend({}, this.defaultStyle);\n
        return new OpenLayers.Style(defaultStyle, options);\n
    },\n
    \n
    CLASS_NAME: "OpenLayers.Style"\n
});\n
\n
\n
/**\n
 * Function: createLiteral\n
 * converts a style value holding a combination of PropertyName and Literal\n
 * into a Literal, taking the property values from the passed features.\n
 * \n
 * Parameters:\n
 * value - {String} value to parse. If this string contains a construct like\n
 *         "foo ${bar}", then "foo " will be taken as literal, and "${bar}"\n
 *         will be replaced by the value of the "bar" attribute of the passed\n
 *         feature.\n
 * context - {Object} context to take attribute values from\n
 * feature - {<OpenLayers.Feature.Vector>} optional feature to pass to\n
 *           <OpenLayers.String.format> for evaluating functions in the\n
 *           context.\n
 * property - {String} optional, name of the property for which the literal is\n
 *            being created for evaluating functions in the context.\n
 * \n
 * Returns:\n
 * {String} the parsed value. In the example of the value parameter above, the\n
 * result would be "foo valueOfBar", assuming that the passed feature has an\n
 * attribute named "bar" with the value "valueOfBar".\n
 */\n
OpenLayers.Style.createLiteral = function(value, context, feature, property) {\n
    if (typeof value == "string" && value.indexOf("${") != -1) {\n
        value = OpenLayers.String.format(value, context, [feature, property]);\n
        value = (isNaN(value) || !value) ? value : parseFloat(value);\n
    }\n
    return value;\n
};\n
    \n
/**\n
 * Constant: OpenLayers.Style.SYMBOLIZER_PREFIXES\n
 * {Array} prefixes of the sld symbolizers. These are the\n
 * same as the main geometry types\n
 */\n
OpenLayers.Style.SYMBOLIZER_PREFIXES = [\'Point\', \'Line\', \'Polygon\', \'Text\',\n
    \'Raster\'];\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>14798</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
