<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.87</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>IFrame.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
\n
/**\n
 * @requires OpenLayers/Tile/Image.js\n
 */\n
\n
/**\n
 * Constant: OpenLayers.Tile.Image.IFrame\n
 * Mixin for tiles that use form-encoded POST requests to get images from\n
 * remote services. Images will be loaded using HTTP-POST into an IFrame.\n
 *\n
 * This mixin will be applied to <OpenLayers.Tile.Image> instances\n
 * configured with <OpenLayers.Tile.Image.maxGetUrlLength> set.\n
 */\n
OpenLayers.Tile.Image.IFrame = {\n
\n
    /**\n
     * Property: useIFrame\n
     * {Boolean} true if we are currently using an IFrame to render POST\n
     * responses, false if we are using an img element to render GET responses.\n
     */ \n
    useIFrame: null,\n
\n
    /**\n
     * Method: draw\n
     * Set useIFrame in the instance, and operate the image/iframe switch.\n
     * Then call Tile.Image.draw.\n
     *\n
     * Returns:\n
     * {Boolean}\n
     */\n
    draw: function() {\n
        var draw = OpenLayers.Tile.Image.prototype.shouldDraw.call(this);\n
        if(draw) {\n
\n
            // this.url isn\'t set to the currect value yet, so we call getURL\n
            // on the layer and store the result in a local variable\n
            var url = this.layer.getURL(this.bounds);\n
\n
            var usedIFrame = this.useIFrame;\n
            this.useIFrame = this.maxGetUrlLength !== null &&\n
                             !this.layer.async &&\n
                             url.length > this.maxGetUrlLength;\n
\n
            var fromIFrame = usedIFrame && !this.useIFrame;\n
            var toIFrame = !usedIFrame && this.useIFrame;\n
\n
            if(fromIFrame || toIFrame) {\n
\n
                // Switching between GET (image) and POST (iframe).\n
\n
                // We remove the imgDiv (really either an image or an iframe)\n
                // from the frame and set it to null to make sure initImage\n
                // will call getImage.\n
\n
                if(this.imgDiv && this.imgDiv.parentNode === this.frame) {\n
                    this.frame.removeChild(this.imgDiv);\n
                }\n
                this.imgDiv = null;\n
\n
                // And if we had an iframe we also remove the event pane.\n
\n
                if(fromIFrame) {\n
                    this.blankImageUrl = this._blankImageUrl;\n
                    this.frame.removeChild(this.frame.firstChild);\n
                } else {\n
                    this._blankImageUrl = this.blankImageUrl;\n
                    this.blankImageUrl = "about:blank";\n
                }\n
            }\n
        }\n
        return OpenLayers.Tile.Image.prototype.draw.apply(this, arguments);\n
    },\n
\n
    /**\n
     * Method: getImage\n
     * Creates the content for the frame on the tile.\n
     */\n
    getImage: function() {\n
        if (this.useIFrame === true) {\n
            if (!this.frame.childNodes.length) {\n
                var eventPane = document.createElement("div"),\n
                    style = eventPane.style;\n
                style.position = "absolute";\n
                style.width = "100%";\n
                style.height = "100%";\n
                style.zIndex = 1;\n
                style.backgroundImage = "url(" + this._blankImageUrl + ")";\n
                this.frame.appendChild(eventPane);\n
            }\n
\n
            var id = this.id + \'_iFrame\', iframe;\n
            if (parseFloat(navigator.appVersion.split("MSIE")[1]) < 9) {\n
                // Older IE versions do not set the name attribute of an iFrame \n
                // properly via DOM manipulation, so we need to do it on our own with\n
                // this hack.\n
                iframe = document.createElement(\'<iframe name="\'+id+\'">\');\n
\n
                // IFrames in older IE versions are not transparent, if you set\n
                // the backgroundColor transparent. This is a workaround to get \n
                // transparent iframes.\n
                iframe.style.backgroundColor = \'#FFFFFF\';\n
                iframe.style.filter          = \'chroma(color=#FFFFFF)\';\n
            }\n
            else {\n
                iframe = document.createElement(\'iframe\');\n
                iframe.style.backgroundColor = \'transparent\';\n
\n
                // iframe.name needs to be an unique id, otherwise it \n
                // could happen that other iframes are overwritten.\n
                iframe.name = id;\n
            }\n
\n
            // some special properties to avoid scaling the images and scrollbars \n
            // in the iframe\n
            iframe.scrolling      = \'no\';\n
            iframe.marginWidth    = \'0px\';\n
            iframe.marginHeight   = \'0px\';\n
            iframe.frameBorder    = \'0\';\n
\n
            iframe.style.position = "absolute";\n
            iframe.style.width    = "100%";\n
            iframe.style.height   = "100%";\n
\n
            if (this.layer.opacity < 1) {\n
                OpenLayers.Util.modifyDOMElement(iframe, null, null, null,\n
                    null, null, null, this.layer.opacity);\n
            }\n
            this.frame.appendChild(iframe);\n
            this.imgDiv = iframe;\n
            return iframe;\n
        } else {\n
            return OpenLayers.Tile.Image.prototype.getImage.apply(this, arguments);\n
        }\n
    },\n
    \n
    /**\n
     * Method: createRequestForm\n
     * Create the html <form> element with width, height, bbox and all \n
     * parameters specified in the layer params.\n
     *\n
     * Returns: \n
     * {DOMElement} The form element which sends the HTTP-POST request to the\n
     *              WMS. \n
     */\n
    createRequestForm: function() {\n
        // creation of the form element\n
        var form = document.createElement(\'form\');\n
        form.method = \'POST\';\n
        var cacheId = this.layer.params["_OLSALT"];\n
        cacheId = (cacheId ? cacheId + "_" : "") + this.bounds.toBBOX();\n
        form.action = OpenLayers.Util.urlAppend(this.layer.url, cacheId);\n
        form.target = this.id + \'_iFrame\';\n
\n
        // adding all parameters in layer params as hidden fields to the html\n
        // form element\n
        var imageSize = this.layer.getImageSize(),\n
            params = OpenLayers.Util.getParameters(this.url),\n
            field;\n
            \n
        for(var par in params) {\n
            field = document.createElement(\'input\');\n
            field.type  = \'hidden\';\n
            field.name  = par;\n
            field.value = params[par];\n
            form.appendChild(field);\n
        }   \n
\n
        return form;\n
    },\n
\n
    /**\n
     * Method: setImgSrc\n
     * Sets the source for the tile image\n
     *\n
     * Parameters:\n
     * url - {String}\n
     */\n
    setImgSrc: function(url) {\n
        if (this.useIFrame === true) {\n
            if (url) {\n
                var form = this.createRequestForm();\n
                this.frame.appendChild(form);\n
                form.submit();\n
                this.frame.removeChild(form);\n
            } else if (this.imgDiv.parentNode === this.frame) {\n
                // we don\'t reuse iframes to avoid caching issues\n
                this.frame.removeChild(this.imgDiv);\n
                this.imgDiv = null;\n
            }\n
        } else {\n
            OpenLayers.Tile.Image.prototype.setImgSrc.apply(this, arguments);\n
        }\n
    },\n
    \n
    /**\n
     * Method: onImageLoad\n
     * Handler for the image onload event\n
     */\n
    onImageLoad: function() {\n
        //TODO de-uglify opacity handling\n
        OpenLayers.Tile.Image.prototype.onImageLoad.apply(this, arguments);\n
        if (this.useIFrame === true) {\n
            this.imgDiv.style.opacity = 1;\n
            this.frame.style.opacity = this.layer.opacity;\n
        }\n
    },\n
\n
    /**\n
     * Method: createBackBuffer\n
     * Override createBackBuffer to do nothing when we use an iframe. Moving an\n
     * iframe from one element to another makes it necessary to reload the iframe\n
     * because its content is lost. So we just give up.\n
     *\n
     * Returns:\n
     * {DOMElement}\n
     */\n
    createBackBuffer: function() {\n
        var backBuffer;\n
        if(this.useIFrame === false) {\n
            backBuffer = OpenLayers.Tile.Image.prototype.createBackBuffer.call(this);\n
        }\n
        return backBuffer;\n
    }\n
};\n


]]></string> </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>8150</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
