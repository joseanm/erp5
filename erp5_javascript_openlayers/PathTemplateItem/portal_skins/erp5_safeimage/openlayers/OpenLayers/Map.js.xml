<?xml version="1.0"?>
<ZopeData>
  <record id="1" aka="AAAAAAAAAAE=">
    <pickle>
      <global name="File" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>_EtagSupport__etag</string> </key>
            <value> <string>ts53684100.76</string> </value>
        </item>
        <item>
            <key> <string>__name__</string> </key>
            <value> <string>Map.js</string> </value>
        </item>
        <item>
            <key> <string>content_type</string> </key>
            <value> <string>application/javascript</string> </value>
        </item>
        <item>
            <key> <string>data</string> </key>
            <value>
              <persistent> <string encoding="base64">AAAAAAAAAAI=</string> </persistent>
            </value>
        </item>
        <item>
            <key> <string>precondition</string> </key>
            <value> <string></string> </value>
        </item>
        <item>
            <key> <string>size</string> </key>
            <value> <int>93493</int> </value>
        </item>
        <item>
            <key> <string>title</string> </key>
            <value> <string></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
  <record id="2" aka="AAAAAAAAAAI=">
    <pickle>
      <global name="Pdata" module="OFS.Image"/>
    </pickle>
    <pickle>
      <dictionary>
        <item>
            <key> <string>data</string> </key>
            <value> <string encoding="cdata"><![CDATA[

/* Copyright (c) 2006-2012 by OpenLayers Contributors (see authors.txt for \n
 * full list of contributors). Published under the 2-clause BSD license.\n
 * See license.txt in the OpenLayers distribution or repository for the\n
 * full text of the license. */\n
\n
/**\n
 * @requires OpenLayers/BaseTypes/Class.js\n
 * @requires OpenLayers/Util.js\n
 * @requires OpenLayers/Events.js\n
 * @requires OpenLayers/Tween.js\n
 * @requires OpenLayers/Projection.js\n
 */\n
\n
/**\n
 * Class: OpenLayers.Map\n
 * Instances of OpenLayers.Map are interactive maps embedded in a web page.\n
 * Create a new map with the <OpenLayers.Map> constructor.\n
 * \n
 * On their own maps do not provide much functionality.  To extend a map\n
 * it\'s necessary to add controls (<OpenLayers.Control>) and \n
 * layers (<OpenLayers.Layer>) to the map. \n
 */\n
OpenLayers.Map = OpenLayers.Class({\n
    \n
    /**\n
     * Constant: Z_INDEX_BASE\n
     * {Object} Base z-indexes for different classes of thing \n
     */\n
    Z_INDEX_BASE: {\n
        BaseLayer: 100,\n
        Overlay: 325,\n
        Feature: 725,\n
        Popup: 750,\n
        Control: 1000\n
    },\n
\n
    /**\n
     * APIProperty: events\n
     * {<OpenLayers.Events>}\n
     *\n
     * Register a listener for a particular event with the following syntax:\n
     * (code)\n
     * map.events.register(type, obj, listener);\n
     * (end)\n
     *\n
     * Listeners will be called with a reference to an event object.  The\n
     *     properties of this event depends on exactly what happened.\n
     *\n
     * All event objects have at least the following properties:\n
     * object - {Object} A reference to map.events.object.\n
     * element - {DOMElement} A reference to map.events.element.\n
     *\n
     * Browser events have the following additional properties:\n
     * xy - {<OpenLayers.Pixel>} The pixel location of the event (relative\n
     *     to the the map viewport).\n
     *\n
     * Supported map event types:\n
     * preaddlayer - triggered before a layer has been added.  The event\n
     *     object will include a *layer* property that references the layer  \n
     *     to be added. When a listener returns "false" the adding will be \n
     *     aborted.\n
     * addlayer - triggered after a layer has been added.  The event object\n
     *     will include a *layer* property that references the added layer.\n
     * preremovelayer - triggered before a layer has been removed. The event\n
     *     object will include a *layer* property that references the layer  \n
     *     to be removed. When a listener returns "false" the removal will be \n
     *     aborted.\n
     * removelayer - triggered after a layer has been removed.  The event\n
     *     object will include a *layer* property that references the removed\n
     *     layer.\n
     * changelayer - triggered after a layer name change, order change,\n
     *     opacity change, params change, visibility change (due to resolution\n
     *     thresholds) or attribution change (due to extent change). Listeners\n
     *     will receive an event object with *layer* and *property* properties.\n
     *     The *layer* property will be a reference to the changed layer. The\n
     *     *property* property will be a key to the changed property (name,\n
     *     order, opacity, params, visibility or attribution).\n
     * movestart - triggered after the start of a drag, pan, or zoom\n
     * move - triggered after each drag, pan, or zoom\n
     * moveend - triggered after a drag, pan, or zoom completes\n
     * zoomend - triggered after a zoom completes\n
     * mouseover - triggered after mouseover the map\n
     * mouseout - triggered after mouseout the map\n
     * mousemove - triggered after mousemove the map\n
     * changebaselayer - triggered after the base layer changes\n
     */\n
\n
    /**\n
     * Property: id\n
     * {String} Unique identifier for the map\n
     */\n
    id: null,\n
    \n
    /**\n
     * Property: fractionalZoom\n
     * {Boolean} For a base layer that supports it, allow the map resolution\n
     *     to be set to a value between one of the values in the resolutions\n
     *     array.  Default is false.\n
     *\n
     * When fractionalZoom is set to true, it is possible to zoom to\n
     *     an arbitrary extent.  This requires a base layer from a source\n
     *     that supports requests for arbitrary extents (i.e. not cached\n
     *     tiles on a regular lattice).  This means that fractionalZoom\n
     *     will not work with commercial layers (Google, Yahoo, VE), layers\n
     *     using TileCache, or any other pre-cached data sources.\n
     *\n
     * If you are using fractionalZoom, then you should also use\n
     *     <getResolutionForZoom> instead of layer.resolutions[zoom] as the\n
     *     former works for non-integer zoom levels.\n
     */\n
    fractionalZoom: false,\n
    \n
    /**\n
     * APIProperty: events\n
     * {<OpenLayers.Events>} An events object that handles all \n
     *                       events on the map\n
     */\n
    events: null,\n
    \n
    /**\n
     * APIProperty: allOverlays\n
     * {Boolean} Allow the map to function with "overlays" only.  Defaults to\n
     *     false.  If true, the lowest layer in the draw order will act as\n
     *     the base layer.  In addition, if set to true, all layers will\n
     *     have isBaseLayer set to false when they are added to the map.\n
     *\n
     * Note:\n
     * If you set map.allOverlays to true, then you *cannot* use\n
     *     map.setBaseLayer or layer.setIsBaseLayer.  With allOverlays true,\n
     *     the lowest layer in the draw layer is the base layer.  So, to change\n
     *     the base layer, use <setLayerIndex> or <raiseLayer> to set the layer\n
     *     index to 0.\n
     */\n
    allOverlays: false,\n
\n
    /**\n
     * APIProperty: div\n
     * {DOMElement|String} The element that contains the map (or an id for\n
     *     that element).  If the <OpenLayers.Map> constructor is called\n
     *     with two arguments, this should be provided as the first argument.\n
     *     Alternatively, the map constructor can be called with the options\n
     *     object as the only argument.  In this case (one argument), a\n
     *     div property may or may not be provided.  If the div property\n
     *     is not provided, the map can be rendered to a container later\n
     *     using the <render> method.\n
     *     \n
     * Note:\n
     * If you are calling <render> after map construction, do not use\n
     *     <maxResolution>  auto.  Instead, divide your <maxExtent> by your\n
     *     maximum expected dimension.\n
     */\n
    div: null,\n
    \n
    /**\n
     * Property: dragging\n
     * {Boolean} The map is currently being dragged.\n
     */\n
    dragging: false,\n
\n
    /**\n
     * Property: size\n
     * {<OpenLayers.Size>} Size of the main div (this.div)\n
     */\n
    size: null,\n
    \n
    /**\n
     * Property: viewPortDiv\n
     * {HTMLDivElement} The element that represents the map viewport\n
     */\n
    viewPortDiv: null,\n
\n
    /**\n
     * Property: layerContainerOrigin\n
     * {<OpenLayers.LonLat>} The lonlat at which the later container was\n
     *                       re-initialized (on-zoom)\n
     */\n
    layerContainerOrigin: null,\n
\n
    /**\n
     * Property: layerContainerDiv\n
     * {HTMLDivElement} The element that contains the layers.\n
     */\n
    layerContainerDiv: null,\n
\n
    /**\n
     * APIProperty: layers\n
     * {Array(<OpenLayers.Layer>)} Ordered list of layers in the map\n
     */\n
    layers: null,\n
\n
    /**\n
     * APIProperty: controls\n
     * {Array(<OpenLayers.Control>)} List of controls associated with the map.\n
     *\n
     * If not provided in the map options at construction, the map will\n
     *     by default be given the following controls if present in the build:\n
     *  - <OpenLayers.Control.Navigation> or <OpenLayers.Control.TouchNavigation>\n
     *  - <OpenLayers.Control.Zoom> or <OpenLayers.Control.PanZoom>\n
     *  - <OpenLayers.Control.ArgParser>\n
     *  - <OpenLayers.Control.Attribution>\n
     */\n
    controls: null,\n
\n
    /**\n
     * Property: popups\n
     * {Array(<OpenLayers.Popup>)} List of popups associated with the map\n
     */\n
    popups: null,\n
\n
    /**\n
     * APIProperty: baseLayer\n
     * {<OpenLayers.Layer>} The currently selected base layer.  This determines\n
     * min/max zoom level, projection, etc.\n
     */\n
    baseLayer: null,\n
    \n
    /**\n
     * Property: center\n
     * {<OpenLayers.LonLat>} The current center of the map\n
     */\n
    center: null,\n
\n
    /**\n
     * Property: resolution\n
     * {Float} The resolution of the map.\n
     */\n
    resolution: null,\n
\n
    /**\n
     * Property: zoom\n
     * {Integer} The current zoom level of the map\n
     */\n
    zoom: 0,    \n
\n
    /**\n
     * Property: panRatio\n
     * {Float} The ratio of the current extent within\n
     *         which panning will tween.\n
     */\n
    panRatio: 1.5,    \n
\n
    /**\n
     * APIProperty: options\n
     * {Object} The options object passed to the class constructor. Read-only.\n
     */\n
    options: null,\n
\n
  // Options\n
\n
    /**\n
     * APIProperty: tileSize\n
     * {<OpenLayers.Size>} Set in the map options to override the default tile\n
     *                     size for this map.\n
     */\n
    tileSize: null,\n
\n
    /**\n
     * APIProperty: projection\n
     * {String} Set in the map options to specify the default projection \n
     *          for layers added to this map. When using a projection other than EPSG:4326\n
     *          (CRS:84, Geographic) or EPSG:3857 (EPSG:900913, Web Mercator),\n
     *          also set maxExtent, maxResolution or resolutions.  Default is "EPSG:4326".\n
     *          Note that the projection of the map is usually determined\n
     *          by that of the current baseLayer (see <baseLayer> and <getProjectionObject>).\n
     */\n
    projection: "EPSG:4326",    \n
        \n
    /**\n
     * APIProperty: units\n
     * {String} The map units.  Possible values are \'degrees\' (or \'dd\'), \'m\', \n
     *     \'ft\', \'km\', \'mi\', \'inches\'.  Normally taken from the projection.\n
     *     Only required if both map and layers do not define a projection,\n
     *     or if they define a projection which does not define units\n
     */\n
    units: null,\n
\n
    /**\n
     * APIProperty: resolutions\n
     * {Array(Float)} A list of map resolutions (map units per pixel) in \n
     *     descending order.  If this is not set in the layer constructor, it \n
     *     will be set based on other resolution related properties \n
     *     (maxExtent, maxResolution, maxScale, etc.).\n
     */\n
    resolutions: null,\n
\n
    /**\n
     * APIProperty: maxResolution\n
     * {Float} Required if you are not displaying the whole world on a tile\n
     * with the size specified in <tileSize>.\n
     */\n
    maxResolution: null,\n
\n
    /**\n
     * APIProperty: minResolution\n
     * {Float}\n
     */\n
    minResolution: null,\n
\n
    /**\n
     * APIProperty: maxScale\n
     * {Float}\n
     */\n
    maxScale: null,\n
\n
    /**\n
     * APIProperty: minScale\n
     * {Float}\n
     */\n
    minScale: null,\n
\n
    /**\n
     * APIProperty: maxExtent\n
     * {<OpenLayers.Bounds>|Array} If provided as an array, the array\n
     *     should consist of four values (left, bottom, right, top).\n
     *     The maximum extent for the map.  Defaults to the\n
     *     whole world in decimal degrees (-180, -90, 180, 90).  Specify a \n
     *     different extent in the map options if you are not using a geographic\n
     *     projection and displaying the whole  world. To restrict user panning\n
     *     and zooming of the map, use <restrictedExtent> instead.  The value \n
     *     for <maxExtent> will change calculations for tile URLs.\n
     */\n
    maxExtent: null,\n
    \n
    /**\n
     * APIProperty: minExtent\n
     * {<OpenLayers.Bounds>|Array} If provided as an array, the array\n
     *     should consist of four values (left, bottom, right, top).\n
     *     The minimum extent for the map.  Defaults to null.\n
     */\n
    minExtent: null,\n
    \n
    /**\n
     * APIProperty: restrictedExtent\n
     * {<OpenLayers.Bounds>|Array} If provided as an array, the array\n
     *     should consist of four values (left, bottom, right, top).\n
     *     Limit map navigation to this extent where possible.\n
     *     If a non-null restrictedExtent is set, panning will be restricted\n
     *     to the given bounds.  In addition, zooming to a resolution that\n
     *     displays more than the restricted extent will center the map\n
     *     on the restricted extent.  If you wish to limit the zoom level\n
     *     or resolution, use maxResolution.\n
     */\n
    restrictedExtent: null,\n
\n
    /**\n
     * APIProperty: numZoomLevels\n
     * {Integer} Number of zoom levels for the map.  Defaults to 16.  Set a\n
     *           different value in the map options if needed.\n
     */\n
    numZoomLevels: 16,\n
\n
    /**\n
     * APIProperty: theme\n
     * {String} Relative path to a CSS file from which to load theme styles.\n
     *          Specify null in the map options (e.g. {theme: null}) if you \n
     *          want to get cascading style declarations - by putting links to \n
     *          stylesheets or style declarations directly in your page.\n
     */\n
    theme: null,\n
    \n
    /** \n
     * APIProperty: displayProjection\n
     * {<OpenLayers.Projection>} Requires proj4js support for projections other\n
     *     than EPSG:4326 or EPSG:900913/EPSG:3857. Projection used by\n
     *     several controls to display data to user. If this property is set,\n
     *     it will be set on any control which has a null displayProjection\n
     *     property at the time the control is added to the map. \n
     */\n
    displayProjection: null,\n
\n
    /**\n
     * APIProperty: fallThrough\n
     * {Boolean} Should OpenLayers allow events on the map to fall through to\n
     *           other elements on the page, or should it swallow them? (#457)\n
     *           Default is to fall through.\n
     */\n
    fallThrough: true,\n
    \n
    /**\n
     * Property: panTween\n
     * {<OpenLayers.Tween>} Animated panning tween object, see panTo()\n
     */\n
    panTween: null,\n
\n
    /**\n
     * APIProperty: eventListeners\n
     * {Object} If set as an option at construction, the eventListeners\n
     *     object will be registered with <OpenLayers.Events.on>.  Object\n
     *     structure must be a listeners object as shown in the example for\n
     *     the events.on method.\n
     */\n
    eventListeners: null,\n
\n
    /**\n
     * APIProperty: panMethod\n
     * {Function} The Easing function to be used for tweening.  Default is\n
     * OpenLayers.Easing.Expo.easeOut. Setting this to \'null\' turns off\n
     * animated panning.\n
     */\n
    panMethod: OpenLayers.Easing.Expo.easeOut,\n
    \n
    /**\n
     * Property: panDuration\n
     * {Integer} The number of steps to be passed to the\n
     * OpenLayers.Tween.start() method when the map is\n
     * panned.\n
     * Default is 50.\n
     */\n
    panDuration: 50,\n
    \n
    /**\n
     * Property: paddingForPopups\n
     * {<OpenLayers.Bounds>} Outside margin of the popup. Used to prevent \n
     *     the popup from getting too close to the map border.\n
     */\n
    paddingForPopups : null,\n
    \n
    /**\n
     * Property: minPx\n
     * {Object} An object with a \'x\' and \'y\' values that is the lower\n
     *     left of maxExtent in viewport pixel space.\n
     *     Used to verify in moveByPx that the new location we\'re moving to\n
     *     is valid. It is also used in the getLonLatFromViewPortPx function\n
     *     of Layer.\n
     */\n
    minPx: null,\n
    \n
    /**\n
     * Property: maxPx\n
     * {Object} An object with a \'x\' and \'y\' values that is the top\n
     *     right of maxExtent in viewport pixel space.\n
     *     Used to verify in moveByPx that the new location we\'re moving to\n
     *     is valid.\n
     */\n
    maxPx: null,\n
    \n
    /**\n
     * Constructor: OpenLayers.Map\n
     * Constructor for a new OpenLayers.Map instance.  There are two possible\n
     *     ways to call the map constructor.  See the examples below.\n
     *\n
     * Parameters:\n
     * div - {DOMElement|String}  The element or id of an element in your page\n
     *     that will contain the map.  May be omitted if the <div> option is\n
     *     provided or if you intend to call the <render> method later.\n
     * options - {Object} Optional object with properties to tag onto the map.\n
     *\n
     * Valid options (in addition to the listed API properties):\n
     * center - {<OpenLayers.LonLat>|Array} The default initial center of the map.\n
     *     If provided as array, the first value is the x coordinate,\n
     *     and the 2nd value is the y coordinate.\n
     *     Only specify if <layers> is provided.\n
     *     Note that if an ArgParser/Permalink control is present,\n
     *     and the querystring contains coordinates, center will be set\n
     *     by that, and this option will be ignored.\n
     * zoom - {Number} The initial zoom level for the map. Only specify if\n
     *     <layers> is provided.\n
     *     Note that if an ArgParser/Permalink control is present,\n
     *     and the querystring contains a zoom level, zoom will be set\n
     *     by that, and this option will be ignored.\n
     * extent - {<OpenLayers.Bounds>|Array} The initial extent of the map.\n
     *     If provided as an array, the array should consist of\n
     *     four values (left, bottom, right, top).\n
     *     Only specify if <center> and <zoom> are not provided.\n
     * \n
     * Examples:\n
     * (code)\n
     * // create a map with default options in an element with the id "map1"\n
     * var map = new OpenLayers.Map("map1");\n
     *\n
     * // create a map with non-default options in an element with id "map2"\n
     * var options = {\n
     *     projection: "EPSG:3857",\n
     *     maxExtent: new OpenLayers.Bounds(-200000, -200000, 200000, 200000),\n
     *     center: new OpenLayers.LonLat(-12356463.476333, 5621521.4854095)\n
     * };\n
     * var map = new OpenLayers.Map("map2", options);\n
     *\n
     * // map with non-default options - same as above but with a single argument,\n
     * // a restricted extent, and using arrays for bounds and center\n
     * var map = new OpenLayers.Map({\n
     *     div: "map_id",\n
     *     projection: "EPSG:3857",\n
     *     maxExtent: [-18924313.432222, -15538711.094146, 18924313.432222, 15538711.094146],\n
     *     restrictedExtent: [-13358338.893333, -9608371.5085962, 13358338.893333, 9608371.5085962],\n
     *     center: [-12356463.476333, 5621521.4854095]\n
     * });\n
     *\n
     * // create a map without a reference to a container - call render later\n
     * var map = new OpenLayers.Map({\n
     *     projection: "EPSG:3857",\n
     *     maxExtent: new OpenLayers.Bounds(-200000, -200000, 200000, 200000)\n
     * });\n
     * (end)\n
     */    \n
    initialize: function (div, options) {\n
        \n
        // If only one argument is provided, check if it is an object.\n
        if(arguments.length === 1 && typeof div === "object") {\n
            options = div;\n
            div = options && options.div;\n
        }\n
\n
        // Simple-type defaults are set in class definition. \n
        //  Now set complex-type defaults \n
        this.tileSize = new OpenLayers.Size(OpenLayers.Map.TILE_WIDTH,\n
                                            OpenLayers.Map.TILE_HEIGHT);\n
        \n
        this.paddingForPopups = new OpenLayers.Bounds(15, 15, 15, 15);\n
\n
        this.theme = OpenLayers._getScriptLocation() + \n
                             \'theme/default/style.css\'; \n
\n
        // backup original options\n
        this.options = OpenLayers.Util.extend({}, options);\n
\n
        // now override default options \n
        OpenLayers.Util.extend(this, options);\n
        \n
        var projCode = this.projection instanceof OpenLayers.Projection ?\n
            this.projection.projCode : this.projection;\n
        OpenLayers.Util.applyDefaults(this, OpenLayers.Projection.defaults[projCode]);\n
        \n
        // allow extents and center to be arrays\n
        if (this.maxExtent && !(this.maxExtent instanceof OpenLayers.Bounds)) {\n
            this.maxExtent = new OpenLayers.Bounds(this.maxExtent);\n
        }\n
        if (this.minExtent && !(this.minExtent instanceof OpenLayers.Bounds)) {\n
            this.minExtent = new OpenLayers.Bounds(this.minExtent);\n
        }\n
        if (this.restrictedExtent && !(this.restrictedExtent instanceof OpenLayers.Bounds)) {\n
            this.restrictedExtent = new OpenLayers.Bounds(this.restrictedExtent);\n
        }\n
        if (this.center && !(this.center instanceof OpenLayers.LonLat)) {\n
            this.center = new OpenLayers.LonLat(this.center);\n
        }\n
\n
        // initialize layers array\n
        this.layers = [];\n
\n
        this.id = OpenLayers.Util.createUniqueID("OpenLayers.Map_");\n
\n
        this.div = OpenLayers.Util.getElement(div);\n
        if(!this.div) {\n
            this.div = document.createElement("div");\n
            this.div.style.height = "1px";\n
            this.div.style.width = "1px";\n
        }\n
        \n
        OpenLayers.Element.addClass(this.div, \'olMap\');\n
\n
        // the viewPortDiv is the outermost div we modify\n
        var id = this.id + "_OpenLayers_ViewPort";\n
        this.viewPortDiv = OpenLayers.Util.createDiv(id, null, null, null,\n
                                                     "relative", null,\n
                                                     "hidden");\n
        this.viewPortDiv.style.width = "100%";\n
        this.viewPortDiv.style.height = "100%";\n
        this.viewPortDiv.className = "olMapViewport";\n
        this.div.appendChild(this.viewPortDiv);\n
\n
        this.events = new OpenLayers.Events(\n
            this, this.viewPortDiv, null, this.fallThrough, \n
            {includeXY: true}\n
        );\n
\n
        // the layerContainerDiv is the one that holds all the layers\n
        id = this.id + "_OpenLayers_Container";\n
        this.layerContainerDiv = OpenLayers.Util.createDiv(id);\n
        this.layerContainerDiv.style.width = \'100px\';\n
        this.layerContainerDiv.style.height = \'100px\';\n
        this.layerContainerDiv.style.zIndex=this.Z_INDEX_BASE[\'Popup\']-1;\n
        \n
        this.viewPortDiv.appendChild(this.layerContainerDiv);\n
\n
        this.updateSize();\n
        if(this.eventListeners instanceof Object) {\n
            this.events.on(this.eventListeners);\n
        }\n
 \n
        // Because Mozilla does not support the "resize" event for elements \n
        // other than "window", we need to put a hack here. \n
        if (parseFloat(navigator.appVersion.split("MSIE")[1]) < 9) {\n
            // If IE < 9, register the resize on the div\n
            this.events.register("resize", this, this.updateSize);\n
        } else {\n
            // Else updateSize on catching the window\'s resize\n
            //  Note that this is ok, as updateSize() does nothing if the \n
            //  map\'s size has not actually changed.\n
            this.updateSizeDestroy = OpenLayers.Function.bind(this.updateSize, \n
                this);\n
            OpenLayers.Event.observe(window, \'resize\',\n
                            this.updateSizeDestroy);\n
        }\n
        \n
        // only append link stylesheet if the theme property is set\n
        if(this.theme) {\n
            // check existing links for equivalent url\n
            var addNode = true;\n
            var nodes = document.getElementsByTagName(\'link\');\n
            for(var i=0, len=nodes.length; i<len; ++i) {\n
                if(OpenLayers.Util.isEquivalentUrl(nodes.item(i).href,\n
                                                   this.theme)) {\n
                    addNode = false;\n
                    break;\n
                }\n
            }\n
            // only add a new node if one with an equivalent url hasn\'t already\n
            // been added\n
            if(addNode) {\n
                var cssNode = document.createElement(\'link\');\n
                cssNode.setAttribute(\'rel\', \'stylesheet\');\n
                cssNode.setAttribute(\'type\', \'text/css\');\n
                cssNode.setAttribute(\'href\', this.theme);\n
                document.getElementsByTagName(\'head\')[0].appendChild(cssNode);\n
            }\n
        }\n
        \n
        if (this.controls == null) { // default controls\n
            this.controls = [];\n
            if (OpenLayers.Control != null) { // running full or lite?\n
                // Navigation or TouchNavigation depending on what is in build\n
                if (OpenLayers.Control.Navigation) {\n
                    this.controls.push(new OpenLayers.Control.Navigation());\n
                } else if (OpenLayers.Control.TouchNavigation) {\n
                    this.controls.push(new OpenLayers.Control.TouchNavigation());\n
                }\n
                if (OpenLayers.Control.Zoom) {\n
                    this.controls.push(new OpenLayers.Control.Zoom());\n
                } else if (OpenLayers.Control.PanZoom) {\n
                    this.controls.push(new OpenLayers.Control.PanZoom());\n
                }\n
\n
                if (OpenLayers.Control.ArgParser) {\n
                    this.controls.push(new OpenLayers.Control.ArgParser());\n
                }\n
                if (OpenLayers.Control.Attribution) {\n
                    this.controls.push(new OpenLayers.Control.Attribution());\n
                }\n
            }\n
        }\n
\n
        for(var i=0, len=this.controls.length; i<len; i++) {\n
            this.addControlToMap(this.controls[i]);\n
        }\n
\n
        this.popups = [];\n
\n
        this.unloadDestroy = OpenLayers.Function.bind(this.destroy, this);\n
        \n
\n
        // always call map.destroy()\n
        OpenLayers.Event.observe(window, \'unload\', this.unloadDestroy);\n
        \n
        // add any initial layers\n
        if (options && options.layers) {\n
            /** \n
             * If you have set options.center, the map center property will be\n
             * set at this point.  However, since setCenter has not been called,\n
             * addLayers gets confused.  So we delete the map center in this \n
             * case.  Because the check below uses options.center, it will\n
             * be properly set below.\n
             */\n
            delete this.center;\n
            this.addLayers(options.layers);\n
            // set center (and optionally zoom)\n
            if (options.center && !this.getCenter()) {\n
                // zoom can be undefined here\n
                this.setCenter(options.center, options.zoom);\n
            }\n
        }\n
    },\n
\n
    /** \n
     * APIMethod: getViewport\n
     * Get the DOMElement representing the view port.\n
     *\n
     * Returns:\n
     * {DOMElement}\n
     */\n
    getViewport: function() {\n
        return this.viewPortDiv;\n
    },\n
    \n
    /**\n
     * APIMethod: render\n
     * Render the map to a specified container.\n
     * \n
     * Parameters:\n
     * div - {String|DOMElement} The container that the map should be rendered\n
     *     to. If different than the current container, the map viewport\n
     *     will be moved from the current to the new container.\n
     */\n
    render: function(div) {\n
        this.div = OpenLayers.Util.getElement(div);\n
        OpenLayers.Element.addClass(this.div, \'olMap\');\n
        this.viewPortDiv.parentNode.removeChild(this.viewPortDiv);\n
        this.div.appendChild(this.viewPortDiv);\n
        this.updateSize();\n
    },\n
\n
    /**\n
     * Method: unloadDestroy\n
     * Function that is called to destroy the map on page unload. stored here\n
     *     so that if map is manually destroyed, we can unregister this.\n
     */\n
    unloadDestroy: null,\n
    \n
    /**\n
     * Method: updateSizeDestroy\n
     * When the map is destroyed, we need to stop listening to updateSize\n
     *    events: this method stores the function we need to unregister in \n
     *    non-IE browsers.\n
     */\n
    updateSizeDestroy: null,\n
\n
    /**\n
     * APIMethod: destroy\n
     * Destroy this map.\n
     *    Note that if you are using an application which removes a container\n
     *    of the map from the DOM, you need to ensure that you destroy the\n
     *    map *before* this happens; otherwise, the page unload handler\n
     *    will fail because the DOM elements that map.destroy() wants\n
     *    to clean up will be gone. (See \n
     *    http://trac.osgeo.org/openlayers/ticket/2277 for more information).\n
     *    This will apply to GeoExt and also to other applications which\n
     *    modify the DOM of the container of the OpenLayers Map.\n
     */\n
    destroy:function() {\n
        // if unloadDestroy is null, we\'ve already been destroyed\n
        if (!this.unloadDestroy) {\n
            return false;\n
        }\n
        \n
        // make sure panning doesn\'t continue after destruction\n
        if(this.panTween) {\n
            this.panTween.stop();\n
            this.panTween = null;\n
        }\n
\n
        // map has been destroyed. dont do it again!\n
        OpenLayers.Event.stopObserving(window, \'unload\', this.unloadDestroy);\n
        this.unloadDestroy = null;\n
\n
        if (this.updateSizeDestroy) {\n
            OpenLayers.Event.stopObserving(window, \'resize\', \n
                                           this.updateSizeDestroy);\n
        } else {\n
            this.events.unregister("resize", this, this.updateSize);\n
        }    \n
        \n
        this.paddingForPopups = null;    \n
\n
        if (this.controls != null) {\n
            for (var i = this.controls.length - 1; i>=0; --i) {\n
                this.controls[i].destroy();\n
            } \n
            this.controls = null;\n
        }\n
        if (this.layers != null) {\n
            for (var i = this.layers.length - 1; i>=0; --i) {\n
                //pass \'false\' to destroy so that map wont try to set a new \n
                // baselayer after each baselayer is removed\n
                this.layers[i].destroy(false);\n
            } \n
            this.layers = null;\n
        }\n
        if (this.viewPortDiv) {\n
            this.div.removeChild(this.viewPortDiv);\n
        }\n
        this.viewPortDiv = null;\n
\n
        if(this.eventListeners) {\n
            this.events.un(this.eventListeners);\n
            this.eventListeners = null;\n
        }\n
        this.events.destroy();\n
        this.events = null;\n
\n
        this.options = null;\n
    },\n
\n
    /**\n
     * APIMethod: setOptions\n
     * Change the map options\n
     *\n
     * Parameters:\n
     * options - {Object} Hashtable of options to tag to the map\n
     */\n
    setOptions: function(options) {\n
        var updatePxExtent = this.minPx &&\n
            options.restrictedExtent != this.restrictedExtent;\n
        OpenLayers.Util.extend(this, options);\n
        // force recalculation of minPx and maxPx\n
        updatePxExtent && this.moveTo(this.getCachedCenter(), this.zoom, {\n
            forceZoomChange: true\n
        });\n
    },\n
\n
    /**\n
     * APIMethod: getTileSize\n
     * Get the tile size for the map\n
     *\n
     * Returns:\n
     * {<OpenLayers.Size>}\n
     */\n
     getTileSize: function() {\n
         return this.tileSize;\n
     },\n
\n
\n
    /**\n
     * APIMethod: getBy\n
     * Get a list of objects given a property and a match item.\n
     *\n
     * Parameters:\n
     * array - {String} A property on the map whose value is an array.\n
     * property - {String} A property on each item of the given array.\n
     * match - {String | Object} A string to match.  Can also be a regular\n
     *     expression literal or object.  In addition, it can be any object\n
     *     with a method named test.  For reqular expressions or other, if\n
     *     match.test(map[array][i][property]) evaluates to true, the item will\n
     *     be included in the array returned.  If no items are found, an empty\n
     *     array is returned.\n
     *\n
     * Returns:\n
     * {Array} An array of items where the given property matches the given\n
     *     criteria.\n
     */\n
    getBy: function(array, property, match) {\n
        var test = (typeof match.test == "function");\n
        var found = OpenLayers.Array.filter(this[array], function(item) {\n
            return item[property] == match || (test && match.test(item[property]));\n
        });\n
        return found;\n
    },\n
\n
    /**\n
     * APIMethod: getLayersBy\n
     * Get a list of layers with properties matching the given criteria.\n
     *\n
     * Parameters:\n
     * property - {String} A layer property to be matched.\n
     * match - {String | Object} A string to match.  Can also be a regular\n
     *     expression literal or object.  In addition, it can be any object\n
     *     with a method named test.  For reqular expressions or other, if\n
     *     match.test(layer[property]) evaluates to true, the layer will be\n
     *     included in the array returned.  If no layers are found, an empty\n
     *     array is returned.\n
     *\n
     * Returns:\n
     * {Array(<OpenLayers.Layer>)} A list of layers matching the given criteria.\n
     *     An empty array is returned if no matches are found.\n
     */\n
    getLayersBy: function(property, match) {\n
        return this.getBy("layers", property, match);\n
    },\n
\n
    /**\n
     * APIMethod: getLayersByName\n
     * Get a list of layers with names matching the given name.\n
     *\n
     * Parameters:\n
     * match - {String | Object} A layer name.  The name can also be a regular\n
     *     expression literal or object.  In addition, it can be any object\n
     *     with a method named test.  For reqular expressions or other, if\n
     *     name.test(layer.name) evaluates to true, the layer will be included\n
     *     in the list of layers returned.  If no layers are found, an empty\n
     *     array is returned.\n
     *\n
     * Returns:\n
     * {Array(<OpenLayers.Layer>)} A list of layers matching the given name.\n
     *     An empty array is returned if no matches are found.\n
     */\n
    getLayersByName: function(match) {\n
        return this.getLayersBy("name", match);\n
    },\n
\n
    /**\n
     * APIMethod: getLayersByClass\n
     * Get a list of layers of a given class (CLASS_NAME).\n
     *\n
     * Parameters:\n
     * match - {String | Object} A layer class name.  The match can also be a\n
     *     regular expression literal or object.  In addition, it can be any\n
     *     object with a method named test.  For reqular expressions or other,\n
     *     if type.test(layer.CLASS_NAME) evaluates to true, the layer will\n
     *     be included in the list of layers returned.  If no layers are\n
     *     found, an empty array is returned.\n
     *\n
     * Returns:\n
     * {Array(<OpenLayers.Layer>)} A list of layers matching the given class.\n
     *     An empty array is returned if no matches are found.\n
     */\n
    getLayersByClass: function(match) {\n
        return this.getLayersBy("CLASS_NAME", match);\n
    },\n
\n
    /**\n
     * APIMethod: getControlsBy\n
     * Get a list of controls with properties matching the given criteria.\n
     *\n
     * Parameters:\n
     * property - {String} A control property to be matched.\n
     * match - {String | Object} A string to match.  Can also be a regular\n
     *     expression literal or object.  In addition, it can be any object\n
     *     with a method named test.  For reqular expressions or other, if\n
     *     match.test(layer[property]) evaluates to true, the layer will be\n
     *     included in the array returned.  If no layers are found, an empty\n
     *     array is returned.\n
     *\n
     * Returns:\n
     * {Array(<OpenLayers.Control>)} A list of controls matching the given\n
     *     criteria.  An empty array is returned if no matches are found.\n
     */\n
    getControlsBy: function(property, match) {\n
        return this.getBy("controls", property, match);\n
    },\n
\n
    /**\n
     * APIMethod: getControlsByClass\n
     * Get a list of controls of a given class (CLASS_NAME).\n
     *\n
     * Parameters:\n
     * match - {String | Object} A control class name.  The match can also be a\n
     *     regular expression literal or object.  In addition, it can be any\n
     *     object with a method named test.  For reqular expressions or other,\n
     *     if type.test(control.CLASS_NAME) evaluates to true, the control will\n
     *     be included in the list of controls returned.  If no controls are\n
     *     found, an empty array is returned.\n
     *\n
     * Returns:\n
     * {Array(<OpenLayers.Control>)} A list of controls matching the given class.\n
     *     An empty array is returned if no matches are found.\n
     */\n
    getControlsByClass: function(match) {\n
        return this.getControlsBy("CLASS_NAME", match);\n
    },\n
\n
  /********************************************************/\n
  /*                                                      */\n
  /*                  Layer Functions                     */\n
  /*                                                      */\n
  /*     The following functions deal with adding and     */\n
  /*        removing Layers to and from the Map           */\n
  /*                                                      */\n
  /********************************************************/         \n
\n
    /**\n
     * APIMethod: getLayer\n
     * Get a layer based on its id\n
     *\n
     * Parameters:\n
     * id - {String} A layer id\n
     *\n
     * Returns:\n
     * {<OpenLayers.Layer>} The Layer with the corresponding id from the map\'s \n
     *                      layer collection, or null if not found.\n
     */\n
    getLayer: function(id) {\n
        var foundLayer = null;\n
        for (var i=0, len=this.layers.length; i<len; i++) {\n
            var layer = this.layers[i];\n
            if (layer.id == id) {\n
                foundLayer = layer;\n
                break;\n
            }\n
        }\n
        return foundLayer;\n
    },\n
\n
    /**\n
    * Method: setLayerZIndex\n
    * \n
    * Parameters:\n
    * layer - {<OpenLayers.Layer>} \n
    * zIdx - {int} \n
    */    \n
    setLayerZIndex: function (layer, zIdx) {\n
        layer.setZIndex(\n
            this.Z_INDEX_BASE[layer.isBaseLayer ? \'BaseLayer\' : \'Overlay\']\n
            + zIdx * 5 );\n
    },\n
\n
    /**\n
     * Method: resetLayersZIndex\n
     * Reset each layer\'s z-index based on layer\'s array index\n
     */\n
    resetLayersZIndex: function() {\n
        for (var i=0, len=this.layers.length; i<len; i++) {\n
            var layer = this.layers[i];\n
            this.setLayerZIndex(layer, i);\n
        }\n
    },\n
\n
    /**\n
    * APIMethod: addLayer\n
    *\n
    * Parameters:\n
    * layer - {<OpenLayers.Layer>} \n
    *\n
    * Returns:\n
    * {Boolean} True if the layer has been added to the map.\n
    */    \n
    addLayer: function (layer) {\n
        for(var i = 0, len = this.layers.length; i < len; i++) {\n
            if (this.layers[i] == layer) {\n
                return false;\n
            }\n
        }\n
        if (this.events.triggerEvent("preaddlayer", {layer: layer}) === false) {\n
            return false;\n
        }\n
        if(this.allOverlays) {\n
            layer.isBaseLayer = false;\n
        }\n
        \n
        layer.div.className = "olLayerDiv";\n
        layer.div.style.overflow = "";\n
        this.setLayerZIndex(layer, this.layers.length);\n
\n
        if (layer.isFixed) {\n
            this.viewPortDiv.appendChild(layer.div);\n
        } else {\n
            this.layerContainerDiv.appendChild(layer.div);\n
        }\n
        this.layers.push(layer);\n
        layer.setMap(this);\n
\n
        if (layer.isBaseLayer || (this.allOverlays && !this.baseLayer))  {\n
            if (this.baseLayer == null) {\n
                // set the first baselaye we add as the baselayer\n
                this.setBaseLayer(layer);\n
            } else {\n
                layer.setVisibility(false);\n
            }\n
        } else {\n
            layer.redraw();\n
        }\n
\n
        this.events.triggerEvent("addlayer", {layer: layer});\n
        layer.events.triggerEvent("added", {map: this, layer: layer});\n
        layer.afterAdd();\n
\n
        return true;\n
    },\n
\n
    /**\n
    * APIMethod: addLayers \n
    *\n
    * Parameters:\n
    * layers - {Array(<OpenLayers.Layer>)} \n
    */    \n
    addLayers: function (layers) {\n
        for (var i=0, len=layers.length; i<len; i++) {\n
            this.addLayer(layers[i]);\n
        }\n
    },\n
\n
    /** \n
     * APIMethod: removeLayer\n
     * Removes a layer from the map by removing its visual element (the \n
     *   layer.div property), then removing it from the map\'s internal list \n
     *   of layers, setting the layer\'s map property to null. \n
     * \n
     *   a "removelayer" event is triggered.\n
     * \n
     *   very worthy of mention is that simply removing a layer from a map\n
     *   will not cause the removal of any popups which may have been created\n
     *   by the layer. this is due to the fact that it was decided at some\n
     *   point that popups would not belong to layers. thus there is no way \n
     *   for us to know here to which layer the popup belongs.\n
     *    \n
     *     A simple solution to this is simply to call destroy() on the layer.\n
     *     the default OpenLayers.Layer class\'s destroy() function\n
     *     automatically takes care to remove itself from whatever map it has\n
     *     been attached to. \n
     * \n
     *     The correct solution is for the layer itself to register an \n
     *     event-handler on "removelayer" and when it is called, if it \n
     *     recognizes itself as the layer being removed, then it cycles through\n
     *     its own personal list of popups, removing them from the map.\n
     * \n
     * Parameters:\n
     * layer - {<OpenLayers.Layer>} \n
     * setNewBaseLayer - {Boolean} Default is true\n
     */\n
    removeLayer: function(layer, setNewBaseLayer) {\n
        if (this.events.triggerEvent("preremovelayer", {layer: layer}) === false) {\n
            return;\n
        }\n
        if (setNewBaseLayer == null) {\n
            setNewBaseLayer = true;\n
        }\n
\n
        if (layer.isFixed) {\n
            this.viewPortDiv.removeChild(layer.div);\n
        } else {\n
            this.layerContainerDiv.removeChild(layer.div);\n
        }\n
        OpenLayers.Util.removeItem(this.layers, layer);\n
        layer.removeMap(this);\n
        layer.map = null;\n
\n
        // if we removed the base layer, need to set a new one\n
        if(this.baseLayer == layer) {\n
            this.baseLayer = null;\n
            if(setNewBaseLayer) {\n
                for(var i=0, len=this.layers.length; i<len; i++) {\n
                    var iLayer = this.layers[i];\n
                    if (iLayer.isBaseLayer || this.allOverlays) {\n
                        this.setBaseLayer(iLayer);\n
                        break;\n
                    }\n
                }\n
            }\n
        }\n
\n
        this.resetLayersZIndex();\n
\n
        this.events.triggerEvent("removelayer", {layer: layer});\n
        layer.events.triggerEvent("removed", {map: this, layer: layer});\n
    },\n
\n
    /**\n
     * APIMethod: getNumLayers\n
     * \n
     * Returns:\n
     * {Int} The number of layers attached to the map.\n
     */\n
    getNumLayers: function () {\n
        return this.layers.length;\n
    },\n
\n
    /** \n
     * APIMethod: getLayerIndex\n
     *\n
     * Parameters:\n
     * layer - {<OpenLayers.Layer>}\n
     *\n
     * Returns:\n
     * {Integer} The current (zero-based) index of the given layer in the map\'s\n
     *           layer stack. Returns -1 if the layer isn\'t on the map.\n
     */\n
    getLayerIndex: function (layer) {\n
        return OpenLayers.Util.indexOf(this.layers, layer);\n
    },\n
    \n
    /** \n
     * APIMethod: setLayerIndex\n
     * Move the given layer to the specified (zero-based) index in the layer\n
     *     list, changing its z-index in the map display. Use\n
     *     map.getLayerIndex() to find out the current index of a layer. Note\n
     *     that this cannot (or at least should not) be effectively used to\n
     *     raise base layers above overlays.\n
     *\n
     * Parameters:\n
     * layer - {<OpenLayers.Layer>} \n
     * idx - {int} \n
     */\n
    setLayerIndex: function (layer, idx) {\n
        var base = this.getLayerIndex(layer);\n
        if (idx < 0) {\n
            idx = 0;\n
        } else if (idx > this.layers.length) {\n
            idx = this.layers.length;\n
        }\n
        if (base != idx) {\n
            this.layers.splice(base, 1);\n
            this.layers.splice(idx, 0, layer);\n
            for (var i=0, len=this.layers.length; i<len; i++) {\n
                this.setLayerZIndex(this.layers[i], i);\n
            }\n
            this.events.triggerEvent("changelayer", {\n
                layer: layer, property: "order"\n
            });\n
            if(this.allOverlays) {\n
                if(idx === 0) {\n
                    this.setBaseLayer(layer);\n
                } else if(this.baseLayer !== this.layers[0]) {\n
                    this.setBaseLayer(this.layers[0]);\n
                }\n
            }\n
        }\n
    },\n
\n
    /** \n
     * APIMethod: raiseLayer\n
     * Change the index of the given layer by delta. If delta is positive, \n
     *     the layer is moved up the map\'s layer stack; if delta is negative,\n
     *     the layer is moved down.  Again, note that this cannot (or at least\n
     *     should not) be effectively used to raise base layers above overlays.\n
     *\n
     * Paremeters:\n
     * layer - {<OpenLayers.Layer>} \n
     * delta - {int} \n
     */\n
    raiseLayer: function (layer, delta) {\n
        var idx = this.getLayerIndex(layer) + delta;\n
        this.setLayerIndex(layer, idx);\n
    },\n
    \n
    /** \n
     * APIMethod: setBaseLayer\n
     * Allows user to specify one of the currently-loaded layers as the Map\'s\n
     *     new base layer.\n
     * \n
     * Parameters:\n
     * newBaseLayer - {<OpenLayers.Layer>}\n
     */\n
    setBaseLayer: function(newBaseLayer) {\n
        \n
        if (newBaseLayer != this.baseLayer) {\n
          \n
            // ensure newBaseLayer is already loaded\n
            if (OpenLayers.Util.indexOf(this.layers, newBaseLayer) != -1) {\n
\n
                // preserve center and scale when changing base layers\n
                var center = this.getCachedCenter();\n
                var newResolution = OpenLayers.Util.getResolutionFromScale(\n
                    this.getScale(), newBaseLayer.units\n
                );\n
\n
                // make the old base layer invisible \n
                if (this.baseLayer != null && !this.allOverlays) {\n
                    this.baseLayer.setVisibility(false);\n
                }\n
\n
                // set new baselayer\n
                this.baseLayer = newBaseLayer;\n
                \n
                if(!this.allOverlays || this.baseLayer.visibility) {\n
                    this.baseLayer.setVisibility(true);\n
                    // Layer may previously have been visible but not in range.\n
                    // In this case we need to redraw it to make it visible.\n
                    if (this.baseLayer.inRange === false) {\n
                        this.baseLayer.redraw();\n
                    }\n
                }\n
\n
                // recenter the map\n
                if (center != null) {\n
                    // new zoom level derived from old scale\n
                    var newZoom = this.getZoomForResolution(\n
                        newResolution || this.resolution, true\n
                    );\n
                    // zoom and force zoom change\n
                    this.setCenter(center, newZoom, false, true);\n
                }\n
\n
                this.events.triggerEvent("changebaselayer", {\n
                    layer: this.baseLayer\n
                });\n
            }        \n
        }\n
    },\n
\n
\n
  /********************************************************/\n
  /*                                                      */\n
  /*                 Control Functions                    */\n
  /*                                                      */\n
  /*     The following functions deal with adding and     */\n
  /*        removing Controls to and from the Map         */\n
  /*                                                      */\n
  /********************************************************/         \n
\n
    /**\n
     * APIMethod: addControl\n
     * Add the passed over control to the map. Optionally \n
     *     position the control at the given pixel.\n
     * \n
     * Parameters:\n
     * control - {<OpenLayers.Control>}\n
     * px - {<OpenLayers.Pixel>}\n
     */    \n
    addControl: function (control, px) {\n
        this.controls.push(control);\n
        this.addControlToMap(control, px);\n
    },\n
    \n
    /**\n
     * APIMethod: addControls\n
     * Add all of the passed over controls to the map. \n
     *     You can pass over an optional second array\n
     *     with pixel-objects to position the controls.\n
     *     The indices of the two arrays should match and\n
     *     you can add null as pixel for those controls \n
     *     you want to be autopositioned.   \n
     *     \n
     * Parameters:\n
     * controls - {Array(<OpenLayers.Control>)}\n
     * pixels - {Array(<OpenLayers.Pixel>)}\n
     */    \n
    addControls: function (controls, pixels) {\n
        var pxs = (arguments.length === 1) ? [] : pixels;\n
        for (var i=0, len=controls.length; i<len; i++) {\n
            var ctrl = controls[i];\n
            var px = (pxs[i]) ? pxs[i] : null;\n
            this.addControl( ctrl, px );\n
        }\n
    },\n
\n
    /**\n
     * Method: addControlToMap\n
     * \n
     * Parameters:\n
     * \n
     * control - {<OpenLayers.Control>}\n
     * px - {<OpenLayers.Pixel>}\n
     */    \n
    addControlToMap: function (control, px) {\n
        // If a control doesn\'t have a div at this point, it belongs in the\n
        // viewport.\n
        control.outsideViewport = (control.div != null);\n
        \n
        // If the map has a displayProjection, and the control doesn\'t, set \n
        // the display projection.\n
        if (this.displayProjection && !control.displayProjection) {\n
            control.displayProjection = this.displayProjection;\n
        }    \n
        \n
        control.setMap(this);\n
        var div = control.draw(px);\n
        if (div) {\n
            if(!control.outsideViewport) {\n
                div.style.zIndex = this.Z_INDEX_BASE[\'Control\'] +\n
                                    this.controls.length;\n
                this.viewPortDiv.appendChild( div );\n
            }\n
        }\n
        if(control.autoActivate) {\n
            control.activate();\n
        }\n
    },\n
    \n
    /**\n
     * APIMethod: getControl\n
     * \n
     * Parameters:\n
     * id - {String} ID of the control to return.\n
     * \n
     * Returns:\n
     * {<OpenLayers.Control>} The control from the map\'s list of controls \n
     *                        which has a matching \'id\'. If none found, \n
     *                        returns null.\n
     */    \n
    getControl: function (id) {\n
        var returnControl = null;\n
        for(var i=0, len=this.controls.length; i<len; i++) {\n
            var control = this.controls[i];\n
            if (control.id == id) {\n
                returnControl = control;\n
                break;\n
            }\n
        }\n
        return returnControl;\n
    },\n
    \n
    /** \n
     * APIMethod: removeControl\n
     * Remove a control from the map. Removes the control both from the map \n
     *     object\'s internal array of controls, as well as from the map\'s \n
     *     viewPort (assuming the control was not added outsideViewport)\n
     * \n
     * Parameters:\n
     * control - {<OpenLayers.Control>} The control to remove.\n
     */    \n
    removeControl: function (control) {\n
        //make sure control is non-null and actually part of our map\n
        if ( (control) && (control == this.getControl(control.id)) ) {\n
            if (control.div && (control.div.parentNode == this.viewPortDiv)) {\n
                this.viewPortDiv.removeChild(control.div);\n
            }\n
            OpenLayers.Util.removeItem(this.controls, control);\n
        }\n
    },\n
\n
  /********************************************************/\n
  /*                                                      */\n
  /*                  Popup Functions                     */\n
  /*                                                      */\n
  /*     The following functions deal with adding and     */\n
  /*        removing Popups to and from the Map           */\n
  /*                                                      */\n
  /********************************************************/         \n
\n
    /** \n
     * APIMethod: addPopup\n
     * \n
     * Parameters:\n
     * popup - {<OpenLayers.Popup>}\n
     * exclusive - {Boolean} If true, closes all other popups first\n
     */\n
    addPopup: function(popup, exclusive) {\n
\n
        if (exclusive) {\n
            //remove all other popups from screen\n
            for (var i = this.popups.length - 1; i >= 0; --i) {\n
                this.removePopup(this.popups[i]);\n
            }\n
        }\n
\n
        popup.map = this;\n
        this.popups.push(popup);\n
        var popupDiv = popup.draw();\n
        if (popupDiv) {\n
            popupDiv.style.zIndex = this.Z_INDEX_BASE[\'Popup\'] +\n
                                    this.popups.length;\n
            this.layerContainerDiv.appendChild(popupDiv);\n
        }\n
    },\n
    \n
    /** \n
    * APIMethod: removePopup\n
    * \n
    * Parameters:\n
    * popup - {<OpenLayers.Popup>}\n
    */\n
    removePopup: function(popup) {\n
        OpenLayers.Util.removeItem(this.popups, popup);\n
        if (popup.div) {\n
            try { this.layerContainerDiv.removeChild(popup.div); }\n
            catch (e) { } // Popups sometimes apparently get disconnected\n
                      // from the layerContainerDiv, and cause complaints.\n
        }\n
        popup.map = null;\n
    },\n
\n
  /********************************************************/\n
  /*                                                      */\n
  /*              Container Div Functions                 */\n
  /*                                                      */\n
  /*   The following functions deal with the access to    */\n
  /*    and maintenance of the size of the container div  */\n
  /*                                                      */\n
  /********************************************************/     \n
\n
    /**\n
     * APIMethod: getSize\n
     * \n
     * Returns:\n
     * {<OpenLayers.Size>} An <OpenLayers.Size> object that represents the \n
     *                     size, in pixels, of the div into which OpenLayers \n
     *                     has been loaded. \n
     *                     Note - A clone() of this locally cached variable is\n
     *                     returned, so as not to allow users to modify it.\n
     */\n
    getSize: function () {\n
        var size = null;\n
        if (this.size != null) {\n
            size = this.size.clone();\n
        }\n
        return size;\n
    },\n
\n
    /**\n
     * APIMethod: updateSize\n
     * This function should be called by any external code which dynamically\n
     *     changes the size of the map div (because mozilla wont let us catch \n
     *     the "onresize" for an element)\n
     */\n
    updateSize: function() {\n
        // the div might have moved on the page, also\n
        var newSize = this.getCurrentSize();\n
        if (newSize && !isNaN(newSize.h) && !isNaN(newSize.w)) {\n
            this.events.clearMouseCache();\n
            var oldSize = this.getSize();\n
            if (oldSize == null) {\n
                this.size = oldSize = newSize;\n
            }\n
            if (!newSize.equals(oldSize)) {\n
                \n
                // store the new size\n
                this.size = newSize;\n
    \n
                //notify layers of mapresize\n
                for(var i=0, len=this.layers.length; i<len; i++) {\n
                    this.layers[i].onMapResize();                \n
                }\n
    \n
                var center = this.getCachedCenter();\n
    \n
                if (this.baseLayer != null && center != null) {\n
                    var zoom = this.getZoom();\n
                    this.zoom = null;\n
                    this.setCenter(center, zoom);\n
                }\n
    \n
            }\n
        }\n
    },\n
    \n
    /**\n
     * Method: getCurrentSize\n
     * \n
     * Returns:\n
     * {<OpenLayers.Size>} A new <OpenLayers.Size> object with the dimensions \n
     *                     of the map div\n
     */\n
    getCurrentSize: function() {\n
\n
        var size = new OpenLayers.Size(this.div.clientWidth, \n
                                       this.div.clientHeight);\n
\n
        if (size.w == 0 && size.h == 0 || isNaN(size.w) && isNaN(size.h)) {\n
            size.w = this.div.offsetWidth;\n
            size.h = this.div.offsetHeight;\n
        }\n
        if (size.w == 0 && size.h == 0 || isNaN(size.w) && isNaN(size.h)) {\n
            size.w = parseInt(this.div.style.width);\n
            size.h = parseInt(this.div.style.height);\n
        }\n
        return size;\n
    },\n
\n
    /** \n
     * Method: calculateBounds\n
     * \n
     * Parameters:\n
     * center - {<OpenLayers.LonLat>} Default is this.getCenter()\n
     * resolution - {float} Default is this.getResolution() \n
     * \n
     * Returns:\n
     * {<OpenLayers.Bounds>} A bounds based on resolution, center, and \n
     *                       current mapsize.\n
     */\n
    calculateBounds: function(center, resolution) {\n
\n
        var extent = null;\n
        \n
        if (center == null) {\n
            center = this.getCachedCenter();\n
        }                \n
        if (resolution == null) {\n
            resolution = this.getResolution();\n
        }\n
    \n
        if ((center != null) && (resolution != null)) {\n
            var halfWDeg = (this.size.w * resolution) / 2;\n
            var halfHDeg = (this.size.h * resolution) / 2;\n
        \n
            extent = new OpenLayers.Bounds(center.lon - halfWDeg,\n
                                           center.lat - halfHDeg,\n
                                           center.lon + halfWDeg,\n
                                           center.lat + halfHDeg);\n
        }\n
\n
        return extent;\n
    },\n
\n
\n
  /********************************************************/\n
  /*                                                      */\n
  /*            Zoom, Center, Pan Functions               */\n
  /*                                                      */\n
  /*    The following functions handle the validation,    */\n
  /*   getting and setting of the Zoom Level and Center   */\n
  /*       as well as the panning of the Map              */\n
  /*                                                      */\n
  /********************************************************/\n
    /**\n
     * APIMethod: getCenter\n
     * \n
     * Returns:\n
     * {<OpenLayers.LonLat>}\n
     */\n
    getCenter: function () {\n
        var center = null;\n
        var cachedCenter = this.getCachedCenter();\n
        if (cachedCenter) {\n
            center = cachedCenter.clone();\n
        }\n
        return center;\n
    },\n
\n
    /**\n
     * Method: getCachedCenter\n
     *\n
     * Returns:\n
     * {<OpenLayers.LonLat>}\n
     */\n
    getCachedCenter: function() {\n
        if (!this.center && this.size) {\n
            this.center = this.getLonLatFromViewPortPx({\n
                x: this.size.w / 2,\n
                y: this.size.h / 2\n
            });\n
        }\n
        return this.center;\n
    },\n
\n
    /**\n
     * APIMethod: getZoom\n
     * \n
     * Returns:\n
     * {Integer}\n
     */\n
    getZoom: function () {\n
        return this.zoom;\n
    },\n
    \n
    /** \n
     * APIMethod: pan\n
     * Allows user to pan by a value of screen pixels\n
     * \n
     * Parameters:\n
     * dx - {Integer}\n
     * dy - {Integer}\n
     * options - {Object} Options to configure panning:\n
     *  - *animate* {Boolean} Use panTo instead of setCenter. Default is true.\n
     *  - *dragging* {Boolean} Call setCenter with dragging true.  Default is\n
     *    false.\n
     */\n
    pan: function(dx, dy, options) {\n
        options = OpenLayers.Util.applyDefaults(options, {\n
            animate: true,\n
            dragging: false\n
        });\n
        if (options.dragging) {\n
            if (dx != 0 || dy != 0) {\n
                this.moveByPx(dx, dy);\n
            }\n
        } else {\n
            // getCenter\n
            var centerPx = this.getViewPortPxFromLonLat(this.getCachedCenter());\n
\n
            // adjust\n
            var newCenterPx = centerPx.add(dx, dy);\n
\n
            if (this.dragging || !newCenterPx.equals(centerPx)) {\n
                var newCenterLonLat = this.getLonLatFromViewPortPx(newCenterPx);\n
                if (options.animate) {\n
                    this.panTo(newCenterLonLat);\n
                } else {\n
                    this.moveTo(newCenterLonLat);\n
                    if(this.dragging) {\n
                        this.dragging = false;\n
                        this.events.triggerEvent("moveend");\n
                    }\n
                }    \n
            }\n
        }        \n
\n
   },\n
   \n
   /** \n
     * APIMethod: panTo\n
     * Allows user to pan to a new lonlat\n
     * If the new lonlat is in the current extent the map will slide smoothly\n
     * \n
     * Parameters:\n
     * lonlat - {<OpenLayers.LonLat>}\n
     */\n
    panTo: function(lonlat) {\n
        if (this.panMethod && this.getExtent().scale(this.panRatio).containsLonLat(lonlat)) {\n
            if (!this.panTween) {\n
                this.panTween = new OpenLayers.Tween(this.panMethod);\n
            }\n
            var center = this.getCachedCenter();\n
\n
            // center will not change, don\'t do nothing\n
            if (lonlat.equals(center)) {\n
                return;\n
            }\n
\n
            var from = this.getPixelFromLonLat(center);\n
            var to = this.getPixelFromLonLat(lonlat);\n
            var vector = { x: to.x - from.x, y: to.y - from.y };\n
            var last = { x: 0, y: 0 };\n
\n
            this.panTween.start( { x: 0, y: 0 }, vector, this.panDuration, {\n
                callbacks: {\n
                    eachStep: OpenLayers.Function.bind(function(px) {\n
                        var x = px.x - last.x,\n
                            y = px.y - last.y;\n
                        this.moveByPx(x, y);\n
                        last.x = Math.round(px.x);\n
                        last.y = Math.round(px.y);\n
                    }, this),\n
                    done: OpenLayers.Function.bind(function(px) {\n
                        this.moveTo(lonlat);\n
                        this.dragging = false;\n
                        this.events.triggerEvent("moveend");\n
                    }, this)\n
                }\n
            });\n
        } else {\n
            this.setCenter(lonlat);\n
        }\n
    },\n
\n
    /**\n
     * APIMethod: setCenter\n
     * Set the map center (and optionally, the zoom level).\n
     * \n
     * Parameters:\n
     * lonlat - {<OpenLayers.LonLat>|Array} The new center location.\n
     *     If provided as array, the first value is the x coordinate,\n
     *     and the 2nd value is the y coordinate.\n
     * zoom - {Integer} Optional zoom level.\n
     * dragging - {Boolean} Specifies whether or not to trigger \n
     *                      movestart/end events\n
     * forceZoomChange - {Boolean} Specifies whether or not to trigger zoom \n
     *                             change events (needed on baseLayer change)\n
     *\n
     * TBD: reconsider forceZoomChange in 3.0\n
     */\n
    setCenter: function(lonlat, zoom, dragging, forceZoomChange) {\n
        this.panTween && this.panTween.stop();             \n
        this.moveTo(lonlat, zoom, {\n
            \'dragging\': dragging,\n
            \'forceZoomChange\': forceZoomChange\n
        });\n
    },\n
    \n
    /** \n
     * Method: moveByPx\n
     * Drag the map by pixels.\n
     *\n
     * Parameters:\n
     * dx - {Number}\n
     * dy - {Number}\n
     */\n
    moveByPx: function(dx, dy) {\n
        var hw = this.size.w / 2;\n
        var hh = this.size.h / 2;\n
        var x = hw + dx;\n
        var y = hh + dy;\n
        var wrapDateLine = this.baseLayer.wrapDateLine;\n
        var xRestriction = 0;\n
        var yRestriction = 0;\n
        if (this.restrictedExtent) {\n
            xRestriction = hw;\n
            yRestriction = hh;\n
            // wrapping the date line makes no sense for restricted extents\n
            wrapDateLine = false;\n
        }\n
        dx = wrapDateLine ||\n
                    x <= this.maxPx.x - xRestriction &&\n
                    x >= this.minPx.x + xRestriction ? Math.round(dx) : 0;\n
        dy = y <= this.maxPx.y - yRestriction &&\n
                    y >= this.minPx.y + yRestriction ? Math.round(dy) : 0;\n
        if (dx || dy) {\n
            if (!this.dragging) {\n
                this.dragging = true;\n
                this.events.triggerEvent("movestart");\n
            }\n
            this.center = null;\n
            if (dx) {\n
                this.layerContainerDiv.style.left =\n
                    parseInt(this.layerContainerDiv.style.left) - dx + "px";\n
                this.minPx.x -= dx;\n
                this.maxPx.x -= dx;\n
            }\n
            if (dy) {\n
                this.layerContainerDiv.style.top =\n
                    parseInt(this.layerContainerDiv.style.top) - dy + "px";\n
                this.minPx.y -= dy;\n
                this.maxPx.y -= dy;\n
            }\n
            var layer, i, len;\n
            for (i=0, len=this.layers.length; i<len; ++i) {\n
                layer = this.layers[i];\n
                if (layer.visibility &&\n
                    (layer === this.baseLayer || layer.inRange)) {\n
                    layer.moveByPx(dx, dy);\n
                    layer.events.triggerEvent("move");\n
                }\n
            }\n
            this.events.triggerEvent("move");\n
        }\n
    },\n
    \n
    /**\n
     * Method: adjustZoom\n
     *\n
     * Parameters:\n
     * zoom - {Number} The zoom level to adjust\n
     *\n
     * Returns:\n
     * {Integer} Adjusted zoom level that shows a map not wider than its\n
     * <baseLayer>\'s maxExtent.\n
     */\n
    adjustZoom: function(zoom) {\n
        var resolution, resolutions = this.baseLayer.resolutions,\n
            maxResolution = this.getMaxExtent().getWidth() / this.size.w;\n
        if (this.getResolutionForZoom(zoom) > maxResolution) {\n
            for (var i=zoom|0, ii=resolutions.length; i<ii; ++i) {\n
                if (resolutions[i] <= maxResolution) {\n
                    zoom = i;\n
                    break;\n
                }\n
            }\n
        }\n
        return zoom;\n
    },\n
\n
    /**\n
     * Method: moveTo\n
     *\n
     * Parameters:\n
     * lonlat - {<OpenLayers.LonLat>}\n
     * zoom - {Integer}\n
     * options - {Object}\n
     */\n
    moveTo: function(lonlat, zoom, options) {\n
        if (lonlat != null && !(lonlat instanceof OpenLayers.LonLat)) {\n
            lonlat = new OpenLayers.LonLat(lonlat);\n
        }\n
        if (!options) { \n
            options = {};\n
        }\n
        if (zoom != null) {\n
            zoom = parseFloat(zoom);\n
            if (!this.fractionalZoom) {\n
                zoom = Math.round(zoom);\n
            }\n
        }\n
        if (this.baseLayer.wrapDateLine) {\n
            var requestedZoom = zoom;\n
            zoom = this.adjustZoom(zoom);\n
            if (zoom !== requestedZoom) {\n
                // zoom was adjusted, so keep old lonlat to avoid panning\n
                lonlat = this.getCenter();\n
            }\n
        }\n
        // dragging is false by default\n
        var dragging = options.dragging || this.dragging;\n
        // forceZoomChange is false by default\n
        var forceZoomChange = options.forceZoomChange;\n
\n
        if (!this.getCachedCenter() && !this.isValidLonLat(lonlat)) {\n
            lonlat = this.maxExtent.getCenterLonLat();\n
            this.center = lonlat.clone();\n
        }\n
\n
        if(this.restrictedExtent != null) {\n
            // In 3.0, decide if we want to change interpretation of maxExtent.\n
            if(lonlat == null) { \n
                lonlat = this.center; \n
            }\n
            if(zoom == null) { \n
                zoom = this.getZoom(); \n
            }\n
            var resolution = this.getResolutionForZoom(zoom);\n
            var extent = this.calculateBounds(lonlat, resolution); \n
            if(!this.restrictedExtent.containsBounds(extent)) {\n
                var maxCenter = this.restrictedExtent.getCenterLonLat(); \n
                if(extent.getWidth() > this.restrictedExtent.getWidth()) { \n
                    lonlat = new OpenLayers.LonLat(maxCenter.lon, lonlat.lat); \n
                } else if(extent.left < this.restrictedExtent.left) {\n
                    lonlat = lonlat.add(this.restrictedExtent.left -\n
                                        extent.left, 0); \n
                } else if(extent.right > this.restrictedExtent.right) { \n
                    lonlat = lonlat.add(this.restrictedExtent.right -\n
                                        extent.right, 0); \n
                } \n
                if(extent.getHeight() > this.restrictedExtent.getHeight()) { \n
                    lonlat = new OpenLayers.LonLat(lonlat.lon, maxCenter.lat); \n
                } else if(extent.bottom < this.restrictedExtent.bottom) { \n
                    lonlat = lonlat.add(0, this.restrictedExtent.bottom -\n
                                        extent.bottom); \n
                } \n
                else if(extent.top > this.restrictedExtent.top) { \n
                    lonlat = lonlat.add(0, this.restrictedExtent.top -\n
                                        extent.top); \n
                } \n
            }\n
        }\n
        \n
        var zoomChanged = forceZoomChange || (\n
                            (this.isValidZoomLevel(zoom)) && \n
                            (zoom != this.getZoom()) );\n
\n
        var centerChanged = (this.isValidLonLat(lonlat)) && \n
                            (!lonlat.equals(this.center));\n
\n
        // if neither center nor zoom will change, no need to do anything\n
        if (zoomChanged || centerChanged || dragging) {\n
            dragging || this.events.triggerEvent("movestart");\n
\n
            if (centerChanged) {\n
                if (!zoomChanged && this.center) { \n
                    // if zoom hasnt changed, just slide layerContainer\n
                    //  (must be done before setting this.center to new value)\n
                    this.centerLayerContainer(lonlat);\n
                }\n
                this.center = lonlat.clone();\n
            }\n
\n
            var res = zoomChanged ?\n
                this.getResolutionForZoom(zoom) : this.getResolution();\n
            // (re)set the layerContainerDiv\'s location\n
            if (zoomChanged || this.layerContainerOrigin == null) {\n
                this.layerContainerOrigin = this.getCachedCenter();\n
                this.layerContainerDiv.style.left = "0px";\n
                this.layerContainerDiv.style.top  = "0px";\n
                var maxExtent = this.getMaxExtent({restricted: true});\n
                var maxExtentCenter = maxExtent.getCenterLonLat();\n
                var lonDelta = this.center.lon - maxExtentCenter.lon;\n
                var latDelta = maxExtentCenter.lat - this.center.lat;\n
                var extentWidth = Math.round(maxExtent.getWidth() / res);\n
                var extentHeight = Math.round(maxExtent.getHeight() / res);\n
                this.minPx = {\n
                    x: (this.size.w - extentWidth) / 2 - lonDelta / res,\n
                    y: (this.size.h - extentHeight) / 2 - latDelta / res\n
                };\n
                this.maxPx = {\n
                    x: this.minPx.x + Math.round(maxExtent.getWidth() / res),\n
                    y: this.minPx.y + Math.round(maxExtent.getHeight() / res)\n
                };\n
            }\n
\n
            if (zoomChanged) {\n
                this.zoom = zoom;\n
                this.resolution = res;\n
            }    \n
            \n
            var bounds = this.getExtent();\n
            \n
            //send the move call to the baselayer and all the overlays    \n
\n
            if(this.baseLayer.visibility) {\n
                this.baseLayer.moveTo(bounds, zoomChanged, options.dragging);\n
                options.dragging || this.baseLayer.events.triggerEvent(\n
                    "moveend", {zoomChanged: zoomChanged}\n
                );\n
            }\n
            \n
            bounds = this.baseLayer.getExtent();\n
            \n
            for (var i=this.layers.length-1; i>=0; --i) {\n
                var layer = this.layers[i];\n
                if (layer !== this.baseLayer && !layer.isBaseLayer) {\n
                    var inRange = layer.calculateInRange();\n
                    if (layer.inRange != inRange) {\n
                        // the inRange property has changed. If the layer is\n
                        // no longer in range, we turn it off right away. If\n
                        // the layer is no longer out of range, the moveTo\n
                        // call below will turn on the layer.\n
                        layer.inRange = inRange;\n
                        if (!inRange) {\n
                            layer.display(false);\n
                        }\n
                        this.events.triggerEvent("changelayer", {\n
                            layer: layer, property: "visibility"\n
                        });\n
                    }\n
                    if (inRange && layer.visibility) {\n
                        layer.moveTo(bounds, zoomChanged, options.dragging);\n
                        options.dragging || layer.events.triggerEvent(\n
                            "moveend", {zoomChanged: zoomChanged}\n
                        );\n
                    }\n
                }                \n
            }\n
            \n
            this.events.triggerEvent("move");\n
            dragging || this.events.triggerEvent("moveend");\n
\n
            if (zoomChanged) {\n
                //redraw popups\n
                for (var i=0, len=this.popups.length; i<len; i++) {\n
                    this.popups[i].updatePosition();\n
                }\n
                this.events.triggerEvent("zoomend");\n
            }\n
        }\n
    },\n
\n
    /** \n
     * Method: centerLayerContainer\n
     * This function takes care to recenter the layerContainerDiv.\n
     * \n
     * Parameters:\n
     * lonlat - {<OpenLayers.LonLat>}\n
     */\n
    centerLayerContainer: function (lonlat) {\n
        var originPx = this.getViewPortPxFromLonLat(this.layerContainerOrigin);\n
        var newPx = this.getViewPortPxFromLonLat(lonlat);\n
\n
        if ((originPx != null) && (newPx != null)) {\n
            var oldLeft = parseInt(this.layerContainerDiv.style.left);\n
            var oldTop = parseInt(this.layerContainerDiv.style.top);\n
            var newLeft = Math.round(originPx.x - newPx.x);\n
            var newTop = Math.round(originPx.y - newPx.y);\n
            this.layerContainerDiv.style.left = newLeft + "px";\n
            this.layerContainerDiv.style.top  = newTop + "px";\n
            var dx = oldLeft - newLeft;\n
            var dy = oldTop - newTop;\n
            this.minPx.x -= dx;\n
            this.maxPx.x -= dx;\n
            this.minPx.y -= dy;\n
            this.maxPx.y -= dy;\n
        }        \n
    },\n
\n
    /**\n
     * Method: isValidZoomLevel\n
     * \n
     * Parameters:\n
     * zoomLevel - {Integer}\n
     * \n
     * Returns:\n
     * {Boolean} Whether or not the zoom level passed in is non-null and \n
     *           within the min/max range of zoom levels.\n
     */\n
    isValidZoomLevel: function(zoomLevel) {\n
        return ( (zoomLevel != null) &&\n
                 (zoomLevel >= 0) && \n
                 (zoomLevel < this.getNumZoomLevels()) );\n
    },\n
    \n
    /**\n
     * Method: isValidLonLat\n
     * \n
     * Parameters:\n
     * lonlat - {<OpenLayers.LonLat>}\n
     * \n
     * Returns:\n
     * {Boolean} Whether or not the lonlat passed in is non-null and within\n
     *           the maxExtent bounds\n
     */\n
    isValidLonLat: function(lonlat) {\n
        var valid = false;\n
        if (lonlat != null) {\n
            var maxExtent = this.getMaxExtent();\n
            var worldBounds = this.baseLayer.wrapDateLine && maxExtent;\n
            valid = maxExtent.containsLonLat(lonlat, {worldBounds: worldBounds});\n
        }\n
        return valid;\n
    },\n
\n
  /********************************************************/\n
  /*                                                      */\n
  /*                 Layer Options                        */\n
  /*                                                      */\n
  /*    Accessor functions to Layer Options parameters    */\n
  /*                                                      */\n
  /********************************************************/\n
    \n
    /**\n
     * APIMethod: getProjection\n
     * This method returns a string representing the projection. In \n
     *     the case of projection support, this will be the srsCode which\n
     *     is loaded -- otherwise it will simply be the string value that\n
     *     was passed to the projection at startup.\n
     *\n
     * FIXME: In 3.0, we will remove getProjectionObject, and instead\n
     *     return a Projection object from this function. \n
     * \n
     * Returns:\n
     * {String} The Projection string from the base layer or null. \n
     */\n
    getProjection: function() {\n
        var projection = this.getProjectionObject();\n
        return projection ? projection.getCode() : null;\n
    },\n
    \n
    /**\n
     * APIMethod: getProjectionObject\n
     * Returns the projection obect from the baselayer.\n
     *\n
     * Returns:\n
     * {<OpenLayers.Projection>} The Projection of the base layer.\n
     */\n
    getProjectionObject: function() {\n
        var projection = null;\n
        if (this.baseLayer != null) {\n
            projection = this.baseLayer.projection;\n
        }\n
        return projection;\n
    },\n
    \n
    /**\n
     * APIMethod: getMaxResolution\n
     * \n
     * Returns:\n
     * {String} The Map\'s Maximum Resolution\n
     */\n
    getMaxResolution: function() {\n
        var maxResolution = null;\n
        if (this.baseLayer != null) {\n
            maxResolution = this.baseLayer.maxResolution;\n
        }\n
        return maxResolution;\n
    },\n
        \n
    /**\n
     * APIMethod: getMaxExtent\n
     *\n
     * Parameters:\n
     * options - {Object} \n
     * \n
     * Allowed Options:\n
     * restricted - {Boolean} If true, returns restricted extent (if it is \n
     *     available.)\n
     *\n
     * Returns:\n
     * {<OpenLayers.Bounds>} The maxExtent property as set on the current \n
     *     baselayer, unless the \'restricted\' option is set, in which case\n
     *     the \'restrictedExtent\' option from the map is returned (if it\n
     *     is set).\n
     */\n
    getMaxExtent: function (options) {\n
        var maxExtent = null;\n
        if(options && options.restricted && this.restrictedExtent){\n
            maxExtent = this.restrictedExtent;\n
        } else if (this.baseLayer != null) {\n
            maxExtent = this.baseLayer.maxExtent;\n
        }        \n
        return maxExtent;\n
    },\n
    \n
    /**\n
     * APIMethod: getNumZoomLevels\n
     * \n
     * Returns:\n
     * {Integer} The total number of zoom levels that can be displayed by the \n
     *           current baseLayer.\n
     */\n
    getNumZoomLevels: function() {\n
        var numZoomLevels = null;\n
        if (this.baseLayer != null) {\n
            numZoomLevels = this.baseLayer.numZoomLevels;\n
        }\n
        return numZoomLevels;\n
    },\n
\n
  /********************************************************/\n
  /*                                                      */\n
  /*                 Baselayer Functions                  */\n
  /*                                                      */\n
  /*    The following functions, all publicly exposed     */\n
  /*       in the API?, are all merely wrappers to the    */\n
  /*       the same calls on whatever layer is set as     */\n
  /*                the current base layer                */\n
  /*                                                      */\n
  /********************************************************/\n
\n
    /**\n
     * APIMethod: getExtent\n
     * \n
     * Returns:\n
     * {<OpenLayers.Bounds>} A Bounds object which represents the lon/lat \n
     *                       bounds of the current viewPort. \n
     *                       If no baselayer is set, returns null.\n
     */\n
    getExtent: function () {\n
        var extent = null;\n
        if (this.baseLayer != null) {\n
            extent = this.baseLayer.getExtent();\n
        }\n
        return extent;\n
    },\n
\n
    /**\n
     * APIMethod: getResolution\n
     * \n
     * Returns:\n
     * {Float} The current resolution of the map. \n
     *         If no baselayer is set, returns null.\n
     */\n
    getResolution: function () {\n
        var resolution = null;\n
        if (this.baseLayer != null) {\n
            resolution = this.baseLayer.getResolution();\n
        } else if(this.allOverlays === true && this.layers.length > 0) {\n
            // while adding the 1st layer to the map in allOverlays mode,\n
            // this.baseLayer is not set yet when we need the resolution\n
            // for calculateInRange.\n
            resolution = this.layers[0].getResolution();\n
        }\n
        return resolution;\n
    },\n
\n
    /**\n
     * APIMethod: getUnits\n
     * \n
     * Returns:\n
     * {Float} The current units of the map. \n
     *         If no baselayer is set, returns null.\n
     */\n
    getUnits: function () {\n
        var units = null;\n
        if (this.baseLayer != null) {\n
            units = this.baseLayer.units;\n
        }\n
        return units;\n
    },\n
\n
     /**\n
      * APIMethod: getScale\n
      * \n
      * Returns:\n
      * {Float} The current scale denominator of the map. \n
      *         If no baselayer is set, returns null.\n
      */\n
    getScale: function () {\n
        var scale = null;\n
        if (this.baseLayer != null) {\n
            var res = this.getResolution();\n
            var units = this.baseLayer.units;\n
            scale = OpenLayers.Util.getScaleFromResolution(res, units);\n
        }\n
        return scale;\n
    },\n
\n
\n
    /**\n
     * APIMethod: getZoomForExtent\n
     * \n
     * Parameters: \n
     * bounds - {<OpenLayers.Bounds>}\n
     * closest - {Boolean} Find the zoom level that most closely fits the \n
     *     specified bounds. Note that this may result in a zoom that does \n
     *     not exactly contain the entire extent.\n
     *     Default is false.\n
     * \n
     * Returns:\n
     * {Integer} A suitable zoom level for the specified bounds.\n
     *           If no baselayer is set, returns null.\n
     */\n
    getZoomForExtent: function (bounds, closest) {\n
        var zoom = null;\n
        if (this.baseLayer != null) {\n
            zoom = this.baseLayer.getZoomForExtent(bounds, closest);\n
        }\n
        return zoom;\n
    },\n
\n
    /**\n
     * APIMethod: getResolutionForZoom\n
     * \n
     * Parameters:\n
     * zoom - {Float}\n
     * \n
     * Returns:\n
     * {Float} A suitable resolution for the specified zoom.  If no baselayer\n
     *     is set, returns null.\n
     */\n
    getResolutionForZoom: function(zoom) {\n
        var resolution = null;\n
        if(this.baseLayer) {\n
            resolution = this.baseLayer.getResolutionForZoom(zoom);\n
        }\n
        return resolution;\n
    },\n
\n
    /**\n
     * APIMethod: getZoomForResolution\n
     * \n
     * Parameters:\n
     * resolution - {Float}\n
     * closest - {Boolean} Find the zoom level that corresponds to the absolute \n
     *     closest resolution, which may result in a zoom whose corresponding\n
     *     resolution is actually smaller than we would have desired (if this\n
     *     is being called from a getZoomForExtent() call, then this means that\n
     *     the returned zoom index might not actually contain the entire \n
     *     extent specified... but it\'ll be close).\n
     *     Default is false.\n
     * \n
     * Returns:\n
     * {Integer} A suitable zoom level for the specified resolution.\n
     *           If no baselayer is set, returns null.\n
     */\n
    getZoomForResolution: function(resolution, closest) {\n
        var zoom = null;\n
        if (this.baseLayer != null) {\n
            zoom = this.baseLayer.getZoomForResolution(resolution, closest);\n
        }\n
        return zoom;\n
    },\n
\n
  /********************************************************/\n
  /*                                                      */\n
  /*                  Zooming Functions                   */\n
  /*                                                      */\n
  /*    The following functions, all publicly exposed     */\n
  /*       in the API, are all merely wrappers to the     */\n
  /*               the setCenter() function               */\n
  /*                                                      */\n
  /********************************************************/\n
  \n
    /** \n
     * APIMethod: zoomTo\n
     * Zoom to a specific zoom level\n
     * \n
     * Parameters:\n
     * zoom - {Integer}\n
     */\n
    zoomTo: function(zoom) {\n
        if (this.isValidZoomLevel(zoom)) {\n
            this.setCenter(null, zoom);\n
        }\n
    },\n
    \n
    /**\n
     * APIMethod: zoomIn\n
     * \n
     */\n
    zoomIn: function() {\n
        this.zoomTo(this.getZoom() + 1);\n
    },\n
    \n
    /**\n
     * APIMethod: zoomOut\n
     * \n
     */\n
    zoomOut: function() {\n
        this.zoomTo(this.getZoom() - 1);\n
    },\n
\n
    /**\n
     * APIMethod: zoomToExtent\n
     * Zoom to the passed in bounds, recenter\n
     * \n
     * Parameters:\n
     * bounds - {<OpenLayers.Bounds>|Array} If provided as an array, the array\n
     *     should consist of four values (left, bottom, right, top).\n
     * closest - {Boolean} Find the zoom level that most closely fits the \n
     *     specified bounds. Note that this may result in a zoom that does \n
     *     not exactly contain the entire extent.\n
     *     Default is false.\n
     * \n
     */\n
    zoomToExtent: function(bounds, closest) {\n
        if (!(bounds instanceof OpenLayers.Bounds)) {\n
            bounds = new OpenLayers.Bounds(bounds);\n
        }\n
        var center = bounds.getCenterLonLat();\n
        if (this.baseLayer.wrapDateLine) {\n
            var maxExtent = this.getMaxExtent();\n
\n
            //fix straddling bounds (in the case of a bbox that straddles the \n
            // dateline, it\'s left and right boundaries will appear backwards. \n
            // we fix this by allowing a right value that is greater than the\n
            // max value at the dateline -- this allows us to pass a valid \n
            // bounds to calculate zoom)\n
            //\n
            bounds = bounds.clone();\n
            while (bounds.right < bounds.left) {\n
                bounds.right += maxExtent.getWidth();\n
            }\n
            //if the bounds was straddling (see above), then the center point \n
            // we got from it was wrong. So we take our new bounds and ask it\n
            // for the center.\n
            //\n
            center = bounds.getCenterLonLat().wrapDateLine(maxExtent);\n
        }\n
        this.setCenter(center, this.getZoomForExtent(bounds, closest));\n
    },\n
\n
    /** \n
     * APIMethod: zoomToMaxExtent\n
     * Zoom to the full extent and recenter.\n
     *\n
     * Parameters:\n
     * options - {Object}\n
     * \n
     * Allowed Options:\n
     * restricted - {Boolean} True to zoom to restricted extent if it is \n
     *     set. Defaults to true.\n
     */\n
    zoomToMaxExtent: function(options) {\n
        //restricted is true by default\n
        var restricted = (options) ? options.restricted : true;\n
\n
        var maxExtent = this.getMaxExtent({\n
            \'restricted\': restricted \n
        });\n
        this.zoomToExtent(maxExtent);\n
    },\n
\n
    /** \n
     * APIMethod: zoomToScale\n
     * Zoom to a specified scale \n
     * \n
     * Parameters:\n
     * scale - {float}\n
     * closest - {Boolean} Find the zoom level that most closely fits the \n
     *     specified scale. Note that this may result in a zoom that does \n
     *     not exactly contain the entire extent.\n
     *     Default is false.\n
     * \n
     */\n
    zoomToScale: function(scale, closest) {\n
        var res = OpenLayers.Util.getResolutionFromScale(scale, \n
                                                         this.baseLayer.units);\n
\n
        var halfWDeg = (this.size.w * res) / 2;\n
        var halfHDeg = (this.size.h * res) / 2;\n
        var center = this.getCachedCenter();\n
\n
        var extent = new OpenLayers.Bounds(center.lon - halfWDeg,\n
                                           center.lat - halfHDeg,\n
                                           center.lon + halfWDeg,\n
                                           center.lat + halfHDeg);\n
        this.zoomToExtent(extent, closest);\n
    },\n
    \n
  /********************************************************/\n
  /*                                                      */\n
  /*             Translation Functions                    */\n
  /*                                                      */\n
  /*      The following functions translate between       */\n
  /*           LonLat, LayerPx, and ViewPortPx            */\n
  /*                                                      */\n
  /********************************************************/\n
      \n
  //\n
  // TRANSLATION: LonLat <-> ViewPortPx\n
  //\n
\n
    /**\n
     * Method: getLonLatFromViewPortPx\n
     * \n
     * Parameters:\n
     * viewPortPx - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or\n
     *                                          an object with a \'x\'\n
     *                                          and \'y\' properties.\n
     * \n
     * Returns:\n
     * {<OpenLayers.LonLat>} An OpenLayers.LonLat which is the passed-in view \n
     *                       port <OpenLayers.Pixel>, translated into lon/lat\n
     *                       by the current base layer.\n
     */\n
    getLonLatFromViewPortPx: function (viewPortPx) {\n
        var lonlat = null; \n
        if (this.baseLayer != null) {\n
            lonlat = this.baseLayer.getLonLatFromViewPortPx(viewPortPx);\n
        }\n
        return lonlat;\n
    },\n
\n
    /**\n
     * APIMethod: getViewPortPxFromLonLat\n
     * \n
     * Parameters:\n
     * lonlat - {<OpenLayers.LonLat>}\n
     * \n
     * Returns:\n
     * {<OpenLayers.Pixel>} An OpenLayers.Pixel which is the passed-in \n
     *                      <OpenLayers.LonLat>, translated into view port \n
     *                      pixels by the current base layer.\n
     */\n
    getViewPortPxFromLonLat: function (lonlat) {\n
        var px = null; \n
        if (this.baseLayer != null) {\n
            px = this.baseLayer.getViewPortPxFromLonLat(lonlat);\n
        }\n
        return px;\n
    },\n
\n
    \n
  //\n
  // CONVENIENCE TRANSLATION FUNCTIONS FOR API\n
  //\n
\n
    /**\n
     * APIMethod: getLonLatFromPixel\n
     * \n
     * Parameters:\n
     * px - {<OpenLayers.Pixel>|Object} An OpenLayers.Pixel or an object with\n
     *                                  a \'x\' and \'y\' properties.\n
     *\n
     * Returns:\n
     * {<OpenLayers.LonLat>} An OpenLayers.LonLat corresponding to the given\n
     *                       OpenLayers.Pixel, translated into lon/lat by the \n
     *                       current base layer\n
     */\n
    getLonLatFromPixel: function (px) {\n
        return this.getLonLatFromViewPortPx(px);\n
    },\n
\n
    /**\n
     * APIMethod: getPixelFromLonLat\n
     * Returns a pixel location given a map location.  The map location is\n
     *     translated to an integer pixel location (in viewport pixel\n
     *     coordinates) by the current base layer.\n
     * \n
     * Parameters:\n
     * lonlat - {<OpenLayers.LonLat>} A map location.\n
     * \n
     * Returns: \n
     * {<OpenLayers.Pixel>} An OpenLayers.Pixel corresponding to the \n
     *     <OpenLayers.LonLat> translated into view port pixels by the current\n
     *     base layer.\n
     */\n
    getPixelFromLonLat: function (lonlat) {\n
        var px = this.getViewPortPxFromLonLat(lonlat);\n
        px.x = Math.round(px.x);\n
        px.y = Math.round(px.y);\n
        return px;\n
    },\n
    \n
    /**\n
     * Method: getGeodesicPixelSize\n
     * \n
     * Parameters:\n
     * px - {<OpenLayers.Pixel>} The pixel to get the geodesic length for. If\n
     *     not provided, the center pixel of the map viewport will be used.\n
     * \n
     * Returns:\n
     * {<OpenLayers.Size>} The geodesic size of the pixel in kilometers.\n
     */\n
    getGeodesicPixelSize: function(px) {\n
        var lonlat = px ? this.getLonLatFromPixel(px) : (\n
            this.getCachedCenter() || new OpenLayers.LonLat(0, 0));\n
        var res = this.getResolution();\n
        var left = lonlat.add(-res / 2, 0);\n
        var right = lonlat.add(res / 2, 0);\n
        var bottom = lonlat.add(0, -res / 2);\n
        var top = lonlat.add(0, res / 2);\n
        var dest = new OpenLayers.Projection("EPSG:4326");\n
        var source = this.getProjectionObject() || dest;\n
        if(!source.equals(dest)) {\n
            left.transform(source, dest);\n
            right.transform(source, dest);\n
            bottom.transform(source, dest);\n
            top.transform(source, dest);\n
        }\n
        \n
        return new OpenLayers.Size(\n
            OpenLayers.Util.distVincenty(left, right),\n
            OpenLayers.Util.distVincenty(bottom, top)\n
        );\n
    },\n
\n
\n
\n
  //\n
  // TRANSLATION: ViewPortPx <-> LayerPx\n
  //\n
\n
    /**\n
     * APIMethod: getViewPortPxFromLayerPx\n
     * \n
     * Parameters:\n
     * layerPx - {<OpenLayers.Pixel>}\n
     * \n
     * Returns:\n
     * {<OpenLayers.Pixel>} Layer Pixel translated into ViewPort Pixel \n
     *                      coordinates\n
     */\n
    getViewPortPxFromLayerPx:function(layerPx) {\n
        var viewPortPx = null;\n
        if (layerPx != null) {\n
            var dX = parseInt(this.layerContainerDiv.style.left);\n
            var dY = parseInt(this.layerContainerDiv.style.top);\n
            viewPortPx = layerPx.add(dX, dY);            \n
        }\n
        return viewPortPx;\n
    },\n
    \n
    /**\n
     * APIMethod: getLayerPxFromViewPortPx\n
     * \n
     * Parameters:\n
     * viewPortPx - {<OpenLayers.Pixel>}\n
     * \n
     * Returns:\n
     * {<OpenLayers.Pixel>} ViewPort Pixel translated into Layer Pixel \n
     *                      coordinates\n
     */\n
    getLayerPxFromViewPortPx:function(viewPortPx) {\n
        var layerPx = null;\n
        if (viewPortPx != null) {\n
            var dX = -parseInt(this.layerContainerDiv.style.left);\n
            var dY = -parseInt(this.layerContainerDiv.style.top);\n
            layerPx = viewPortPx.add(dX, dY);\n
            if (isNaN(layerPx.x) || isNaN(layerPx.y)) {\n
                layerPx = null;\n
            }\n
        }\n
        return layerPx;\n
    },\n
    \n
  //\n
  // TRANSLATION: LonLat <-> LayerPx\n
  //\n
\n
    /**\n
     * Method: getLonLatFromLayerPx\n
     * \n
     * Parameters:\n
     * px - {<OpenLayers.Pixel>}\n
     *\n
     * Returns:\n
     * {<OpenLayers.LonLat>}\n
     */\n
    getLonLatFromLayerPx: function (px) {\n
       //adjust for displacement of layerContainerDiv\n
       px = this.getViewPortPxFromLayerPx(px);\n
       return this.getLonLatFromViewPortPx(px);         \n
    },\n
    \n
    /**\n
     * APIMethod: getLayerPxFromLonLat\n
     * \n
     * Parameters:\n
     * lonlat - {<OpenLayers.LonLat>} lonlat\n
     *\n
     * Returns:\n
     * {<OpenLayers.Pixel>} An OpenLayers.Pixel which is the passed-in \n
     *                      <OpenLayers.LonLat>, translated into layer pixels \n
     *                      by the current base layer\n
     */\n
    getLayerPxFromLonLat: function (lonlat) {\n
       //adjust for displacement of layerContainerDiv\n
       var px = this.getPixelFromLonLat(lonlat);\n
       return this.getLayerPxFromViewPortPx(px);         \n
    },\n
\n
    CLASS_NAME: "OpenLayers.Map"\n
});\n
\n
/**\n
 * Constant: TILE_WIDTH\n
 * {Integer} 256 Default tile width (unless otherwise specified)\n
 */\n
OpenLayers.Map.TILE_WIDTH = 256;\n
/**\n
 * Constant: TILE_HEIGHT\n
 * {Integer} 256 Default tile height (unless otherwise specified)\n
 */\n
OpenLayers.Map.TILE_HEIGHT = 256;\n


]]></string> </value>
        </item>
      </dictionary>
    </pickle>
  </record>
</ZopeData>
